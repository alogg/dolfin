// This code conforms with the UFC specification version 1.4
// and was automatically generated by FFC version 0.9.1+.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   False
//   epsilon:                        1e-14
//   form_postfix:                   True
//   format:                         'dolfin'
//   log_level:                      20
//   log_prefix:                     ''
//   optimize:                       True
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              'auto'
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False

#ifndef __THSTOKES2D_H
#define __THSTOKES2D_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class thstokes2d_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  thstokes2d_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~thstokes2d_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 2)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues.
    double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables.
    unsigned int rr = 0;
    unsigned int ss = 0;
    unsigned int tt = 0;
    double tmp5 = 0.000000000000000;
    double tmp6 = 0.000000000000000;
    double tmp7 = 0.000000000000000;
    double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
    double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 1; r < 2; r++)
    {
      rr = (r + 1)*((r + 1) + 1)/2;
      ss = r*(r + 1)/2;
      tt = (r - 1)*((r - 1) + 1)/2;
      tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
      basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      rr = (r + 1)*(r + 1 + 1)/2 + 1;
      ss = r*(r + 1)/2;
      basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 1; r++)
    {
      for (unsigned int s = 1; s < 2 - r; s++)
      {
        rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
        ss = (r + s)*(r + s + 1)/2 + s;
        tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
        tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
      }// end loop over 's'
    }// end loop over 'r'
    for (unsigned int r = 0; r < 3; r++)
    {
      for (unsigned int s = 0; s < 3 - r; s++)
      {
        rr = (r + s)*(r + s + 1)/2 + s;
        basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients.
    static const double coefficients0[6][6] = \
    {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
    {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
    {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
    {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
    {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
    {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 6; r++)
    {
      *values += coefficients0[dof][r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues.
    double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables.
    unsigned int rr = 0;
    unsigned int ss = 0;
    unsigned int tt = 0;
    double tmp5 = 0.000000000000000;
    double tmp6 = 0.000000000000000;
    double tmp7 = 0.000000000000000;
    double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
    double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 1; r < 2; r++)
    {
      rr = (r + 1)*((r + 1) + 1)/2;
      ss = r*(r + 1)/2;
      tt = (r - 1)*((r - 1) + 1)/2;
      tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
      basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      rr = (r + 1)*(r + 1 + 1)/2 + 1;
      ss = r*(r + 1)/2;
      basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 1; r++)
    {
      for (unsigned int s = 1; s < 2 - r; s++)
      {
        rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
        ss = (r + s)*(r + s + 1)/2 + s;
        tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
        tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
      }// end loop over 's'
    }// end loop over 'r'
    for (unsigned int r = 0; r < 3; r++)
    {
      for (unsigned int s = 0; s < 3 - r; s++)
      {
        rr = (r + s)*(r + s + 1)/2 + s;
        basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients.
    static const double coefficients0[6][6] = \
    {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
    {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
    {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
    {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
    {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
    {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[6][6] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {4.898979485566355, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {3.999999999999999, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    static const double dmats1[6][6] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.581988897471611, 4.743416490252570, -0.912870929175278, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {1.999999999999999, 6.123724356957944, 3.535533905932737, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[6][6] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[6][6] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 6; t++)
      {
        for (unsigned int u = 0; u < 6; u++)
        {
          dmats[t][u] = 0.000000000000000;
          if (t == u)
          {
          dmats[t][u] = 1.000000000000000;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.000000000000000;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            for (unsigned int tu = 0; tu < 6; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            for (unsigned int tu = 0; tu < 6; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 6; s++)
      {
        for (unsigned int t = 0; t < 6; t++)
        {
          derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a finite element.

class thstokes2d_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  thstokes2d_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~thstokes2d_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    if (0 <= i && i <= 5)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
    if (6 <= i && i <= 11)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 6;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    if (0 <= i && i <= 5)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566355, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252570, -0.912870929175278, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957944, 3.535533905932737, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
    }
    
    if (6 <= i && i <= 11)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 6;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566355, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252570, -0.912870929175278, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957944, 3.535533905932737, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_finite_element_0();
        break;
      }
    case 1:
      {
        return new thstokes2d_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for a finite element.

class thstokes2d_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  thstokes2d_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~thstokes2d_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues.
    double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables.
    unsigned int rr = 0;
    unsigned int ss = 0;
    double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 0; r < 1; r++)
    {
      rr = (r + 1)*(r + 1 + 1)/2 + 1;
      ss = r*(r + 1)/2;
      basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      for (unsigned int s = 0; s < 2 - r; s++)
      {
        rr = (r + s)*(r + s + 1)/2 + s;
        basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients.
    static const double coefficients0[3][3] = \
    {{0.471404520791032, -0.288675134594813, -0.166666666666667},
    {0.471404520791032, 0.288675134594813, -0.166666666666667},
    {0.471404520791032, 0.000000000000000, 0.333333333333333}};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 3; r++)
    {
      *values += coefficients0[dof][r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues.
    double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables.
    unsigned int rr = 0;
    unsigned int ss = 0;
    double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 0; r < 1; r++)
    {
      rr = (r + 1)*(r + 1 + 1)/2 + 1;
      ss = r*(r + 1)/2;
      basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      for (unsigned int s = 0; s < 2 - r; s++)
      {
        rr = (r + s)*(r + s + 1)/2 + s;
        basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients.
    static const double coefficients0[3][3] = \
    {{0.471404520791032, -0.288675134594813, -0.166666666666667},
    {0.471404520791032, 0.288675134594813, -0.166666666666667},
    {0.471404520791032, 0.000000000000000, 0.333333333333333}};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[3][3] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000},
    {4.898979485566356, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    static const double dmats1[3][3] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.449489742783178, 0.000000000000000, 0.000000000000000},
    {4.242640687119285, 0.000000000000000, 0.000000000000000}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[3][3] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[3][3] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 3; t++)
      {
        for (unsigned int u = 0; u < 3; u++)
        {
          dmats[t][u] = 0.000000000000000;
          if (t == u)
          {
          dmats[t][u] = 1.000000000000000;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.000000000000000;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            for (unsigned int tu = 0; tu < 3; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            for (unsigned int tu = 0; tu < 3; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 3; s++)
      {
        for (unsigned int t = 0; t < 3; t++)
        {
          derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a finite element.

class thstokes2d_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  thstokes2d_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~thstokes2d_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    values[2] = 0.000000000000000;
    if (0 <= i && i <= 5)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
    if (6 <= i && i <= 11)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 6;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
    if (12 <= i && i <= 14)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 12;
      
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3][3] = \
      {{0.471404520791032, -0.288675134594813, -0.166666666666667},
      {0.471404520791032, 0.288675134594813, -0.166666666666667},
      {0.471404520791032, 0.000000000000000, 0.333333333333333}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    if (0 <= i && i <= 5)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566355, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252570, -0.912870929175278, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957944, 3.535533905932737, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
    }
    
    if (6 <= i && i <= 11)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 6;
      
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6][6] = \
      {{0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182},
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545},
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545},
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545},
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566355, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252570, -0.912870929175278, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957944, 3.535533905932737, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
    }
    
    if (12 <= i && i <= 14)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 12;
      
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3][3] = \
      {{0.471404520791032, -0.288675134594813, -0.166666666666667},
      {0.471404520791032, 0.288675134594813, -0.166666666666667},
      {0.471404520791032, 0.000000000000000, 0.333333333333333}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_finite_element_1();
        break;
      }
    case 1:
      {
        return new thstokes2d_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class thstokes2d_dof_map_0: public ufc::dof_map
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  thstokes2d_dof_map_0() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~thstokes2d_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 2)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0] + m.num_entities[1];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 6;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 6;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 1;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class thstokes2d_dof_map_1: public ufc::dof_map
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  thstokes2d_dof_map_1() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~thstokes2d_dof_map_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 2.000000000000000*m.num_entities[0] + 2.000000000000000*m.num_entities[1];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 6;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[9][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[10][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[10][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[11][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[11][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 2;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_dof_map_0();
        break;
      }
    case 1:
      {
        return new thstokes2d_dof_map_0();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class thstokes2d_dof_map_2: public ufc::dof_map
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  thstokes2d_dof_map_2() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~thstokes2d_dof_map_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 3;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 3;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 2;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class thstokes2d_dof_map_3: public ufc::dof_map
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  thstokes2d_dof_map_3() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~thstokes2d_dof_map_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3.000000000000000*m.num_entities[0] + 2.000000000000000*m.num_entities[1];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[12] = offset + c.entity_indices[0][0];
    dofs[13] = offset + c.entity_indices[0][1];
    dofs[14] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
      dofs[6] = 12;
      dofs[7] = 14;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
      dofs[6] = 12;
      dofs[7] = 13;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
        dofs[2] = 12;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
        dofs[2] = 13;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
        dofs[2] = 14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[9][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[10][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[10][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[11][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[11][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[12][0] = x[0][0];
    coordinates[12][1] = x[0][1];
    coordinates[13][0] = x[1][0];
    coordinates[13][1] = x[1][1];
    coordinates[14][0] = x[2][0];
    coordinates[14][1] = x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 2;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_dof_map_1();
        break;
      }
    case 1:
      {
        return new thstokes2d_dof_map_2();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class thstokes2d_cell_integral_0_0: public ufc::cell_integral
{
public:

  /// Constructor
  thstokes2d_cell_integral_0_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~thstokes2d_cell_integral_0_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      11
    // Number of operations (multiply-add pairs) for geometry tensor:    32
    // Number of operations (multiply-add pairs) for tensor contraction: 873
    // Total number of operations (multiply-add pairs):                  916
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K_00*(1.0);
    const double G0_1 = det*K_10*(1.0);
    const double G1_0 = det*K_01*(1.0);
    const double G1_1 = det*K_11*(1.0);
    const double G2_0 = det*K_00*(1.0);
    const double G2_1 = det*K_10*(1.0);
    const double G3_0 = det*K_01*(1.0);
    const double G3_1 = det*K_11*(1.0);
    const double G4_0_0 = det*K_00*K_00*(1.0);
    const double G4_0_1 = det*K_00*K_10*(1.0);
    const double G4_1_0 = det*K_10*K_00*(1.0);
    const double G4_1_1 = det*K_10*K_10*(1.0);
    const double G5_0_0 = det*K_00*K_00*(1.0);
    const double G5_0_1 = det*K_00*K_10*(1.0);
    const double G5_1_0 = det*K_10*K_00*(1.0);
    const double G5_1_1 = det*K_10*K_10*(1.0);
    const double G6_0_0 = det*K_01*K_01*(1.0);
    const double G6_0_1 = det*K_01*K_11*(1.0);
    const double G6_1_0 = det*K_11*K_01*(1.0);
    const double G6_1_1 = det*K_11*K_11*(1.0);
    const double G7_0_0 = det*K_01*K_01*(1.0);
    const double G7_0_1 = det*K_01*K_11*(1.0);
    const double G7_1_0 = det*K_11*K_01*(1.0);
    const double G7_1_1 = det*K_11*K_11*(1.0);
    
    // Compute element tensor
    double A0[225];
    A0[108] = 0.000000000000000;
    A0[99] = 0.000000000000000;
    A0[181] = 0.000000000000000;
    A0[176] = 0.000000000000000;
    A0[117] = 0.000000000000000;
    A0[199] = -0.166666666666666*G0_0;
    A0[192] = 0.000000000000000;
    A0[7] = 0.000000000000000;
    A0[21] = 0.000000000000000;
    A0[10] = 0.000000000000000;
    A0[52] = 0.000000000000000;
    A0[35] = 0.000000000000000;
    A0[26] = 0.000000000000000;
    A0[125] = 0.000000000000000;
    A0[83] = 0.000000000000000;
    A0[60] = 0.000000000000000;
    A0[158] = 0.000000000000000;
    A0[135] = 0.000000000000000;
    A0[97] = 0.000000000000000;
    A0[80] = 0.000000000000000;
    A0[170] = 0.000000000000000;
    A0[157] = 0.000000000000000;
    A0[111] = 0.000000000000000;
    A0[100] = 0.000000000000000;
    A0[186] = 0.000000000000000;
    A0[211] = 0.000000000000000;
    A0[202] = 0.000000000000000;
    A0[4] = 0.000000000000000;
    A0[16] = 0.000000000000000;
    A0[70] = 0.000000000000000;
    A0[47] = 0.000000000000000;
    A0[36] = 0.000000000000000;
    A0[149] = 0.000000000000000;
    A0[122] = 0.000000000000000;
    A0[86] = 0.000000000000000;
    A0[65] = 0.000000000000000;
    A0[163] = 0.000000000000000;
    A0[138] = 0.000000000000000;
    A0[90] = 0.000000000000000;
    A0[165] = 0.000000000000000;
    A0[110] = 0.000000000000000;
    A0[191] = 0.000000000000000;
    A0[212] = 0.166666666666666*G0_1;
    A0[214] = -A0[212] - 0.333333333333333*G0_0;
    A0[205] = 0.000000000000000;
    A0[1] = 0.000000000000000;
    A0[57] = 0.000000000000000;
    A0[27] = 0.000000000000000;
    A0[132] = 0.000000000000000;
    A0[46] = 0.000000000000000;
    A0[41] = 0.000000000000000;
    A0[144] = 0.000000000000000;
    A0[89] = 0.000000000000000;
    A0[164] = 0.000000000000000;
    A0[103] = 0.000000000000000;
    A0[113] = 0.000000000000000;
    A0[218] = 0.000000000000000;
    A0[195] = 0.000000000000000;
    A0[188] = 0.000000000000000;
    A0[208] = 0.000000000000000;
    A0[14] = 0.000000000000000;
    A0[56] = 0.000000000000000;
    A0[31] = 0.000000000000000;
    A0[129] = 0.000000000000000;
    A0[72] = 0.000000000000000;
    A0[42] = 0.000000000000000;
    A0[139] = 0.000000000000000;
    A0[76] = 0.000000000000000;
    A0[153] = 0.000000000000000;
    A0[107] = 0.000000000000000;
    A0[104] = 0.000000000000000;
    A0[182] = 0.000000000000000;
    A0[175] = 0.000000000000000;
    A0[215] = -A0[212];
    A0[198] = -A0[199] + 0.333333333333332*G0_1;
    A0[193] = 0.000000000000000;
    A0[20] = 0.000000000000000;
    A0[11] = 0.000000000000000;
    A0[51] = 0.000000000000000;
    A0[32] = 0.000000000000000;
    A0[25] = 0.000000000000000;
    A0[126] = 0.000000000000000;
    A0[61] = 0.000000000000000;
    A0[159] = 0.000000000000000;
    A0[142] = 0.000000000000000;
    A0[94] = 0.000000000000000;
    A0[79] = 0.000000000000000;
    A0[169] = 0.000000000000000;
    A0[154] = 0.000000000000000;
    A0[106] = 0.000000000000000;
    A0[101] = 0.000000000000000;
    A0[187] = 0.000000000000000;
    A0[174] = 0.000000000000000;
    A0[216] = 0.000000000000000;
    A0[201] = 0.000000000000000;
    A0[5] = 0.000000000000000;
    A0[15] = 0.000000000000000;
    A0[8] = 0.000000000000000;
    A0[71] = 0.000000000000000;
    A0[50] = 0.000000000000000;
    A0[37] = 0.000000000000000;
    A0[148] = 0.000000000000000;
    A0[123] = 0.000000000000000;
    A0[85] = 0.000000000000000;
    A0[66] = 0.000000000000000;
    A0[160] = 0.000000000000000;
    A0[137] = 0.000000000000000;
    A0[91] = 0.000000000000000;
    A0[82] = 0.000000000000000;
    A0[168] = 0.000000000000000;
    A0[109] = 0.000000000000000;
    A0[222] = 0.000000000000000;
    A0[184] = A0[199] + 0.166666666666666*G0_1;
    A0[213] = -A0[214];
    A0[204] = 0.000000000000000;
    A0[2] = 0.000000000000000;
    A0[18] = 0.000000000000000;
    A0[133] = 0.000000000000000;
    A0[68] = 0.000000000000000;
    A0[45] = 0.000000000000000;
    A0[38] = 0.000000000000000;
    A0[143] = 0.000000000000000;
    A0[120] = 0.000000000000000;
    A0[88] = 0.000000000000000;
    A0[92] = 0.000000000000000;
    A0[179] = 0.000000000000000;
    A0[116] = 0.000000000000000;
    A0[219] = 0.000000000000000;
    A0[189] = 0.000000000000000;
    A0[207] = 0.000000000000000;
    A0[55] = 0.000000000000000;
    A0[29] = 0.000000000000000;
    A0[130] = 0.000000000000000;
    A0[73] = 0.000000000000000;
    A0[43] = 0.000000000000000;
    A0[146] = 0.000000000000000;
    A0[75] = 0.000000000000000;
    A0[150] = 0.000000000000000;
    A0[183] = -A0[199] + 0.166666666666666*G0_1;
    A0[178] = 0.000000000000000;
    A0[119] = 0.000000000000000;
    A0[220] = 0.000000000000000;
    A0[197] = 0.000000000000000;
    A0[194] = 0.000000000000000;
    A0[19] = 0.000000000000000;
    A0[12] = 0.000000000000000;
    A0[54] = 0.000000000000000;
    A0[33] = 0.000000000000000;
    A0[24] = 0.000000000000000;
    A0[127] = 0.000000000000000;
    A0[62] = 0.000000000000000;
    A0[44] = 0.000000000000000;
    A0[141] = 0.000000000000000;
    A0[95] = 0.000000000000000;
    A0[78] = 0.000000000000000;
    A0[172] = 0.000000000000000;
    A0[155] = 0.000000000000000;
    A0[105] = 0.000000000000000;
    A0[98] = 0.000000000000000;
    A0[180] = -A0[183];
    A0[173] = 0.000000000000000;
    A0[118] = 0.000000000000000;
    A0[217] = 0.000000000000000;
    A0[200] = -A0[198];
    A0[6] = 0.000000000000000;
    A0[22] = 0.000000000000000;
    A0[9] = 0.000000000000000;
    A0[49] = 0.000000000000000;
    A0[34] = 0.000000000000000;
    A0[147] = 0.000000000000000;
    A0[124] = 0.000000000000000;
    A0[84] = 0.000000000000000;
    A0[67] = 0.000000000000000;
    A0[161] = 0.000000000000000;
    A0[136] = 0.000000000000000;
    A0[96] = 0.000000000000000;
    A0[81] = 0.000000000000000;
    A0[167] = 0.000000000000000;
    A0[156] = 0.000000000000000;
    A0[112] = 0.000000000000000;
    A0[223] = 0.000000000000000;
    A0[185] = -A0[184];
    A0[210] = 0.000000000000000;
    A0[203] = 0.000000000000000;
    A0[3] = 0.000000000000000;
    A0[59] = 0.000000000000000;
    A0[17] = 0.000000000000000;
    A0[134] = 0.000000000000000;
    A0[69] = 0.000000000000000;
    A0[48] = 0.000000000000000;
    A0[39] = 0.000000000000000;
    A0[121] = 0.000000000000000;
    A0[87] = 0.000000000000000;
    A0[64] = 0.000000000000000;
    A0[162] = 0.000000000000000;
    A0[93] = 0.000000000000000;
    A0[166] = 0.000000000000000;
    A0[115] = 0.000000000000000;
    A0[224] = 0.000000000000000;
    A0[190] = 0.000000000000000;
    A0[206] = 0.000000000000000;
    A0[0] = 0.000000000000000;
    A0[58] = 0.000000000000000;
    A0[28] = 0.000000000000000;
    A0[131] = 0.000000000000000;
    A0[74] = 0.000000000000000;
    A0[40] = 0.000000000000000;
    A0[145] = 0.000000000000000;
    A0[151] = 0.000000000000000;
    A0[102] = 0.000000000000000;
    A0[177] = 0.000000000000000;
    A0[114] = 0.000000000000000;
    A0[221] = 0.000000000000000;
    A0[196] = -A0[199];
    A0[209] = 0.000000000000000;
    A0[13] = 0.000000000000000;
    A0[53] = 0.000000000000000;
    A0[30] = 0.000000000000000;
    A0[23] = 0.000000000000000;
    A0[128] = 0.000000000000000;
    A0[63] = 0.000000000000000;
    A0[140] = 0.000000000000000;
    A0[77] = 0.000000000000000;
    A0[171] = 0.000000000000000;
    A0[152] = 0.000000000000000;
    
    double A1[225];
    A1[108] = 0.000000000000000;
    A1[99] = 0.000000000000000;
    A1[181] = 0.000000000000000;
    A1[176] = 0.000000000000000;
    A1[117] = 0.000000000000000;
    A1[214] = 0.000000000000000;
    A1[199] = 0.000000000000000;
    A1[192] = 0.000000000000000;
    A1[7] = 0.000000000000000;
    A1[21] = 0.000000000000000;
    A1[10] = 0.000000000000000;
    A1[52] = 0.000000000000000;
    A1[35] = 0.000000000000000;
    A1[26] = 0.000000000000000;
    A1[125] = 0.000000000000000;
    A1[83] = 0.000000000000000;
    A1[60] = 0.000000000000000;
    A1[158] = 0.000000000000000;
    A1[135] = 0.000000000000000;
    A1[97] = 0.000000000000000;
    A1[80] = 0.000000000000000;
    A1[170] = 0.000000000000000;
    A1[157] = 0.000000000000000;
    A1[111] = 0.000000000000000;
    A1[100] = 0.000000000000000;
    A1[211] = 0.000000000000000;
    A1[202] = 0.166666666666666*G1_0;
    A1[186] = -A1[202] - 0.166666666666666*G1_1;
    A1[4] = 0.000000000000000;
    A1[16] = 0.000000000000000;
    A1[70] = 0.000000000000000;
    A1[47] = 0.000000000000000;
    A1[36] = 0.000000000000000;
    A1[149] = 0.000000000000000;
    A1[122] = 0.000000000000000;
    A1[86] = 0.000000000000000;
    A1[65] = 0.000000000000000;
    A1[163] = 0.000000000000000;
    A1[138] = 0.000000000000000;
    A1[90] = 0.000000000000000;
    A1[165] = 0.000000000000000;
    A1[110] = 0.000000000000000;
    A1[191] = A1[202] - 0.166666666666666*G1_1;
    A1[212] = 0.000000000000000;
    A1[205] = -A1[202];
    A1[1] = 0.000000000000000;
    A1[57] = 0.000000000000000;
    A1[27] = 0.000000000000000;
    A1[132] = 0.000000000000000;
    A1[46] = 0.000000000000000;
    A1[41] = 0.000000000000000;
    A1[144] = 0.000000000000000;
    A1[89] = 0.000000000000000;
    A1[164] = 0.000000000000000;
    A1[103] = 0.000000000000000;
    A1[113] = 0.000000000000000;
    A1[218] = 0.166666666666666*G1_1;
    A1[195] = 0.000000000000000;
    A1[188] = 0.000000000000000;
    A1[208] = 0.000000000000000;
    A1[14] = 0.000000000000000;
    A1[56] = 0.000000000000000;
    A1[31] = 0.000000000000000;
    A1[129] = 0.000000000000000;
    A1[72] = 0.000000000000000;
    A1[42] = 0.000000000000000;
    A1[139] = 0.000000000000000;
    A1[76] = 0.000000000000000;
    A1[153] = 0.000000000000000;
    A1[107] = 0.000000000000000;
    A1[104] = 0.000000000000000;
    A1[182] = 0.000000000000000;
    A1[175] = 0.000000000000000;
    A1[215] = 0.000000000000000;
    A1[198] = 0.000000000000000;
    A1[193] = 0.000000000000000;
    A1[20] = 0.000000000000000;
    A1[11] = 0.000000000000000;
    A1[51] = 0.000000000000000;
    A1[32] = 0.000000000000000;
    A1[25] = 0.000000000000000;
    A1[126] = 0.000000000000000;
    A1[61] = 0.000000000000000;
    A1[159] = 0.000000000000000;
    A1[142] = 0.000000000000000;
    A1[94] = 0.000000000000000;
    A1[79] = 0.000000000000000;
    A1[169] = 0.000000000000000;
    A1[154] = 0.000000000000000;
    A1[106] = 0.000000000000000;
    A1[101] = 0.000000000000000;
    A1[187] = 0.000000000000000;
    A1[174] = 0.000000000000000;
    A1[216] = 0.000000000000000;
    A1[201] = 0.000000000000000;
    A1[5] = 0.000000000000000;
    A1[15] = 0.000000000000000;
    A1[8] = 0.000000000000000;
    A1[71] = 0.000000000000000;
    A1[50] = 0.000000000000000;
    A1[37] = 0.000000000000000;
    A1[148] = 0.000000000000000;
    A1[123] = 0.000000000000000;
    A1[85] = 0.000000000000000;
    A1[66] = 0.000000000000000;
    A1[160] = 0.000000000000000;
    A1[137] = 0.000000000000000;
    A1[91] = 0.000000000000000;
    A1[82] = 0.000000000000000;
    A1[168] = 0.000000000000000;
    A1[109] = 0.000000000000000;
    A1[222] = 0.000000000000000;
    A1[184] = 0.000000000000000;
    A1[213] = 0.000000000000000;
    A1[204] = A1[202] + 0.333333333333333*G1_1;
    A1[2] = 0.000000000000000;
    A1[18] = 0.000000000000000;
    A1[133] = 0.000000000000000;
    A1[68] = 0.000000000000000;
    A1[45] = 0.000000000000000;
    A1[38] = 0.000000000000000;
    A1[143] = 0.000000000000000;
    A1[120] = 0.000000000000000;
    A1[88] = 0.000000000000000;
    A1[92] = 0.000000000000000;
    A1[179] = 0.000000000000000;
    A1[116] = 0.000000000000000;
    A1[219] = -A1[186] + 0.166666666666666*G1_0;
    A1[189] = -A1[186];
    A1[207] = 0.000000000000000;
    A1[55] = 0.000000000000000;
    A1[29] = 0.000000000000000;
    A1[130] = 0.000000000000000;
    A1[73] = 0.000000000000000;
    A1[43] = 0.000000000000000;
    A1[146] = 0.000000000000000;
    A1[75] = 0.000000000000000;
    A1[150] = 0.000000000000000;
    A1[183] = 0.000000000000000;
    A1[178] = 0.000000000000000;
    A1[119] = 0.000000000000000;
    A1[220] = -A1[219];
    A1[197] = 0.000000000000000;
    A1[194] = 0.000000000000000;
    A1[19] = 0.000000000000000;
    A1[12] = 0.000000000000000;
    A1[54] = 0.000000000000000;
    A1[33] = 0.000000000000000;
    A1[24] = 0.000000000000000;
    A1[127] = 0.000000000000000;
    A1[62] = 0.000000000000000;
    A1[44] = 0.000000000000000;
    A1[141] = 0.000000000000000;
    A1[95] = 0.000000000000000;
    A1[78] = 0.000000000000000;
    A1[172] = 0.000000000000000;
    A1[155] = 0.000000000000000;
    A1[105] = 0.000000000000000;
    A1[98] = 0.000000000000000;
    A1[180] = 0.000000000000000;
    A1[173] = 0.000000000000000;
    A1[118] = 0.000000000000000;
    A1[217] = 0.000000000000000;
    A1[200] = 0.000000000000000;
    A1[6] = 0.000000000000000;
    A1[22] = 0.000000000000000;
    A1[9] = 0.000000000000000;
    A1[49] = 0.000000000000000;
    A1[34] = 0.000000000000000;
    A1[147] = 0.000000000000000;
    A1[124] = 0.000000000000000;
    A1[84] = 0.000000000000000;
    A1[67] = 0.000000000000000;
    A1[161] = 0.000000000000000;
    A1[136] = 0.000000000000000;
    A1[96] = 0.000000000000000;
    A1[81] = 0.000000000000000;
    A1[167] = 0.000000000000000;
    A1[156] = 0.000000000000000;
    A1[112] = 0.000000000000000;
    A1[223] = 0.000000000000000;
    A1[185] = 0.000000000000000;
    A1[210] = 0.000000000000000;
    A1[203] = 0.000000000000000;
    A1[3] = 0.000000000000000;
    A1[59] = 0.000000000000000;
    A1[17] = 0.000000000000000;
    A1[134] = 0.000000000000000;
    A1[69] = 0.000000000000000;
    A1[48] = 0.000000000000000;
    A1[39] = 0.000000000000000;
    A1[121] = 0.000000000000000;
    A1[87] = 0.000000000000000;
    A1[64] = 0.000000000000000;
    A1[162] = 0.000000000000000;
    A1[93] = 0.000000000000000;
    A1[166] = 0.000000000000000;
    A1[115] = 0.000000000000000;
    A1[224] = 0.000000000000000;
    A1[190] = -A1[191];
    A1[206] = -A1[204];
    A1[0] = 0.000000000000000;
    A1[58] = 0.000000000000000;
    A1[28] = 0.000000000000000;
    A1[131] = 0.000000000000000;
    A1[74] = 0.000000000000000;
    A1[40] = 0.000000000000000;
    A1[145] = 0.000000000000000;
    A1[151] = 0.000000000000000;
    A1[102] = 0.000000000000000;
    A1[177] = 0.000000000000000;
    A1[114] = 0.000000000000000;
    A1[221] = -A1[218];
    A1[196] = 0.000000000000000;
    A1[209] = 0.000000000000000;
    A1[13] = 0.000000000000000;
    A1[53] = 0.000000000000000;
    A1[30] = 0.000000000000000;
    A1[23] = 0.000000000000000;
    A1[128] = 0.000000000000000;
    A1[63] = 0.000000000000000;
    A1[140] = 0.000000000000000;
    A1[77] = 0.000000000000000;
    A1[171] = 0.000000000000000;
    A1[152] = 0.000000000000000;
    
    double A2[225];
    A2[108] = 0.000000000000000;
    A2[99] = 0.000000000000000;
    A2[181] = 0.000000000000000;
    A2[176] = 0.000000000000000;
    A2[117] = 0.000000000000000;
    A2[214] = 0.000000000000000;
    A2[199] = 0.000000000000000;
    A2[192] = 0.000000000000000;
    A2[7] = 0.000000000000000;
    A2[21] = 0.000000000000000;
    A2[10] = 0.000000000000000;
    A2[52] = 0.000000000000000;
    A2[35] = 0.000000000000000;
    A2[26] = 0.000000000000000;
    A2[125] = 0.000000000000000;
    A2[83] = 0.000000000000000;
    A2[60] = 0.000000000000000;
    A2[158] = 0.000000000000000;
    A2[135] = 0.000000000000000;
    A2[97] = 0.000000000000000;
    A2[80] = 0.000000000000000;
    A2[170] = 0.000000000000000;
    A2[157] = 0.000000000000000;
    A2[111] = 0.000000000000000;
    A2[100] = 0.000000000000000;
    A2[186] = 0.000000000000000;
    A2[211] = 0.000000000000000;
    A2[202] = 0.000000000000000;
    A2[4] = 0.000000000000000;
    A2[16] = 0.000000000000000;
    A2[70] = 0.000000000000000;
    A2[47] = 0.000000000000000;
    A2[36] = 0.000000000000000;
    A2[149] = 0.000000000000000;
    A2[122] = 0.000000000000000;
    A2[86] = 0.000000000000000;
    A2[65] = 0.000000000000000;
    A2[163] = 0.000000000000000;
    A2[138] = 0.000000000000000;
    A2[90] = 0.000000000000000;
    A2[165] = 0.000000000000000;
    A2[110] = 0.000000000000000;
    A2[191] = 0.000000000000000;
    A2[212] = 0.000000000000000;
    A2[205] = 0.000000000000000;
    A2[1] = 0.000000000000000;
    A2[27] = 0.000000000000000;
    A2[132] = 0.000000000000000;
    A2[46] = 0.000000000000000;
    A2[41] = 0.000000000000000;
    A2[144] = 0.000000000000000;
    A2[89] = 0.166666666666666*G2_1;
    A2[57] = -A2[89] - 0.166666666666666*G2_0;
    A2[164] = 0.000000000000000;
    A2[103] = 0.000000000000000;
    A2[113] = 0.000000000000000;
    A2[218] = 0.000000000000000;
    A2[195] = 0.000000000000000;
    A2[188] = 0.000000000000000;
    A2[208] = 0.000000000000000;
    A2[14] = 0.000000000000000;
    A2[56] = 0.000000000000000;
    A2[31] = 0.000000000000000;
    A2[129] = 0.000000000000000;
    A2[72] = -A2[89] + 0.166666666666666*G2_0;
    A2[42] = 0.000000000000000;
    A2[139] = 0.000000000000000;
    A2[76] = 0.000000000000000;
    A2[153] = 0.000000000000000;
    A2[107] = 0.000000000000000;
    A2[104] = 0.000000000000000;
    A2[182] = 0.000000000000000;
    A2[175] = 0.000000000000000;
    A2[215] = 0.000000000000000;
    A2[198] = 0.000000000000000;
    A2[193] = 0.000000000000000;
    A2[20] = 0.000000000000000;
    A2[11] = 0.000000000000000;
    A2[51] = 0.000000000000000;
    A2[32] = 0.000000000000000;
    A2[25] = 0.000000000000000;
    A2[126] = 0.000000000000000;
    A2[61] = 0.000000000000000;
    A2[159] = 0.000000000000000;
    A2[142] = 0.000000000000000;
    A2[94] = 0.000000000000000;
    A2[79] = 0.000000000000000;
    A2[169] = 0.000000000000000;
    A2[154] = 0.000000000000000;
    A2[106] = 0.000000000000000;
    A2[101] = 0.000000000000000;
    A2[187] = 0.000000000000000;
    A2[174] = 0.000000000000000;
    A2[216] = 0.000000000000000;
    A2[201] = 0.000000000000000;
    A2[5] = 0.000000000000000;
    A2[15] = 0.000000000000000;
    A2[8] = 0.000000000000000;
    A2[71] = 0.000000000000000;
    A2[50] = 0.000000000000000;
    A2[37] = 0.000000000000000;
    A2[148] = 0.000000000000000;
    A2[123] = 0.000000000000000;
    A2[85] = 0.000000000000000;
    A2[66] = 0.000000000000000;
    A2[160] = 0.000000000000000;
    A2[137] = 0.000000000000000;
    A2[91] = 0.000000000000000;
    A2[82] = 0.000000000000000;
    A2[168] = 0.000000000000000;
    A2[109] = 0.000000000000000;
    A2[222] = 0.000000000000000;
    A2[184] = 0.000000000000000;
    A2[213] = 0.000000000000000;
    A2[204] = 0.000000000000000;
    A2[2] = 0.000000000000000;
    A2[18] = 0.000000000000000;
    A2[133] = 0.000000000000000;
    A2[68] = 0.000000000000000;
    A2[45] = 0.000000000000000;
    A2[38] = 0.000000000000000;
    A2[143] = 0.000000000000000;
    A2[120] = 0.000000000000000;
    A2[88] = -A2[57] + 0.166666666666666*G2_1;
    A2[92] = 0.000000000000000;
    A2[179] = 0.000000000000000;
    A2[116] = 0.000000000000000;
    A2[219] = 0.000000000000000;
    A2[189] = 0.000000000000000;
    A2[207] = 0.000000000000000;
    A2[55] = 0.000000000000000;
    A2[29] = 0.000000000000000;
    A2[130] = 0.000000000000000;
    A2[73] = 0.166666666666666*G2_0;
    A2[43] = 0.000000000000000;
    A2[146] = 0.000000000000000;
    A2[75] = 0.000000000000000;
    A2[150] = 0.000000000000000;
    A2[183] = 0.000000000000000;
    A2[178] = 0.000000000000000;
    A2[119] = 0.000000000000000;
    A2[220] = 0.000000000000000;
    A2[197] = 0.000000000000000;
    A2[194] = 0.000000000000000;
    A2[19] = 0.000000000000000;
    A2[12] = -A2[57];
    A2[54] = 0.000000000000000;
    A2[33] = 0.000000000000000;
    A2[24] = 0.000000000000000;
    A2[127] = 0.000000000000000;
    A2[62] = 0.000000000000000;
    A2[44] = -A2[89];
    A2[141] = 0.000000000000000;
    A2[95] = 0.000000000000000;
    A2[78] = 0.000000000000000;
    A2[172] = 0.000000000000000;
    A2[155] = 0.000000000000000;
    A2[105] = 0.000000000000000;
    A2[98] = 0.000000000000000;
    A2[180] = 0.000000000000000;
    A2[173] = 0.000000000000000;
    A2[118] = 0.000000000000000;
    A2[217] = 0.000000000000000;
    A2[200] = 0.000000000000000;
    A2[6] = 0.000000000000000;
    A2[22] = 0.000000000000000;
    A2[9] = 0.000000000000000;
    A2[49] = 0.000000000000000;
    A2[34] = 0.000000000000000;
    A2[147] = 0.000000000000000;
    A2[124] = 0.000000000000000;
    A2[84] = 0.000000000000000;
    A2[67] = 0.000000000000000;
    A2[161] = 0.000000000000000;
    A2[136] = 0.000000000000000;
    A2[96] = 0.000000000000000;
    A2[81] = 0.000000000000000;
    A2[167] = 0.000000000000000;
    A2[156] = 0.000000000000000;
    A2[112] = 0.000000000000000;
    A2[223] = 0.000000000000000;
    A2[185] = 0.000000000000000;
    A2[210] = 0.000000000000000;
    A2[203] = 0.000000000000000;
    A2[3] = 0.000000000000000;
    A2[59] = -A2[89] - 0.333333333333333*G2_0;
    A2[17] = 0.000000000000000;
    A2[134] = 0.000000000000000;
    A2[69] = 0.000000000000000;
    A2[48] = 0.000000000000000;
    A2[39] = 0.000000000000000;
    A2[121] = 0.000000000000000;
    A2[87] = -A2[72];
    A2[64] = 0.000000000000000;
    A2[162] = 0.000000000000000;
    A2[93] = 0.000000000000000;
    A2[166] = 0.000000000000000;
    A2[115] = 0.000000000000000;
    A2[224] = 0.000000000000000;
    A2[190] = 0.000000000000000;
    A2[206] = 0.000000000000000;
    A2[0] = 0.000000000000000;
    A2[58] = -A2[88];
    A2[28] = -A2[73];
    A2[131] = 0.000000000000000;
    A2[74] = -A2[59];
    A2[40] = 0.000000000000000;
    A2[145] = 0.000000000000000;
    A2[151] = 0.000000000000000;
    A2[102] = 0.000000000000000;
    A2[177] = 0.000000000000000;
    A2[114] = 0.000000000000000;
    A2[221] = 0.000000000000000;
    A2[196] = 0.000000000000000;
    A2[209] = 0.000000000000000;
    A2[13] = 0.000000000000000;
    A2[53] = 0.000000000000000;
    A2[30] = 0.000000000000000;
    A2[23] = 0.000000000000000;
    A2[128] = 0.000000000000000;
    A2[63] = 0.000000000000000;
    A2[140] = 0.000000000000000;
    A2[77] = 0.000000000000000;
    A2[171] = 0.000000000000000;
    A2[152] = 0.000000000000000;
    
    double A3[225];
    A3[108] = 0.000000000000000;
    A3[99] = 0.000000000000000;
    A3[181] = 0.000000000000000;
    A3[176] = 0.000000000000000;
    A3[117] = 0.000000000000000;
    A3[214] = 0.000000000000000;
    A3[199] = 0.000000000000000;
    A3[192] = 0.000000000000000;
    A3[7] = 0.000000000000000;
    A3[21] = 0.000000000000000;
    A3[10] = 0.000000000000000;
    A3[52] = 0.000000000000000;
    A3[35] = 0.000000000000000;
    A3[26] = 0.000000000000000;
    A3[125] = 0.000000000000000;
    A3[83] = 0.000000000000000;
    A3[60] = 0.000000000000000;
    A3[158] = 0.000000000000000;
    A3[135] = 0.000000000000000;
    A3[97] = 0.000000000000000;
    A3[80] = 0.000000000000000;
    A3[170] = 0.000000000000000;
    A3[157] = 0.000000000000000;
    A3[111] = 0.000000000000000;
    A3[100] = 0.000000000000000;
    A3[186] = 0.000000000000000;
    A3[211] = 0.000000000000000;
    A3[202] = 0.000000000000000;
    A3[4] = 0.000000000000000;
    A3[16] = 0.000000000000000;
    A3[70] = 0.000000000000000;
    A3[47] = 0.000000000000000;
    A3[36] = 0.000000000000000;
    A3[122] = 0.000000000000000;
    A3[86] = 0.000000000000000;
    A3[65] = 0.000000000000000;
    A3[163] = 0.166666666666666*G3_0;
    A3[138] = 0.000000000000000;
    A3[90] = 0.000000000000000;
    A3[165] = 0.000000000000000;
    A3[110] = 0.000000000000000;
    A3[191] = 0.000000000000000;
    A3[212] = 0.000000000000000;
    A3[205] = 0.000000000000000;
    A3[1] = 0.000000000000000;
    A3[57] = 0.000000000000000;
    A3[27] = 0.000000000000000;
    A3[132] = 0.000000000000000;
    A3[46] = 0.000000000000000;
    A3[41] = 0.000000000000000;
    A3[144] = 0.000000000000000;
    A3[89] = 0.000000000000000;
    A3[103] = 0.000000000000000;
    A3[113] = 0.000000000000000;
    A3[218] = 0.000000000000000;
    A3[195] = 0.000000000000000;
    A3[188] = 0.000000000000000;
    A3[208] = 0.000000000000000;
    A3[14] = 0.000000000000000;
    A3[56] = 0.000000000000000;
    A3[31] = 0.000000000000000;
    A3[129] = 0.000000000000000;
    A3[72] = 0.000000000000000;
    A3[42] = 0.000000000000000;
    A3[139] = 0.000000000000000;
    A3[76] = 0.000000000000000;
    A3[153] = 0.000000000000000;
    A3[107] = 0.000000000000000;
    A3[104] = 0.000000000000000;
    A3[182] = 0.000000000000000;
    A3[175] = 0.000000000000000;
    A3[215] = 0.000000000000000;
    A3[198] = 0.000000000000000;
    A3[193] = 0.000000000000000;
    A3[20] = 0.000000000000000;
    A3[11] = 0.000000000000000;
    A3[51] = 0.000000000000000;
    A3[32] = 0.000000000000000;
    A3[25] = 0.000000000000000;
    A3[126] = 0.000000000000000;
    A3[61] = 0.000000000000000;
    A3[159] = 0.000000000000000;
    A3[142] = 0.000000000000000;
    A3[94] = 0.000000000000000;
    A3[79] = 0.000000000000000;
    A3[169] = 0.000000000000000;
    A3[154] = 0.000000000000000;
    A3[106] = 0.000000000000000;
    A3[101] = 0.000000000000000;
    A3[187] = 0.000000000000000;
    A3[174] = 0.000000000000000;
    A3[216] = 0.000000000000000;
    A3[201] = 0.000000000000000;
    A3[5] = 0.000000000000000;
    A3[15] = 0.000000000000000;
    A3[8] = 0.000000000000000;
    A3[71] = 0.000000000000000;
    A3[50] = 0.000000000000000;
    A3[37] = 0.000000000000000;
    A3[148] = -A3[163] - 0.333333333333332*G3_1;
    A3[123] = 0.000000000000000;
    A3[85] = 0.000000000000000;
    A3[66] = 0.000000000000000;
    A3[160] = 0.000000000000000;
    A3[137] = 0.000000000000000;
    A3[91] = 0.000000000000000;
    A3[82] = 0.000000000000000;
    A3[168] = 0.000000000000000;
    A3[109] = 0.000000000000000;
    A3[222] = 0.000000000000000;
    A3[184] = 0.000000000000000;
    A3[213] = 0.000000000000000;
    A3[204] = 0.000000000000000;
    A3[2] = 0.000000000000000;
    A3[18] = 0.000000000000000;
    A3[133] = 0.000000000000000;
    A3[68] = 0.000000000000000;
    A3[45] = 0.000000000000000;
    A3[38] = 0.000000000000000;
    A3[143] = 0.000000000000000;
    A3[120] = 0.000000000000000;
    A3[88] = 0.000000000000000;
    A3[92] = 0.000000000000000;
    A3[179] = 0.166666666666666*G3_1;
    A3[149] = -A3[179] - 0.333333333333333*G3_0;
    A3[164] = -A3[149];
    A3[116] = 0.000000000000000;
    A3[219] = 0.000000000000000;
    A3[189] = 0.000000000000000;
    A3[207] = 0.000000000000000;
    A3[55] = 0.000000000000000;
    A3[29] = 0.000000000000000;
    A3[130] = 0.000000000000000;
    A3[73] = 0.000000000000000;
    A3[43] = 0.000000000000000;
    A3[146] = 0.000000000000000;
    A3[75] = 0.000000000000000;
    A3[150] = 0.000000000000000;
    A3[183] = 0.000000000000000;
    A3[178] = -A3[148];
    A3[119] = 0.000000000000000;
    A3[220] = 0.000000000000000;
    A3[197] = 0.000000000000000;
    A3[194] = 0.000000000000000;
    A3[19] = 0.000000000000000;
    A3[12] = 0.000000000000000;
    A3[54] = 0.000000000000000;
    A3[33] = 0.000000000000000;
    A3[24] = 0.000000000000000;
    A3[127] = 0.000000000000000;
    A3[62] = 0.000000000000000;
    A3[44] = 0.000000000000000;
    A3[141] = 0.000000000000000;
    A3[95] = 0.000000000000000;
    A3[78] = 0.000000000000000;
    A3[172] = 0.000000000000000;
    A3[155] = 0.000000000000000;
    A3[105] = 0.000000000000000;
    A3[98] = 0.000000000000000;
    A3[180] = 0.000000000000000;
    A3[173] = 0.000000000000000;
    A3[118] = -A3[163];
    A3[217] = 0.000000000000000;
    A3[200] = 0.000000000000000;
    A3[6] = 0.000000000000000;
    A3[22] = 0.000000000000000;
    A3[9] = 0.000000000000000;
    A3[49] = 0.000000000000000;
    A3[34] = 0.000000000000000;
    A3[147] = -A3[163] - 0.166666666666666*G3_1;
    A3[124] = 0.000000000000000;
    A3[84] = 0.000000000000000;
    A3[67] = 0.000000000000000;
    A3[161] = 0.000000000000000;
    A3[136] = 0.000000000000000;
    A3[96] = 0.000000000000000;
    A3[81] = 0.000000000000000;
    A3[167] = 0.000000000000000;
    A3[156] = 0.000000000000000;
    A3[112] = 0.000000000000000;
    A3[223] = 0.000000000000000;
    A3[185] = 0.000000000000000;
    A3[210] = 0.000000000000000;
    A3[203] = 0.000000000000000;
    A3[3] = 0.000000000000000;
    A3[59] = 0.000000000000000;
    A3[17] = 0.000000000000000;
    A3[134] = -A3[179];
    A3[69] = 0.000000000000000;
    A3[48] = 0.000000000000000;
    A3[39] = 0.000000000000000;
    A3[121] = 0.000000000000000;
    A3[87] = 0.000000000000000;
    A3[64] = 0.000000000000000;
    A3[162] = A3[163] - 0.166666666666666*G3_1;
    A3[93] = 0.000000000000000;
    A3[166] = 0.000000000000000;
    A3[115] = 0.000000000000000;
    A3[224] = 0.000000000000000;
    A3[190] = 0.000000000000000;
    A3[206] = 0.000000000000000;
    A3[0] = 0.000000000000000;
    A3[58] = 0.000000000000000;
    A3[28] = 0.000000000000000;
    A3[131] = 0.000000000000000;
    A3[74] = 0.000000000000000;
    A3[40] = 0.000000000000000;
    A3[145] = 0.000000000000000;
    A3[151] = 0.000000000000000;
    A3[102] = -A3[147];
    A3[177] = -A3[162];
    A3[114] = 0.000000000000000;
    A3[221] = 0.000000000000000;
    A3[196] = 0.000000000000000;
    A3[209] = 0.000000000000000;
    A3[13] = 0.000000000000000;
    A3[53] = 0.000000000000000;
    A3[30] = 0.000000000000000;
    A3[23] = 0.000000000000000;
    A3[128] = 0.000000000000000;
    A3[63] = 0.000000000000000;
    A3[140] = 0.000000000000000;
    A3[77] = 0.000000000000000;
    A3[171] = 0.000000000000000;
    A3[152] = 0.000000000000000;
    
    double A4[225];
    A4[108] = 0.000000000000000;
    A4[99] = 0.000000000000000;
    A4[181] = 0.000000000000000;
    A4[176] = 0.000000000000000;
    A4[117] = 0.000000000000000;
    A4[214] = 0.000000000000000;
    A4[199] = 0.000000000000000;
    A4[192] = 0.000000000000000;
    A4[7] = 0.000000000000000;
    A4[21] = 0.000000000000000;
    A4[10] = 0.000000000000000;
    A4[52] = 0.000000000000000;
    A4[35] = 0.000000000000000;
    A4[26] = 0.000000000000000;
    A4[125] = 0.000000000000000;
    A4[83] = 0.000000000000000;
    A4[158] = 0.000000000000000;
    A4[135] = 0.000000000000000;
    A4[97] = 0.000000000000000;
    A4[170] = 0.000000000000000;
    A4[157] = 0.000000000000000;
    A4[111] = 0.000000000000000;
    A4[100] = 0.000000000000000;
    A4[186] = 0.000000000000000;
    A4[211] = 0.000000000000000;
    A4[202] = 0.000000000000000;
    A4[16] = 0.499999999999999*G4_0_0;
    A4[70] = 0.000000000000000;
    A4[47] = 0.666666666666665*G4_0_1;
    A4[4] = -A4[47] - 0.666666666666665*G4_1_1;
    A4[36] = 0.000000000000000;
    A4[149] = 0.000000000000000;
    A4[122] = 0.000000000000000;
    A4[86] = 0.000000000000000;
    A4[65] = A4[47] + 0.666666666666665*G4_1_0;
    A4[163] = 0.000000000000000;
    A4[138] = 0.000000000000000;
    A4[90] = 0.000000000000000;
    A4[165] = 0.000000000000000;
    A4[110] = 0.000000000000000;
    A4[191] = 0.000000000000000;
    A4[212] = 0.000000000000000;
    A4[205] = 0.000000000000000;
    A4[57] = 0.000000000000000;
    A4[27] = 0.000000000000000;
    A4[132] = 0.000000000000000;
    A4[46] = 0.666666666666665*G4_1_0;
    A4[60] = -A4[46] - 0.666666666666665*G4_1_1;
    A4[41] = 0.000000000000000;
    A4[144] = 0.000000000000000;
    A4[89] = 0.000000000000000;
    A4[164] = 0.000000000000000;
    A4[103] = 0.000000000000000;
    A4[113] = 0.000000000000000;
    A4[218] = 0.000000000000000;
    A4[195] = 0.000000000000000;
    A4[188] = 0.000000000000000;
    A4[208] = 0.000000000000000;
    A4[14] = 0.000000000000000;
    A4[56] = 0.000000000000000;
    A4[31] = -0.166666666666666*G4_1_0;
    A4[1] = -A4[31] + 0.166666666666666*G4_0_0;
    A4[129] = 0.000000000000000;
    A4[72] = 0.000000000000000;
    A4[42] = 0.000000000000000;
    A4[139] = 0.000000000000000;
    A4[76] = -A4[46] - 0.666666666666666*G4_0_0;
    A4[153] = 0.000000000000000;
    A4[107] = 0.000000000000000;
    A4[104] = 0.000000000000000;
    A4[182] = 0.000000000000000;
    A4[175] = 0.000000000000000;
    A4[215] = 0.000000000000000;
    A4[198] = 0.000000000000000;
    A4[193] = 0.000000000000000;
    A4[20] = -A4[47] - 0.666666666666665*G4_0_0;
    A4[11] = 0.000000000000000;
    A4[51] = 0.000000000000000;
    A4[32] = 0.499999999999999*G4_1_1;
    A4[25] = 0.000000000000000;
    A4[126] = 0.000000000000000;
    A4[61] = 0.000000000000000;
    A4[159] = 0.000000000000000;
    A4[142] = 0.000000000000000;
    A4[94] = 0.000000000000000;
    A4[79] = A4[65];
    A4[169] = 0.000000000000000;
    A4[154] = 0.000000000000000;
    A4[106] = 0.000000000000000;
    A4[101] = 0.000000000000000;
    A4[187] = 0.000000000000000;
    A4[174] = 0.000000000000000;
    A4[216] = 0.000000000000000;
    A4[201] = 0.000000000000000;
    A4[5] = A4[76];
    A4[15] = -0.250000000000000*A4[20];
    A4[8] = 0.000000000000000;
    A4[71] = 0.000000000000000;
    A4[50] = -A4[65] - 1.333333333333330*G4_1_1;
    A4[80] = -A4[50] + 1.333333333333331*G4_0_0;
    A4[37] = 0.000000000000000;
    A4[148] = 0.000000000000000;
    A4[123] = 0.000000000000000;
    A4[85] = 0.000000000000000;
    A4[66] = 0.000000000000000;
    A4[160] = 0.000000000000000;
    A4[137] = 0.000000000000000;
    A4[91] = 0.000000000000000;
    A4[82] = 0.000000000000000;
    A4[168] = 0.000000000000000;
    A4[109] = 0.000000000000000;
    A4[222] = 0.000000000000000;
    A4[184] = 0.000000000000000;
    A4[213] = 0.000000000000000;
    A4[204] = 0.000000000000000;
    A4[2] = -0.250000000000000*A4[4];
    A4[18] = A4[47];
    A4[133] = 0.000000000000000;
    A4[68] = 0.000000000000000;
    A4[45] = 0.000000000000000;
    A4[38] = 0.000000000000000;
    A4[143] = 0.000000000000000;
    A4[120] = 0.000000000000000;
    A4[88] = 0.000000000000000;
    A4[92] = 0.000000000000000;
    A4[179] = 0.000000000000000;
    A4[116] = 0.000000000000000;
    A4[219] = 0.000000000000000;
    A4[189] = 0.000000000000000;
    A4[207] = 0.000000000000000;
    A4[55] = 0.000000000000000;
    A4[29] = 0.000000000000000;
    A4[130] = 0.000000000000000;
    A4[73] = 0.000000000000000;
    A4[43] = 0.000000000000000;
    A4[146] = 0.000000000000000;
    A4[75] = A4[20];
    A4[150] = 0.000000000000000;
    A4[183] = 0.000000000000000;
    A4[178] = 0.000000000000000;
    A4[119] = 0.000000000000000;
    A4[220] = 0.000000000000000;
    A4[197] = 0.000000000000000;
    A4[194] = 0.000000000000000;
    A4[19] = 0.000000000000000;
    A4[12] = 0.000000000000000;
    A4[54] = 0.000000000000000;
    A4[33] = A4[46];
    A4[24] = 0.000000000000000;
    A4[127] = 0.000000000000000;
    A4[62] = A4[4];
    A4[44] = 0.000000000000000;
    A4[141] = 0.000000000000000;
    A4[95] = 0.000000000000000;
    A4[78] = A4[50];
    A4[172] = 0.000000000000000;
    A4[155] = 0.000000000000000;
    A4[105] = 0.000000000000000;
    A4[98] = 0.000000000000000;
    A4[180] = 0.000000000000000;
    A4[173] = 0.000000000000000;
    A4[118] = 0.000000000000000;
    A4[217] = 0.000000000000000;
    A4[200] = 0.000000000000000;
    A4[6] = 0.000000000000000;
    A4[22] = 0.000000000000000;
    A4[9] = 0.000000000000000;
    A4[49] = -A4[65] - 1.333333333333330*G4_0_0;
    A4[34] = A4[60];
    A4[147] = 0.000000000000000;
    A4[124] = 0.000000000000000;
    A4[84] = 0.000000000000000;
    A4[67] = 0.000000000000000;
    A4[161] = 0.000000000000000;
    A4[136] = 0.000000000000000;
    A4[96] = 0.000000000000000;
    A4[81] = 0.000000000000000;
    A4[167] = 0.000000000000000;
    A4[156] = 0.000000000000000;
    A4[112] = 0.000000000000000;
    A4[223] = 0.000000000000000;
    A4[185] = 0.000000000000000;
    A4[210] = 0.000000000000000;
    A4[203] = 0.000000000000000;
    A4[3] = 0.000000000000000;
    A4[59] = 0.000000000000000;
    A4[17] = -0.166666666666666*G4_0_1;
    A4[134] = 0.000000000000000;
    A4[69] = 0.000000000000000;
    A4[48] = A4[80];
    A4[39] = 0.000000000000000;
    A4[121] = 0.000000000000000;
    A4[87] = 0.000000000000000;
    A4[64] = A4[80];
    A4[162] = 0.000000000000000;
    A4[93] = 0.000000000000000;
    A4[166] = 0.000000000000000;
    A4[115] = 0.000000000000000;
    A4[224] = 0.000000000000000;
    A4[190] = 0.000000000000000;
    A4[206] = 0.000000000000000;
    A4[0] = A4[16] + 0.499999999999999*G4_0_1 + 0.499999999999999*G4_1_0 + 0.499999999999999*G4_1_1;
    A4[58] = 0.000000000000000;
    A4[28] = 0.000000000000000;
    A4[131] = 0.000000000000000;
    A4[74] = 0.000000000000000;
    A4[40] = 0.000000000000000;
    A4[145] = 0.000000000000000;
    A4[151] = 0.000000000000000;
    A4[102] = 0.000000000000000;
    A4[177] = 0.000000000000000;
    A4[114] = 0.000000000000000;
    A4[221] = 0.000000000000000;
    A4[196] = 0.000000000000000;
    A4[209] = 0.000000000000000;
    A4[13] = 0.000000000000000;
    A4[53] = 0.000000000000000;
    A4[30] = -0.250000000000000*A4[60];
    A4[23] = 0.000000000000000;
    A4[128] = 0.000000000000000;
    A4[63] = A4[49];
    A4[140] = 0.000000000000000;
    A4[77] = 0.000000000000000;
    A4[171] = 0.000000000000000;
    A4[152] = 0.000000000000000;
    
    double A5[225];
    A5[108] = 0.000000000000000;
    A5[99] = 0.000000000000000;
    A5[181] = 0.000000000000000;
    A5[117] = 0.000000000000000;
    A5[214] = 0.000000000000000;
    A5[199] = 0.000000000000000;
    A5[192] = 0.000000000000000;
    A5[7] = 0.000000000000000;
    A5[21] = 0.000000000000000;
    A5[10] = 0.000000000000000;
    A5[52] = 0.000000000000000;
    A5[35] = 0.000000000000000;
    A5[26] = 0.000000000000000;
    A5[125] = 0.000000000000000;
    A5[83] = 0.000000000000000;
    A5[60] = 0.000000000000000;
    A5[135] = 0.000000000000000;
    A5[80] = 0.000000000000000;
    A5[170] = 0.000000000000000;
    A5[157] = 0.000000000000000;
    A5[186] = 0.000000000000000;
    A5[211] = 0.000000000000000;
    A5[202] = 0.000000000000000;
    A5[4] = 0.000000000000000;
    A5[16] = 0.000000000000000;
    A5[70] = 0.000000000000000;
    A5[47] = 0.000000000000000;
    A5[36] = 0.000000000000000;
    A5[149] = 0.000000000000000;
    A5[122] = 0.000000000000000;
    A5[86] = 0.000000000000000;
    A5[65] = 0.000000000000000;
    A5[163] = 0.000000000000000;
    A5[138] = 0.000000000000000;
    A5[90] = 0.000000000000000;
    A5[165] = 0.000000000000000;
    A5[110] = 0.000000000000000;
    A5[191] = 0.000000000000000;
    A5[212] = 0.000000000000000;
    A5[205] = 0.000000000000000;
    A5[1] = 0.000000000000000;
    A5[57] = 0.000000000000000;
    A5[27] = 0.000000000000000;
    A5[132] = 0.000000000000000;
    A5[46] = 0.000000000000000;
    A5[41] = 0.000000000000000;
    A5[89] = 0.000000000000000;
    A5[164] = 0.000000000000000;
    A5[103] = 0.000000000000000;
    A5[113] = -0.166666666666666*G5_0_1;
    A5[111] = -A5[113] + 0.166666666666666*G5_0_0;
    A5[218] = 0.000000000000000;
    A5[195] = 0.000000000000000;
    A5[188] = 0.000000000000000;
    A5[208] = 0.000000000000000;
    A5[14] = 0.000000000000000;
    A5[56] = 0.000000000000000;
    A5[31] = 0.000000000000000;
    A5[129] = 0.666666666666665*G5_1_0;
    A5[72] = 0.000000000000000;
    A5[42] = 0.000000000000000;
    A5[139] = 0.000000000000000;
    A5[76] = 0.000000000000000;
    A5[153] = 0.000000000000000;
    A5[107] = 0.000000000000000;
    A5[104] = 0.000000000000000;
    A5[182] = 0.000000000000000;
    A5[175] = A5[129] + 0.666666666666665*G5_0_1;
    A5[215] = 0.000000000000000;
    A5[198] = 0.000000000000000;
    A5[193] = 0.000000000000000;
    A5[20] = 0.000000000000000;
    A5[11] = 0.000000000000000;
    A5[51] = 0.000000000000000;
    A5[32] = 0.000000000000000;
    A5[25] = 0.000000000000000;
    A5[61] = 0.000000000000000;
    A5[159] = -A5[175] - 1.333333333333330*G5_0_0;
    A5[176] = -A5[159] + 1.333333333333330*G5_1_1;
    A5[144] = A5[176];
    A5[142] = A5[129];
    A5[94] = 0.000000000000000;
    A5[79] = 0.000000000000000;
    A5[169] = 0.000000000000000;
    A5[154] = 0.000000000000000;
    A5[106] = 0.000000000000000;
    A5[101] = -A5[129] - 0.666666666666665*G5_0_0;
    A5[97] = -0.250000000000000*A5[101];
    A5[187] = 0.000000000000000;
    A5[174] = -A5[175] - 1.333333333333330*G5_1_1;
    A5[216] = 0.000000000000000;
    A5[201] = 0.000000000000000;
    A5[5] = 0.000000000000000;
    A5[15] = 0.000000000000000;
    A5[8] = 0.000000000000000;
    A5[71] = 0.000000000000000;
    A5[50] = 0.000000000000000;
    A5[37] = 0.000000000000000;
    A5[148] = 0.000000000000000;
    A5[123] = 0.000000000000000;
    A5[85] = 0.000000000000000;
    A5[66] = 0.000000000000000;
    A5[160] = A5[176];
    A5[137] = 0.000000000000000;
    A5[91] = 0.000000000000000;
    A5[82] = 0.000000000000000;
    A5[168] = 0.000000000000000;
    A5[109] = 0.000000000000000;
    A5[222] = 0.000000000000000;
    A5[184] = 0.000000000000000;
    A5[213] = 0.000000000000000;
    A5[204] = 0.000000000000000;
    A5[2] = 0.000000000000000;
    A5[18] = 0.000000000000000;
    A5[133] = 0.000000000000000;
    A5[68] = 0.000000000000000;
    A5[45] = 0.000000000000000;
    A5[38] = 0.000000000000000;
    A5[143] = 0.666666666666665*G5_0_1;
    A5[158] = -A5[143] - 0.666666666666665*G5_1_1;
    A5[100] = A5[158];
    A5[120] = 0.000000000000000;
    A5[88] = 0.000000000000000;
    A5[92] = 0.000000000000000;
    A5[179] = 0.000000000000000;
    A5[116] = -3.999999999999999*A5[111];
    A5[219] = 0.000000000000000;
    A5[189] = 0.000000000000000;
    A5[207] = 0.000000000000000;
    A5[55] = 0.000000000000000;
    A5[29] = 0.000000000000000;
    A5[130] = -A5[129] - 0.666666666666665*G5_1_1;
    A5[126] = -0.250000000000000*A5[130];
    A5[73] = 0.000000000000000;
    A5[43] = 0.000000000000000;
    A5[146] = A5[174];
    A5[75] = 0.000000000000000;
    A5[150] = 0.000000000000000;
    A5[183] = 0.000000000000000;
    A5[178] = 0.000000000000000;
    A5[119] = 0.000000000000000;
    A5[220] = 0.000000000000000;
    A5[197] = 0.000000000000000;
    A5[194] = 0.000000000000000;
    A5[19] = 0.000000000000000;
    A5[12] = 0.000000000000000;
    A5[54] = 0.000000000000000;
    A5[33] = 0.000000000000000;
    A5[24] = 0.000000000000000;
    A5[127] = -0.166666666666666*G5_1_0;
    A5[62] = 0.000000000000000;
    A5[44] = 0.000000000000000;
    A5[141] = 0.000000000000000;
    A5[95] = 0.000000000000000;
    A5[78] = 0.000000000000000;
    A5[172] = A5[101];
    A5[155] = 0.000000000000000;
    A5[105] = 0.000000000000000;
    A5[98] = -A5[113] + 0.166666666666666*G5_1_1;
    A5[180] = 0.000000000000000;
    A5[173] = 0.000000000000000;
    A5[118] = 0.000000000000000;
    A5[217] = 0.000000000000000;
    A5[200] = 0.000000000000000;
    A5[6] = 0.000000000000000;
    A5[22] = 0.000000000000000;
    A5[9] = 0.000000000000000;
    A5[49] = 0.000000000000000;
    A5[34] = 0.000000000000000;
    A5[147] = 0.000000000000000;
    A5[124] = 0.000000000000000;
    A5[84] = 0.000000000000000;
    A5[67] = 0.000000000000000;
    A5[161] = A5[175];
    A5[136] = 0.000000000000000;
    A5[81] = 0.000000000000000;
    A5[167] = 0.000000000000000;
    A5[156] = A5[130];
    A5[112] = 0.499999999999999*G5_0_0;
    A5[96] = A5[112] + 0.499999999999999*G5_0_1 + 0.499999999999999*G5_1_0 + 0.499999999999999*G5_1_1;
    A5[223] = 0.000000000000000;
    A5[185] = 0.000000000000000;
    A5[210] = 0.000000000000000;
    A5[203] = 0.000000000000000;
    A5[3] = 0.000000000000000;
    A5[59] = 0.000000000000000;
    A5[17] = 0.000000000000000;
    A5[134] = 0.000000000000000;
    A5[69] = 0.000000000000000;
    A5[48] = 0.000000000000000;
    A5[39] = 0.000000000000000;
    A5[121] = 0.000000000000000;
    A5[87] = 0.000000000000000;
    A5[64] = 0.000000000000000;
    A5[162] = 0.000000000000000;
    A5[93] = 0.000000000000000;
    A5[166] = 0.000000000000000;
    A5[115] = 0.000000000000000;
    A5[224] = 0.000000000000000;
    A5[190] = 0.000000000000000;
    A5[206] = 0.000000000000000;
    A5[0] = 0.000000000000000;
    A5[58] = 0.000000000000000;
    A5[28] = 0.000000000000000;
    A5[131] = 0.000000000000000;
    A5[74] = 0.000000000000000;
    A5[40] = 0.000000000000000;
    A5[145] = A5[159];
    A5[151] = 0.000000000000000;
    A5[102] = 0.000000000000000;
    A5[177] = 0.000000000000000;
    A5[114] = A5[143];
    A5[221] = 0.000000000000000;
    A5[196] = 0.000000000000000;
    A5[209] = 0.000000000000000;
    A5[13] = 0.000000000000000;
    A5[53] = 0.000000000000000;
    A5[30] = 0.000000000000000;
    A5[23] = 0.000000000000000;
    A5[128] = 0.499999999999999*G5_1_1;
    A5[63] = 0.000000000000000;
    A5[140] = 0.000000000000000;
    A5[77] = 0.000000000000000;
    A5[171] = A5[116];
    A5[152] = 0.000000000000000;
    
    double A6[225];
    A6[108] = 0.000000000000000;
    A6[99] = 0.000000000000000;
    A6[181] = 0.000000000000000;
    A6[176] = 0.000000000000000;
    A6[117] = 0.000000000000000;
    A6[214] = 0.000000000000000;
    A6[199] = 0.000000000000000;
    A6[192] = 0.000000000000000;
    A6[7] = 0.000000000000000;
    A6[21] = 0.000000000000000;
    A6[10] = 0.000000000000000;
    A6[52] = 0.000000000000000;
    A6[35] = 0.000000000000000;
    A6[26] = 0.000000000000000;
    A6[125] = 0.000000000000000;
    A6[83] = 0.000000000000000;
    A6[158] = 0.000000000000000;
    A6[135] = 0.000000000000000;
    A6[97] = 0.000000000000000;
    A6[170] = 0.000000000000000;
    A6[157] = 0.000000000000000;
    A6[111] = 0.000000000000000;
    A6[100] = 0.000000000000000;
    A6[186] = 0.000000000000000;
    A6[211] = 0.000000000000000;
    A6[202] = 0.000000000000000;
    A6[16] = 0.499999999999999*G6_0_0;
    A6[70] = 0.000000000000000;
    A6[47] = 0.666666666666665*G6_0_1;
    A6[4] = -A6[47] - 0.666666666666665*G6_1_1;
    A6[36] = 0.000000000000000;
    A6[149] = 0.000000000000000;
    A6[122] = 0.000000000000000;
    A6[86] = 0.000000000000000;
    A6[65] = A6[47] + 0.666666666666665*G6_1_0;
    A6[163] = 0.000000000000000;
    A6[138] = 0.000000000000000;
    A6[90] = 0.000000000000000;
    A6[165] = 0.000000000000000;
    A6[110] = 0.000000000000000;
    A6[191] = 0.000000000000000;
    A6[212] = 0.000000000000000;
    A6[205] = 0.000000000000000;
    A6[57] = 0.000000000000000;
    A6[27] = 0.000000000000000;
    A6[132] = 0.000000000000000;
    A6[46] = 0.666666666666665*G6_1_0;
    A6[60] = -A6[46] - 0.666666666666665*G6_1_1;
    A6[41] = 0.000000000000000;
    A6[144] = 0.000000000000000;
    A6[89] = 0.000000000000000;
    A6[164] = 0.000000000000000;
    A6[103] = 0.000000000000000;
    A6[113] = 0.000000000000000;
    A6[218] = 0.000000000000000;
    A6[195] = 0.000000000000000;
    A6[188] = 0.000000000000000;
    A6[208] = 0.000000000000000;
    A6[14] = 0.000000000000000;
    A6[56] = 0.000000000000000;
    A6[31] = -0.166666666666666*G6_1_0;
    A6[1] = -A6[31] + 0.166666666666666*G6_0_0;
    A6[129] = 0.000000000000000;
    A6[72] = 0.000000000000000;
    A6[42] = 0.000000000000000;
    A6[139] = 0.000000000000000;
    A6[76] = -A6[46] - 0.666666666666666*G6_0_0;
    A6[153] = 0.000000000000000;
    A6[107] = 0.000000000000000;
    A6[104] = 0.000000000000000;
    A6[182] = 0.000000000000000;
    A6[175] = 0.000000000000000;
    A6[215] = 0.000000000000000;
    A6[198] = 0.000000000000000;
    A6[193] = 0.000000000000000;
    A6[20] = -A6[47] - 0.666666666666665*G6_0_0;
    A6[11] = 0.000000000000000;
    A6[51] = 0.000000000000000;
    A6[32] = 0.499999999999999*G6_1_1;
    A6[25] = 0.000000000000000;
    A6[126] = 0.000000000000000;
    A6[61] = 0.000000000000000;
    A6[159] = 0.000000000000000;
    A6[142] = 0.000000000000000;
    A6[94] = 0.000000000000000;
    A6[79] = A6[65];
    A6[169] = 0.000000000000000;
    A6[154] = 0.000000000000000;
    A6[106] = 0.000000000000000;
    A6[101] = 0.000000000000000;
    A6[187] = 0.000000000000000;
    A6[174] = 0.000000000000000;
    A6[216] = 0.000000000000000;
    A6[201] = 0.000000000000000;
    A6[5] = A6[76];
    A6[15] = -0.250000000000000*A6[20];
    A6[8] = 0.000000000000000;
    A6[71] = 0.000000000000000;
    A6[50] = -A6[65] - 1.333333333333330*G6_1_1;
    A6[80] = -A6[50] + 1.333333333333331*G6_0_0;
    A6[37] = 0.000000000000000;
    A6[148] = 0.000000000000000;
    A6[123] = 0.000000000000000;
    A6[85] = 0.000000000000000;
    A6[66] = 0.000000000000000;
    A6[160] = 0.000000000000000;
    A6[137] = 0.000000000000000;
    A6[91] = 0.000000000000000;
    A6[82] = 0.000000000000000;
    A6[168] = 0.000000000000000;
    A6[109] = 0.000000000000000;
    A6[222] = 0.000000000000000;
    A6[184] = 0.000000000000000;
    A6[213] = 0.000000000000000;
    A6[204] = 0.000000000000000;
    A6[2] = -0.250000000000000*A6[4];
    A6[18] = A6[47];
    A6[133] = 0.000000000000000;
    A6[68] = 0.000000000000000;
    A6[45] = 0.000000000000000;
    A6[38] = 0.000000000000000;
    A6[143] = 0.000000000000000;
    A6[120] = 0.000000000000000;
    A6[88] = 0.000000000000000;
    A6[92] = 0.000000000000000;
    A6[179] = 0.000000000000000;
    A6[116] = 0.000000000000000;
    A6[219] = 0.000000000000000;
    A6[189] = 0.000000000000000;
    A6[207] = 0.000000000000000;
    A6[55] = 0.000000000000000;
    A6[29] = 0.000000000000000;
    A6[130] = 0.000000000000000;
    A6[73] = 0.000000000000000;
    A6[43] = 0.000000000000000;
    A6[146] = 0.000000000000000;
    A6[75] = A6[20];
    A6[150] = 0.000000000000000;
    A6[183] = 0.000000000000000;
    A6[178] = 0.000000000000000;
    A6[119] = 0.000000000000000;
    A6[220] = 0.000000000000000;
    A6[197] = 0.000000000000000;
    A6[194] = 0.000000000000000;
    A6[19] = 0.000000000000000;
    A6[12] = 0.000000000000000;
    A6[54] = 0.000000000000000;
    A6[33] = A6[46];
    A6[24] = 0.000000000000000;
    A6[127] = 0.000000000000000;
    A6[62] = A6[4];
    A6[44] = 0.000000000000000;
    A6[141] = 0.000000000000000;
    A6[95] = 0.000000000000000;
    A6[78] = A6[50];
    A6[172] = 0.000000000000000;
    A6[155] = 0.000000000000000;
    A6[105] = 0.000000000000000;
    A6[98] = 0.000000000000000;
    A6[180] = 0.000000000000000;
    A6[173] = 0.000000000000000;
    A6[118] = 0.000000000000000;
    A6[217] = 0.000000000000000;
    A6[200] = 0.000000000000000;
    A6[6] = 0.000000000000000;
    A6[22] = 0.000000000000000;
    A6[9] = 0.000000000000000;
    A6[49] = -A6[65] - 1.333333333333330*G6_0_0;
    A6[34] = A6[60];
    A6[147] = 0.000000000000000;
    A6[124] = 0.000000000000000;
    A6[84] = 0.000000000000000;
    A6[67] = 0.000000000000000;
    A6[161] = 0.000000000000000;
    A6[136] = 0.000000000000000;
    A6[96] = 0.000000000000000;
    A6[81] = 0.000000000000000;
    A6[167] = 0.000000000000000;
    A6[156] = 0.000000000000000;
    A6[112] = 0.000000000000000;
    A6[223] = 0.000000000000000;
    A6[185] = 0.000000000000000;
    A6[210] = 0.000000000000000;
    A6[203] = 0.000000000000000;
    A6[3] = 0.000000000000000;
    A6[59] = 0.000000000000000;
    A6[17] = -0.166666666666666*G6_0_1;
    A6[134] = 0.000000000000000;
    A6[69] = 0.000000000000000;
    A6[48] = A6[80];
    A6[39] = 0.000000000000000;
    A6[121] = 0.000000000000000;
    A6[87] = 0.000000000000000;
    A6[64] = A6[80];
    A6[162] = 0.000000000000000;
    A6[93] = 0.000000000000000;
    A6[166] = 0.000000000000000;
    A6[115] = 0.000000000000000;
    A6[224] = 0.000000000000000;
    A6[190] = 0.000000000000000;
    A6[206] = 0.000000000000000;
    A6[0] = A6[16] + 0.499999999999999*G6_0_1 + 0.499999999999999*G6_1_0 + 0.499999999999999*G6_1_1;
    A6[58] = 0.000000000000000;
    A6[28] = 0.000000000000000;
    A6[131] = 0.000000000000000;
    A6[74] = 0.000000000000000;
    A6[40] = 0.000000000000000;
    A6[145] = 0.000000000000000;
    A6[151] = 0.000000000000000;
    A6[102] = 0.000000000000000;
    A6[177] = 0.000000000000000;
    A6[114] = 0.000000000000000;
    A6[221] = 0.000000000000000;
    A6[196] = 0.000000000000000;
    A6[209] = 0.000000000000000;
    A6[13] = 0.000000000000000;
    A6[53] = 0.000000000000000;
    A6[30] = -0.250000000000000*A6[60];
    A6[23] = 0.000000000000000;
    A6[128] = 0.000000000000000;
    A6[63] = A6[49];
    A6[140] = 0.000000000000000;
    A6[77] = 0.000000000000000;
    A6[171] = 0.000000000000000;
    A6[152] = 0.000000000000000;
    
    double A7[225];
    A7[108] = 0.000000000000000;
    A7[99] = 0.000000000000000;
    A7[181] = 0.000000000000000;
    A7[117] = 0.000000000000000;
    A7[214] = 0.000000000000000;
    A7[199] = 0.000000000000000;
    A7[192] = 0.000000000000000;
    A7[7] = 0.000000000000000;
    A7[21] = 0.000000000000000;
    A7[10] = 0.000000000000000;
    A7[52] = 0.000000000000000;
    A7[35] = 0.000000000000000;
    A7[26] = 0.000000000000000;
    A7[125] = 0.000000000000000;
    A7[83] = 0.000000000000000;
    A7[60] = 0.000000000000000;
    A7[135] = 0.000000000000000;
    A7[80] = 0.000000000000000;
    A7[170] = 0.000000000000000;
    A7[157] = 0.000000000000000;
    A7[186] = 0.000000000000000;
    A7[211] = 0.000000000000000;
    A7[202] = 0.000000000000000;
    A7[4] = 0.000000000000000;
    A7[16] = 0.000000000000000;
    A7[70] = 0.000000000000000;
    A7[47] = 0.000000000000000;
    A7[36] = 0.000000000000000;
    A7[149] = 0.000000000000000;
    A7[122] = 0.000000000000000;
    A7[86] = 0.000000000000000;
    A7[65] = 0.000000000000000;
    A7[163] = 0.000000000000000;
    A7[138] = 0.000000000000000;
    A7[90] = 0.000000000000000;
    A7[165] = 0.000000000000000;
    A7[110] = 0.000000000000000;
    A7[191] = 0.000000000000000;
    A7[212] = 0.000000000000000;
    A7[205] = 0.000000000000000;
    A7[1] = 0.000000000000000;
    A7[57] = 0.000000000000000;
    A7[27] = 0.000000000000000;
    A7[132] = 0.000000000000000;
    A7[46] = 0.000000000000000;
    A7[41] = 0.000000000000000;
    A7[89] = 0.000000000000000;
    A7[164] = 0.000000000000000;
    A7[103] = 0.000000000000000;
    A7[113] = -0.166666666666666*G7_0_1;
    A7[111] = -A7[113] + 0.166666666666666*G7_0_0;
    A7[218] = 0.000000000000000;
    A7[195] = 0.000000000000000;
    A7[188] = 0.000000000000000;
    A7[208] = 0.000000000000000;
    A7[14] = 0.000000000000000;
    A7[56] = 0.000000000000000;
    A7[31] = 0.000000000000000;
    A7[129] = 0.666666666666665*G7_1_0;
    A7[72] = 0.000000000000000;
    A7[42] = 0.000000000000000;
    A7[139] = 0.000000000000000;
    A7[76] = 0.000000000000000;
    A7[153] = 0.000000000000000;
    A7[107] = 0.000000000000000;
    A7[104] = 0.000000000000000;
    A7[182] = 0.000000000000000;
    A7[175] = A7[129] + 0.666666666666665*G7_0_1;
    A7[215] = 0.000000000000000;
    A7[198] = 0.000000000000000;
    A7[193] = 0.000000000000000;
    A7[20] = 0.000000000000000;
    A7[11] = 0.000000000000000;
    A7[51] = 0.000000000000000;
    A7[32] = 0.000000000000000;
    A7[25] = 0.000000000000000;
    A7[61] = 0.000000000000000;
    A7[159] = -A7[175] - 1.333333333333330*G7_0_0;
    A7[176] = -A7[159] + 1.333333333333330*G7_1_1;
    A7[144] = A7[176];
    A7[142] = A7[129];
    A7[94] = 0.000000000000000;
    A7[79] = 0.000000000000000;
    A7[169] = 0.000000000000000;
    A7[154] = 0.000000000000000;
    A7[106] = 0.000000000000000;
    A7[101] = -A7[129] - 0.666666666666665*G7_0_0;
    A7[97] = -0.250000000000000*A7[101];
    A7[187] = 0.000000000000000;
    A7[174] = -A7[175] - 1.333333333333330*G7_1_1;
    A7[216] = 0.000000000000000;
    A7[201] = 0.000000000000000;
    A7[5] = 0.000000000000000;
    A7[15] = 0.000000000000000;
    A7[8] = 0.000000000000000;
    A7[71] = 0.000000000000000;
    A7[50] = 0.000000000000000;
    A7[37] = 0.000000000000000;
    A7[148] = 0.000000000000000;
    A7[123] = 0.000000000000000;
    A7[85] = 0.000000000000000;
    A7[66] = 0.000000000000000;
    A7[160] = A7[176];
    A7[137] = 0.000000000000000;
    A7[91] = 0.000000000000000;
    A7[82] = 0.000000000000000;
    A7[168] = 0.000000000000000;
    A7[109] = 0.000000000000000;
    A7[222] = 0.000000000000000;
    A7[184] = 0.000000000000000;
    A7[213] = 0.000000000000000;
    A7[204] = 0.000000000000000;
    A7[2] = 0.000000000000000;
    A7[18] = 0.000000000000000;
    A7[133] = 0.000000000000000;
    A7[68] = 0.000000000000000;
    A7[45] = 0.000000000000000;
    A7[38] = 0.000000000000000;
    A7[143] = 0.666666666666665*G7_0_1;
    A7[158] = -A7[143] - 0.666666666666665*G7_1_1;
    A7[100] = A7[158];
    A7[120] = 0.000000000000000;
    A7[88] = 0.000000000000000;
    A7[92] = 0.000000000000000;
    A7[179] = 0.000000000000000;
    A7[116] = -3.999999999999999*A7[111];
    A7[219] = 0.000000000000000;
    A7[189] = 0.000000000000000;
    A7[207] = 0.000000000000000;
    A7[55] = 0.000000000000000;
    A7[29] = 0.000000000000000;
    A7[130] = -A7[129] - 0.666666666666665*G7_1_1;
    A7[126] = -0.250000000000000*A7[130];
    A7[73] = 0.000000000000000;
    A7[43] = 0.000000000000000;
    A7[146] = A7[174];
    A7[75] = 0.000000000000000;
    A7[150] = 0.000000000000000;
    A7[183] = 0.000000000000000;
    A7[178] = 0.000000000000000;
    A7[119] = 0.000000000000000;
    A7[220] = 0.000000000000000;
    A7[197] = 0.000000000000000;
    A7[194] = 0.000000000000000;
    A7[19] = 0.000000000000000;
    A7[12] = 0.000000000000000;
    A7[54] = 0.000000000000000;
    A7[33] = 0.000000000000000;
    A7[24] = 0.000000000000000;
    A7[127] = -0.166666666666666*G7_1_0;
    A7[62] = 0.000000000000000;
    A7[44] = 0.000000000000000;
    A7[141] = 0.000000000000000;
    A7[95] = 0.000000000000000;
    A7[78] = 0.000000000000000;
    A7[172] = A7[101];
    A7[155] = 0.000000000000000;
    A7[105] = 0.000000000000000;
    A7[98] = -A7[113] + 0.166666666666666*G7_1_1;
    A7[180] = 0.000000000000000;
    A7[173] = 0.000000000000000;
    A7[118] = 0.000000000000000;
    A7[217] = 0.000000000000000;
    A7[200] = 0.000000000000000;
    A7[6] = 0.000000000000000;
    A7[22] = 0.000000000000000;
    A7[9] = 0.000000000000000;
    A7[49] = 0.000000000000000;
    A7[34] = 0.000000000000000;
    A7[147] = 0.000000000000000;
    A7[124] = 0.000000000000000;
    A7[84] = 0.000000000000000;
    A7[67] = 0.000000000000000;
    A7[161] = A7[175];
    A7[136] = 0.000000000000000;
    A7[81] = 0.000000000000000;
    A7[167] = 0.000000000000000;
    A7[156] = A7[130];
    A7[112] = 0.499999999999999*G7_0_0;
    A7[96] = A7[112] + 0.499999999999999*G7_0_1 + 0.499999999999999*G7_1_0 + 0.499999999999999*G7_1_1;
    A7[223] = 0.000000000000000;
    A7[185] = 0.000000000000000;
    A7[210] = 0.000000000000000;
    A7[203] = 0.000000000000000;
    A7[3] = 0.000000000000000;
    A7[59] = 0.000000000000000;
    A7[17] = 0.000000000000000;
    A7[134] = 0.000000000000000;
    A7[69] = 0.000000000000000;
    A7[48] = 0.000000000000000;
    A7[39] = 0.000000000000000;
    A7[121] = 0.000000000000000;
    A7[87] = 0.000000000000000;
    A7[64] = 0.000000000000000;
    A7[162] = 0.000000000000000;
    A7[93] = 0.000000000000000;
    A7[166] = 0.000000000000000;
    A7[115] = 0.000000000000000;
    A7[224] = 0.000000000000000;
    A7[190] = 0.000000000000000;
    A7[206] = 0.000000000000000;
    A7[0] = 0.000000000000000;
    A7[58] = 0.000000000000000;
    A7[28] = 0.000000000000000;
    A7[131] = 0.000000000000000;
    A7[74] = 0.000000000000000;
    A7[40] = 0.000000000000000;
    A7[145] = A7[159];
    A7[151] = 0.000000000000000;
    A7[102] = 0.000000000000000;
    A7[177] = 0.000000000000000;
    A7[114] = A7[143];
    A7[221] = 0.000000000000000;
    A7[196] = 0.000000000000000;
    A7[209] = 0.000000000000000;
    A7[13] = 0.000000000000000;
    A7[53] = 0.000000000000000;
    A7[30] = 0.000000000000000;
    A7[23] = 0.000000000000000;
    A7[128] = 0.499999999999999*G7_1_1;
    A7[63] = 0.000000000000000;
    A7[140] = 0.000000000000000;
    A7[77] = 0.000000000000000;
    A7[171] = A7[116];
    A7[152] = 0.000000000000000;
    
    A[0] = A0[0] + A1[0] + A2[0] + A3[0] + A4[0] + A5[0] + A6[0] + A7[0];
    A[1] = A0[1] + A1[1] + A2[1] + A3[1] + A4[1] + A5[1] + A6[1] + A7[1];
    A[2] = A0[2] + A1[2] + A2[2] + A3[2] + A4[2] + A5[2] + A6[2] + A7[2];
    A[3] = A0[3] + A1[3] + A2[3] + A3[3] + A4[3] + A5[3] + A6[3] + A7[3];
    A[4] = A0[4] + A1[4] + A2[4] + A3[4] + A4[4] + A5[4] + A6[4] + A7[4];
    A[5] = A0[5] + A1[5] + A2[5] + A3[5] + A4[5] + A5[5] + A6[5] + A7[5];
    A[6] = A0[6] + A1[6] + A2[6] + A3[6] + A4[6] + A5[6] + A6[6] + A7[6];
    A[7] = A0[7] + A1[7] + A2[7] + A3[7] + A4[7] + A5[7] + A6[7] + A7[7];
    A[8] = A0[8] + A1[8] + A2[8] + A3[8] + A4[8] + A5[8] + A6[8] + A7[8];
    A[9] = A0[9] + A1[9] + A2[9] + A3[9] + A4[9] + A5[9] + A6[9] + A7[9];
    A[10] = A0[10] + A1[10] + A2[10] + A3[10] + A4[10] + A5[10] + A6[10] + A7[10];
    A[11] = A0[11] + A1[11] + A2[11] + A3[11] + A4[11] + A5[11] + A6[11] + A7[11];
    A[12] = A0[12] + A1[12] + A2[12] + A3[12] + A4[12] + A5[12] + A6[12] + A7[12];
    A[13] = A0[13] + A1[13] + A2[13] + A3[13] + A4[13] + A5[13] + A6[13] + A7[13];
    A[14] = A0[14] + A1[14] + A2[14] + A3[14] + A4[14] + A5[14] + A6[14] + A7[14];
    A[15] = A0[15] + A1[15] + A2[15] + A3[15] + A4[15] + A5[15] + A6[15] + A7[15];
    A[16] = A0[16] + A1[16] + A2[16] + A3[16] + A4[16] + A5[16] + A6[16] + A7[16];
    A[17] = A0[17] + A1[17] + A2[17] + A3[17] + A4[17] + A5[17] + A6[17] + A7[17];
    A[18] = A0[18] + A1[18] + A2[18] + A3[18] + A4[18] + A5[18] + A6[18] + A7[18];
    A[19] = A0[19] + A1[19] + A2[19] + A3[19] + A4[19] + A5[19] + A6[19] + A7[19];
    A[20] = A0[20] + A1[20] + A2[20] + A3[20] + A4[20] + A5[20] + A6[20] + A7[20];
    A[21] = A0[21] + A1[21] + A2[21] + A3[21] + A4[21] + A5[21] + A6[21] + A7[21];
    A[22] = A0[22] + A1[22] + A2[22] + A3[22] + A4[22] + A5[22] + A6[22] + A7[22];
    A[23] = A0[23] + A1[23] + A2[23] + A3[23] + A4[23] + A5[23] + A6[23] + A7[23];
    A[24] = A0[24] + A1[24] + A2[24] + A3[24] + A4[24] + A5[24] + A6[24] + A7[24];
    A[25] = A0[25] + A1[25] + A2[25] + A3[25] + A4[25] + A5[25] + A6[25] + A7[25];
    A[26] = A0[26] + A1[26] + A2[26] + A3[26] + A4[26] + A5[26] + A6[26] + A7[26];
    A[27] = A0[27] + A1[27] + A2[27] + A3[27] + A4[27] + A5[27] + A6[27] + A7[27];
    A[28] = A0[28] + A1[28] + A2[28] + A3[28] + A4[28] + A5[28] + A6[28] + A7[28];
    A[29] = A0[29] + A1[29] + A2[29] + A3[29] + A4[29] + A5[29] + A6[29] + A7[29];
    A[30] = A0[30] + A1[30] + A2[30] + A3[30] + A4[30] + A5[30] + A6[30] + A7[30];
    A[31] = A0[31] + A1[31] + A2[31] + A3[31] + A4[31] + A5[31] + A6[31] + A7[31];
    A[32] = A0[32] + A1[32] + A2[32] + A3[32] + A4[32] + A5[32] + A6[32] + A7[32];
    A[33] = A0[33] + A1[33] + A2[33] + A3[33] + A4[33] + A5[33] + A6[33] + A7[33];
    A[34] = A0[34] + A1[34] + A2[34] + A3[34] + A4[34] + A5[34] + A6[34] + A7[34];
    A[35] = A0[35] + A1[35] + A2[35] + A3[35] + A4[35] + A5[35] + A6[35] + A7[35];
    A[36] = A0[36] + A1[36] + A2[36] + A3[36] + A4[36] + A5[36] + A6[36] + A7[36];
    A[37] = A0[37] + A1[37] + A2[37] + A3[37] + A4[37] + A5[37] + A6[37] + A7[37];
    A[38] = A0[38] + A1[38] + A2[38] + A3[38] + A4[38] + A5[38] + A6[38] + A7[38];
    A[39] = A0[39] + A1[39] + A2[39] + A3[39] + A4[39] + A5[39] + A6[39] + A7[39];
    A[40] = A0[40] + A1[40] + A2[40] + A3[40] + A4[40] + A5[40] + A6[40] + A7[40];
    A[41] = A0[41] + A1[41] + A2[41] + A3[41] + A4[41] + A5[41] + A6[41] + A7[41];
    A[42] = A0[42] + A1[42] + A2[42] + A3[42] + A4[42] + A5[42] + A6[42] + A7[42];
    A[43] = A0[43] + A1[43] + A2[43] + A3[43] + A4[43] + A5[43] + A6[43] + A7[43];
    A[44] = A0[44] + A1[44] + A2[44] + A3[44] + A4[44] + A5[44] + A6[44] + A7[44];
    A[45] = A0[45] + A1[45] + A2[45] + A3[45] + A4[45] + A5[45] + A6[45] + A7[45];
    A[46] = A0[46] + A1[46] + A2[46] + A3[46] + A4[46] + A5[46] + A6[46] + A7[46];
    A[47] = A0[47] + A1[47] + A2[47] + A3[47] + A4[47] + A5[47] + A6[47] + A7[47];
    A[48] = A0[48] + A1[48] + A2[48] + A3[48] + A4[48] + A5[48] + A6[48] + A7[48];
    A[49] = A0[49] + A1[49] + A2[49] + A3[49] + A4[49] + A5[49] + A6[49] + A7[49];
    A[50] = A0[50] + A1[50] + A2[50] + A3[50] + A4[50] + A5[50] + A6[50] + A7[50];
    A[51] = A0[51] + A1[51] + A2[51] + A3[51] + A4[51] + A5[51] + A6[51] + A7[51];
    A[52] = A0[52] + A1[52] + A2[52] + A3[52] + A4[52] + A5[52] + A6[52] + A7[52];
    A[53] = A0[53] + A1[53] + A2[53] + A3[53] + A4[53] + A5[53] + A6[53] + A7[53];
    A[54] = A0[54] + A1[54] + A2[54] + A3[54] + A4[54] + A5[54] + A6[54] + A7[54];
    A[55] = A0[55] + A1[55] + A2[55] + A3[55] + A4[55] + A5[55] + A6[55] + A7[55];
    A[56] = A0[56] + A1[56] + A2[56] + A3[56] + A4[56] + A5[56] + A6[56] + A7[56];
    A[57] = A0[57] + A1[57] + A2[57] + A3[57] + A4[57] + A5[57] + A6[57] + A7[57];
    A[58] = A0[58] + A1[58] + A2[58] + A3[58] + A4[58] + A5[58] + A6[58] + A7[58];
    A[59] = A0[59] + A1[59] + A2[59] + A3[59] + A4[59] + A5[59] + A6[59] + A7[59];
    A[60] = A0[60] + A1[60] + A2[60] + A3[60] + A4[60] + A5[60] + A6[60] + A7[60];
    A[61] = A0[61] + A1[61] + A2[61] + A3[61] + A4[61] + A5[61] + A6[61] + A7[61];
    A[62] = A0[62] + A1[62] + A2[62] + A3[62] + A4[62] + A5[62] + A6[62] + A7[62];
    A[63] = A0[63] + A1[63] + A2[63] + A3[63] + A4[63] + A5[63] + A6[63] + A7[63];
    A[64] = A0[64] + A1[64] + A2[64] + A3[64] + A4[64] + A5[64] + A6[64] + A7[64];
    A[65] = A0[65] + A1[65] + A2[65] + A3[65] + A4[65] + A5[65] + A6[65] + A7[65];
    A[66] = A0[66] + A1[66] + A2[66] + A3[66] + A4[66] + A5[66] + A6[66] + A7[66];
    A[67] = A0[67] + A1[67] + A2[67] + A3[67] + A4[67] + A5[67] + A6[67] + A7[67];
    A[68] = A0[68] + A1[68] + A2[68] + A3[68] + A4[68] + A5[68] + A6[68] + A7[68];
    A[69] = A0[69] + A1[69] + A2[69] + A3[69] + A4[69] + A5[69] + A6[69] + A7[69];
    A[70] = A0[70] + A1[70] + A2[70] + A3[70] + A4[70] + A5[70] + A6[70] + A7[70];
    A[71] = A0[71] + A1[71] + A2[71] + A3[71] + A4[71] + A5[71] + A6[71] + A7[71];
    A[72] = A0[72] + A1[72] + A2[72] + A3[72] + A4[72] + A5[72] + A6[72] + A7[72];
    A[73] = A0[73] + A1[73] + A2[73] + A3[73] + A4[73] + A5[73] + A6[73] + A7[73];
    A[74] = A0[74] + A1[74] + A2[74] + A3[74] + A4[74] + A5[74] + A6[74] + A7[74];
    A[75] = A0[75] + A1[75] + A2[75] + A3[75] + A4[75] + A5[75] + A6[75] + A7[75];
    A[76] = A0[76] + A1[76] + A2[76] + A3[76] + A4[76] + A5[76] + A6[76] + A7[76];
    A[77] = A0[77] + A1[77] + A2[77] + A3[77] + A4[77] + A5[77] + A6[77] + A7[77];
    A[78] = A0[78] + A1[78] + A2[78] + A3[78] + A4[78] + A5[78] + A6[78] + A7[78];
    A[79] = A0[79] + A1[79] + A2[79] + A3[79] + A4[79] + A5[79] + A6[79] + A7[79];
    A[80] = A0[80] + A1[80] + A2[80] + A3[80] + A4[80] + A5[80] + A6[80] + A7[80];
    A[81] = A0[81] + A1[81] + A2[81] + A3[81] + A4[81] + A5[81] + A6[81] + A7[81];
    A[82] = A0[82] + A1[82] + A2[82] + A3[82] + A4[82] + A5[82] + A6[82] + A7[82];
    A[83] = A0[83] + A1[83] + A2[83] + A3[83] + A4[83] + A5[83] + A6[83] + A7[83];
    A[84] = A0[84] + A1[84] + A2[84] + A3[84] + A4[84] + A5[84] + A6[84] + A7[84];
    A[85] = A0[85] + A1[85] + A2[85] + A3[85] + A4[85] + A5[85] + A6[85] + A7[85];
    A[86] = A0[86] + A1[86] + A2[86] + A3[86] + A4[86] + A5[86] + A6[86] + A7[86];
    A[87] = A0[87] + A1[87] + A2[87] + A3[87] + A4[87] + A5[87] + A6[87] + A7[87];
    A[88] = A0[88] + A1[88] + A2[88] + A3[88] + A4[88] + A5[88] + A6[88] + A7[88];
    A[89] = A0[89] + A1[89] + A2[89] + A3[89] + A4[89] + A5[89] + A6[89] + A7[89];
    A[90] = A0[90] + A1[90] + A2[90] + A3[90] + A4[90] + A5[90] + A6[90] + A7[90];
    A[91] = A0[91] + A1[91] + A2[91] + A3[91] + A4[91] + A5[91] + A6[91] + A7[91];
    A[92] = A0[92] + A1[92] + A2[92] + A3[92] + A4[92] + A5[92] + A6[92] + A7[92];
    A[93] = A0[93] + A1[93] + A2[93] + A3[93] + A4[93] + A5[93] + A6[93] + A7[93];
    A[94] = A0[94] + A1[94] + A2[94] + A3[94] + A4[94] + A5[94] + A6[94] + A7[94];
    A[95] = A0[95] + A1[95] + A2[95] + A3[95] + A4[95] + A5[95] + A6[95] + A7[95];
    A[96] = A0[96] + A1[96] + A2[96] + A3[96] + A4[96] + A5[96] + A6[96] + A7[96];
    A[97] = A0[97] + A1[97] + A2[97] + A3[97] + A4[97] + A5[97] + A6[97] + A7[97];
    A[98] = A0[98] + A1[98] + A2[98] + A3[98] + A4[98] + A5[98] + A6[98] + A7[98];
    A[99] = A0[99] + A1[99] + A2[99] + A3[99] + A4[99] + A5[99] + A6[99] + A7[99];
    A[100] = A0[100] + A1[100] + A2[100] + A3[100] + A4[100] + A5[100] + A6[100] + A7[100];
    A[101] = A0[101] + A1[101] + A2[101] + A3[101] + A4[101] + A5[101] + A6[101] + A7[101];
    A[102] = A0[102] + A1[102] + A2[102] + A3[102] + A4[102] + A5[102] + A6[102] + A7[102];
    A[103] = A0[103] + A1[103] + A2[103] + A3[103] + A4[103] + A5[103] + A6[103] + A7[103];
    A[104] = A0[104] + A1[104] + A2[104] + A3[104] + A4[104] + A5[104] + A6[104] + A7[104];
    A[105] = A0[105] + A1[105] + A2[105] + A3[105] + A4[105] + A5[105] + A6[105] + A7[105];
    A[106] = A0[106] + A1[106] + A2[106] + A3[106] + A4[106] + A5[106] + A6[106] + A7[106];
    A[107] = A0[107] + A1[107] + A2[107] + A3[107] + A4[107] + A5[107] + A6[107] + A7[107];
    A[108] = A0[108] + A1[108] + A2[108] + A3[108] + A4[108] + A5[108] + A6[108] + A7[108];
    A[109] = A0[109] + A1[109] + A2[109] + A3[109] + A4[109] + A5[109] + A6[109] + A7[109];
    A[110] = A0[110] + A1[110] + A2[110] + A3[110] + A4[110] + A5[110] + A6[110] + A7[110];
    A[111] = A0[111] + A1[111] + A2[111] + A3[111] + A4[111] + A5[111] + A6[111] + A7[111];
    A[112] = A0[112] + A1[112] + A2[112] + A3[112] + A4[112] + A5[112] + A6[112] + A7[112];
    A[113] = A0[113] + A1[113] + A2[113] + A3[113] + A4[113] + A5[113] + A6[113] + A7[113];
    A[114] = A0[114] + A1[114] + A2[114] + A3[114] + A4[114] + A5[114] + A6[114] + A7[114];
    A[115] = A0[115] + A1[115] + A2[115] + A3[115] + A4[115] + A5[115] + A6[115] + A7[115];
    A[116] = A0[116] + A1[116] + A2[116] + A3[116] + A4[116] + A5[116] + A6[116] + A7[116];
    A[117] = A0[117] + A1[117] + A2[117] + A3[117] + A4[117] + A5[117] + A6[117] + A7[117];
    A[118] = A0[118] + A1[118] + A2[118] + A3[118] + A4[118] + A5[118] + A6[118] + A7[118];
    A[119] = A0[119] + A1[119] + A2[119] + A3[119] + A4[119] + A5[119] + A6[119] + A7[119];
    A[120] = A0[120] + A1[120] + A2[120] + A3[120] + A4[120] + A5[120] + A6[120] + A7[120];
    A[121] = A0[121] + A1[121] + A2[121] + A3[121] + A4[121] + A5[121] + A6[121] + A7[121];
    A[122] = A0[122] + A1[122] + A2[122] + A3[122] + A4[122] + A5[122] + A6[122] + A7[122];
    A[123] = A0[123] + A1[123] + A2[123] + A3[123] + A4[123] + A5[123] + A6[123] + A7[123];
    A[124] = A0[124] + A1[124] + A2[124] + A3[124] + A4[124] + A5[124] + A6[124] + A7[124];
    A[125] = A0[125] + A1[125] + A2[125] + A3[125] + A4[125] + A5[125] + A6[125] + A7[125];
    A[126] = A0[126] + A1[126] + A2[126] + A3[126] + A4[126] + A5[126] + A6[126] + A7[126];
    A[127] = A0[127] + A1[127] + A2[127] + A3[127] + A4[127] + A5[127] + A6[127] + A7[127];
    A[128] = A0[128] + A1[128] + A2[128] + A3[128] + A4[128] + A5[128] + A6[128] + A7[128];
    A[129] = A0[129] + A1[129] + A2[129] + A3[129] + A4[129] + A5[129] + A6[129] + A7[129];
    A[130] = A0[130] + A1[130] + A2[130] + A3[130] + A4[130] + A5[130] + A6[130] + A7[130];
    A[131] = A0[131] + A1[131] + A2[131] + A3[131] + A4[131] + A5[131] + A6[131] + A7[131];
    A[132] = A0[132] + A1[132] + A2[132] + A3[132] + A4[132] + A5[132] + A6[132] + A7[132];
    A[133] = A0[133] + A1[133] + A2[133] + A3[133] + A4[133] + A5[133] + A6[133] + A7[133];
    A[134] = A0[134] + A1[134] + A2[134] + A3[134] + A4[134] + A5[134] + A6[134] + A7[134];
    A[135] = A0[135] + A1[135] + A2[135] + A3[135] + A4[135] + A5[135] + A6[135] + A7[135];
    A[136] = A0[136] + A1[136] + A2[136] + A3[136] + A4[136] + A5[136] + A6[136] + A7[136];
    A[137] = A0[137] + A1[137] + A2[137] + A3[137] + A4[137] + A5[137] + A6[137] + A7[137];
    A[138] = A0[138] + A1[138] + A2[138] + A3[138] + A4[138] + A5[138] + A6[138] + A7[138];
    A[139] = A0[139] + A1[139] + A2[139] + A3[139] + A4[139] + A5[139] + A6[139] + A7[139];
    A[140] = A0[140] + A1[140] + A2[140] + A3[140] + A4[140] + A5[140] + A6[140] + A7[140];
    A[141] = A0[141] + A1[141] + A2[141] + A3[141] + A4[141] + A5[141] + A6[141] + A7[141];
    A[142] = A0[142] + A1[142] + A2[142] + A3[142] + A4[142] + A5[142] + A6[142] + A7[142];
    A[143] = A0[143] + A1[143] + A2[143] + A3[143] + A4[143] + A5[143] + A6[143] + A7[143];
    A[144] = A0[144] + A1[144] + A2[144] + A3[144] + A4[144] + A5[144] + A6[144] + A7[144];
    A[145] = A0[145] + A1[145] + A2[145] + A3[145] + A4[145] + A5[145] + A6[145] + A7[145];
    A[146] = A0[146] + A1[146] + A2[146] + A3[146] + A4[146] + A5[146] + A6[146] + A7[146];
    A[147] = A0[147] + A1[147] + A2[147] + A3[147] + A4[147] + A5[147] + A6[147] + A7[147];
    A[148] = A0[148] + A1[148] + A2[148] + A3[148] + A4[148] + A5[148] + A6[148] + A7[148];
    A[149] = A0[149] + A1[149] + A2[149] + A3[149] + A4[149] + A5[149] + A6[149] + A7[149];
    A[150] = A0[150] + A1[150] + A2[150] + A3[150] + A4[150] + A5[150] + A6[150] + A7[150];
    A[151] = A0[151] + A1[151] + A2[151] + A3[151] + A4[151] + A5[151] + A6[151] + A7[151];
    A[152] = A0[152] + A1[152] + A2[152] + A3[152] + A4[152] + A5[152] + A6[152] + A7[152];
    A[153] = A0[153] + A1[153] + A2[153] + A3[153] + A4[153] + A5[153] + A6[153] + A7[153];
    A[154] = A0[154] + A1[154] + A2[154] + A3[154] + A4[154] + A5[154] + A6[154] + A7[154];
    A[155] = A0[155] + A1[155] + A2[155] + A3[155] + A4[155] + A5[155] + A6[155] + A7[155];
    A[156] = A0[156] + A1[156] + A2[156] + A3[156] + A4[156] + A5[156] + A6[156] + A7[156];
    A[157] = A0[157] + A1[157] + A2[157] + A3[157] + A4[157] + A5[157] + A6[157] + A7[157];
    A[158] = A0[158] + A1[158] + A2[158] + A3[158] + A4[158] + A5[158] + A6[158] + A7[158];
    A[159] = A0[159] + A1[159] + A2[159] + A3[159] + A4[159] + A5[159] + A6[159] + A7[159];
    A[160] = A0[160] + A1[160] + A2[160] + A3[160] + A4[160] + A5[160] + A6[160] + A7[160];
    A[161] = A0[161] + A1[161] + A2[161] + A3[161] + A4[161] + A5[161] + A6[161] + A7[161];
    A[162] = A0[162] + A1[162] + A2[162] + A3[162] + A4[162] + A5[162] + A6[162] + A7[162];
    A[163] = A0[163] + A1[163] + A2[163] + A3[163] + A4[163] + A5[163] + A6[163] + A7[163];
    A[164] = A0[164] + A1[164] + A2[164] + A3[164] + A4[164] + A5[164] + A6[164] + A7[164];
    A[165] = A0[165] + A1[165] + A2[165] + A3[165] + A4[165] + A5[165] + A6[165] + A7[165];
    A[166] = A0[166] + A1[166] + A2[166] + A3[166] + A4[166] + A5[166] + A6[166] + A7[166];
    A[167] = A0[167] + A1[167] + A2[167] + A3[167] + A4[167] + A5[167] + A6[167] + A7[167];
    A[168] = A0[168] + A1[168] + A2[168] + A3[168] + A4[168] + A5[168] + A6[168] + A7[168];
    A[169] = A0[169] + A1[169] + A2[169] + A3[169] + A4[169] + A5[169] + A6[169] + A7[169];
    A[170] = A0[170] + A1[170] + A2[170] + A3[170] + A4[170] + A5[170] + A6[170] + A7[170];
    A[171] = A0[171] + A1[171] + A2[171] + A3[171] + A4[171] + A5[171] + A6[171] + A7[171];
    A[172] = A0[172] + A1[172] + A2[172] + A3[172] + A4[172] + A5[172] + A6[172] + A7[172];
    A[173] = A0[173] + A1[173] + A2[173] + A3[173] + A4[173] + A5[173] + A6[173] + A7[173];
    A[174] = A0[174] + A1[174] + A2[174] + A3[174] + A4[174] + A5[174] + A6[174] + A7[174];
    A[175] = A0[175] + A1[175] + A2[175] + A3[175] + A4[175] + A5[175] + A6[175] + A7[175];
    A[176] = A0[176] + A1[176] + A2[176] + A3[176] + A4[176] + A5[176] + A6[176] + A7[176];
    A[177] = A0[177] + A1[177] + A2[177] + A3[177] + A4[177] + A5[177] + A6[177] + A7[177];
    A[178] = A0[178] + A1[178] + A2[178] + A3[178] + A4[178] + A5[178] + A6[178] + A7[178];
    A[179] = A0[179] + A1[179] + A2[179] + A3[179] + A4[179] + A5[179] + A6[179] + A7[179];
    A[180] = A0[180] + A1[180] + A2[180] + A3[180] + A4[180] + A5[180] + A6[180] + A7[180];
    A[181] = A0[181] + A1[181] + A2[181] + A3[181] + A4[181] + A5[181] + A6[181] + A7[181];
    A[182] = A0[182] + A1[182] + A2[182] + A3[182] + A4[182] + A5[182] + A6[182] + A7[182];
    A[183] = A0[183] + A1[183] + A2[183] + A3[183] + A4[183] + A5[183] + A6[183] + A7[183];
    A[184] = A0[184] + A1[184] + A2[184] + A3[184] + A4[184] + A5[184] + A6[184] + A7[184];
    A[185] = A0[185] + A1[185] + A2[185] + A3[185] + A4[185] + A5[185] + A6[185] + A7[185];
    A[186] = A0[186] + A1[186] + A2[186] + A3[186] + A4[186] + A5[186] + A6[186] + A7[186];
    A[187] = A0[187] + A1[187] + A2[187] + A3[187] + A4[187] + A5[187] + A6[187] + A7[187];
    A[188] = A0[188] + A1[188] + A2[188] + A3[188] + A4[188] + A5[188] + A6[188] + A7[188];
    A[189] = A0[189] + A1[189] + A2[189] + A3[189] + A4[189] + A5[189] + A6[189] + A7[189];
    A[190] = A0[190] + A1[190] + A2[190] + A3[190] + A4[190] + A5[190] + A6[190] + A7[190];
    A[191] = A0[191] + A1[191] + A2[191] + A3[191] + A4[191] + A5[191] + A6[191] + A7[191];
    A[192] = A0[192] + A1[192] + A2[192] + A3[192] + A4[192] + A5[192] + A6[192] + A7[192];
    A[193] = A0[193] + A1[193] + A2[193] + A3[193] + A4[193] + A5[193] + A6[193] + A7[193];
    A[194] = A0[194] + A1[194] + A2[194] + A3[194] + A4[194] + A5[194] + A6[194] + A7[194];
    A[195] = A0[195] + A1[195] + A2[195] + A3[195] + A4[195] + A5[195] + A6[195] + A7[195];
    A[196] = A0[196] + A1[196] + A2[196] + A3[196] + A4[196] + A5[196] + A6[196] + A7[196];
    A[197] = A0[197] + A1[197] + A2[197] + A3[197] + A4[197] + A5[197] + A6[197] + A7[197];
    A[198] = A0[198] + A1[198] + A2[198] + A3[198] + A4[198] + A5[198] + A6[198] + A7[198];
    A[199] = A0[199] + A1[199] + A2[199] + A3[199] + A4[199] + A5[199] + A6[199] + A7[199];
    A[200] = A0[200] + A1[200] + A2[200] + A3[200] + A4[200] + A5[200] + A6[200] + A7[200];
    A[201] = A0[201] + A1[201] + A2[201] + A3[201] + A4[201] + A5[201] + A6[201] + A7[201];
    A[202] = A0[202] + A1[202] + A2[202] + A3[202] + A4[202] + A5[202] + A6[202] + A7[202];
    A[203] = A0[203] + A1[203] + A2[203] + A3[203] + A4[203] + A5[203] + A6[203] + A7[203];
    A[204] = A0[204] + A1[204] + A2[204] + A3[204] + A4[204] + A5[204] + A6[204] + A7[204];
    A[205] = A0[205] + A1[205] + A2[205] + A3[205] + A4[205] + A5[205] + A6[205] + A7[205];
    A[206] = A0[206] + A1[206] + A2[206] + A3[206] + A4[206] + A5[206] + A6[206] + A7[206];
    A[207] = A0[207] + A1[207] + A2[207] + A3[207] + A4[207] + A5[207] + A6[207] + A7[207];
    A[208] = A0[208] + A1[208] + A2[208] + A3[208] + A4[208] + A5[208] + A6[208] + A7[208];
    A[209] = A0[209] + A1[209] + A2[209] + A3[209] + A4[209] + A5[209] + A6[209] + A7[209];
    A[210] = A0[210] + A1[210] + A2[210] + A3[210] + A4[210] + A5[210] + A6[210] + A7[210];
    A[211] = A0[211] + A1[211] + A2[211] + A3[211] + A4[211] + A5[211] + A6[211] + A7[211];
    A[212] = A0[212] + A1[212] + A2[212] + A3[212] + A4[212] + A5[212] + A6[212] + A7[212];
    A[213] = A0[213] + A1[213] + A2[213] + A3[213] + A4[213] + A5[213] + A6[213] + A7[213];
    A[214] = A0[214] + A1[214] + A2[214] + A3[214] + A4[214] + A5[214] + A6[214] + A7[214];
    A[215] = A0[215] + A1[215] + A2[215] + A3[215] + A4[215] + A5[215] + A6[215] + A7[215];
    A[216] = A0[216] + A1[216] + A2[216] + A3[216] + A4[216] + A5[216] + A6[216] + A7[216];
    A[217] = A0[217] + A1[217] + A2[217] + A3[217] + A4[217] + A5[217] + A6[217] + A7[217];
    A[218] = A0[218] + A1[218] + A2[218] + A3[218] + A4[218] + A5[218] + A6[218] + A7[218];
    A[219] = A0[219] + A1[219] + A2[219] + A3[219] + A4[219] + A5[219] + A6[219] + A7[219];
    A[220] = A0[220] + A1[220] + A2[220] + A3[220] + A4[220] + A5[220] + A6[220] + A7[220];
    A[221] = A0[221] + A1[221] + A2[221] + A3[221] + A4[221] + A5[221] + A6[221] + A7[221];
    A[222] = A0[222] + A1[222] + A2[222] + A3[222] + A4[222] + A5[222] + A6[222] + A7[222];
    A[223] = A0[223] + A1[223] + A2[223] + A3[223] + A4[223] + A5[223] + A6[223] + A7[223];
    A[224] = A0[224] + A1[224] + A2[224] + A3[224] + A4[224] + A5[224] + A6[224] + A7[224];
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class thstokes2d_form_0: public ufc::form
{
public:

  /// Constructor
  thstokes2d_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~thstokes2d_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((Index(0),), {Index(0): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))), Sum(IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(2), Index(1)), {Index(2): 2, Index(1): 2})), MultiIndex((Index(3), Index(4)), {Index(4): 2, Index(3): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((Index(6), Index(5)), {Index(5): 2, Index(6): 2})), MultiIndex((Index(3), Index(4)), {Index(4): 2, Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(4),), {Index(4): 2})), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7),), {Index(7): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', 1, Space(2)), 2, 2), FiniteElement('Lagrange', Cell('triangle', 1, Space(2)), 1)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3})))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 0;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_finite_element_3();
        break;
      }
    case 1:
      {
        return new thstokes2d_finite_element_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_dof_map_3();
        break;
      }
    case 1:
      {
        return new thstokes2d_dof_map_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new thstokes2d_cell_integral_0_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>

namespace THStokes2D
{

class Form_0_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_0()
  {
  }

};

class Form_0_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new thstokes2d_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new thstokes2d_dof_map_3()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_1()
  {
  }

};

class Form_0: public dolfin::Form
{
public:

  // Constructor
  Form_0(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new thstokes2d_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new thstokes2d_form_0());
  }

  // Destructor
  ~Form_0()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {

    dolfin::error("No coefficients.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {

    dolfin::error("No coefficients.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_0_FunctionSpace_0 TestSpace;
  typedef Form_0_FunctionSpace_1 TrialSpace;

  // Coefficients
};

// Class typedefs
typedef Form_0 BilinearForm;
typedef Form_0::TestSpace FunctionSpace;

}

#endif
