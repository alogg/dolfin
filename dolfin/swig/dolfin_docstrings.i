// An autogenerated docstringfile


// File: index.xml

// File: classdolfin_1_1ALE.xml
%feature("docstring") dolfin::ALE "

This class provides functionality useful for implementation of ALE
(Arbitrary Lagrangian-Eulerian) methods, in particular moving the
boundary vertices of a mesh and then interpolating the new coordinates
for the interior vertices accordingly.

C++ includes: ALE.h ";


// File: classdolfin_1_1Array.xml
%feature("docstring") dolfin::Array "

Array is a container that provides O(1) access time to elements and
O(1) memory overhead.

It is a wrapper for std::vector, so see the STL manual for further
details:http://www.sgi.com/tech/stl/

C++ includes: Array.h ";

%feature("docstring")  dolfin::Array::Array "

Create empty array. ";

%feature("docstring")  dolfin::Array::Array "

Create array of given size. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing two elements. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing three elements. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing four elements. ";

%feature("docstring")  dolfin::Array::Array "

Create array containing five elements. ";

%feature("docstring")  dolfin::Array::Array "

Copy constructor. ";

%feature("docstring")  dolfin::Array::~Array "

Destructor. ";


// File: classdolfin_1_1Assembler.xml
%feature("docstring") dolfin::Assembler "

This class provides automated assembly of linear systems, or more
generally, assembly of a sparse tensor from a given variational form.

C++ includes: Assembler.h ";

%feature("docstring")  dolfin::Assembler::Assembler "

Constructor. ";

%feature("docstring")  dolfin::Assembler::~Assembler "

Destructor. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given variational form. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given variational form over a sub domain. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given variational form over a sub domain.

Assemble tensor from given variational form over sub domains ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble scalar from given variational form. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble scalar from given variational form over a sub domain. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble scalar from given variational form over sub domains. ";

%feature("docstring")  dolfin::Assembler::assemble "

Assemble tensor from given (UFC) form, coefficients and sub domains.
This is the main assembly function in DOLFIN. All other assembly
functions end up calling this function.

The MeshFunction arguments can be used to specify assembly over
subdomains of the mesh cells, exterior facets and interior facets.
Either a null pointer or an empty MeshFunction may be used to specify
that the tensor should be assembled over the entire set of cells or
facets. ";


// File: classdolfin_1_1AvgMeshSize.xml
%feature("docstring") dolfin::AvgMeshSize "

This function represents the average of the local mesh size on a given
mesh.

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::AvgMeshSize::AvgMeshSize "";

%feature("docstring")  dolfin::AvgMeshSize::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1BoundaryCondition.xml
%feature("docstring") dolfin::BoundaryCondition "

Common base class for boundary conditions.

C++ includes: BoundaryCondition.h ";

%feature("docstring")  dolfin::BoundaryCondition::BoundaryCondition "

Constructor. ";

%feature("docstring")  dolfin::BoundaryCondition::~BoundaryCondition "

Destructor. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system for a nonlinear problem. ";

%feature("docstring")  dolfin::BoundaryCondition::apply "

Apply boundary condition to linear system for a nonlinear problem. ";


// File: classdolfin_1_1BoundaryCondition_1_1LocalData.xml


// File: classdolfin_1_1BoundaryMesh.xml
%feature("docstring") dolfin::BoundaryMesh "

A BoundaryMesh is a mesh over the boundary of some given mesh.

C++ includes: BoundaryMesh.h ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create an empty boundary mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create boundary mesh from given mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create boundary mesh from given mesh and a mapping from the vertices
of the boundary to the corresponding mesh entities in the original
mesh ";

%feature("docstring")  dolfin::BoundaryMesh::BoundaryMesh "

Create boundary mesh from given mesh and compute a pair of mappings
from the vertices and cells of the boundary to the corresponding mesh
entities in the original mesh ";

%feature("docstring")  dolfin::BoundaryMesh::~BoundaryMesh "

Destructor. ";

%feature("docstring")  dolfin::BoundaryMesh::init "

Initialize boundary mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::init "

Initialize boundary mesh. ";

%feature("docstring")  dolfin::BoundaryMesh::init "

Initialize boundary mesh. ";


// File: classdolfin_1_1Cell.xml
%feature("docstring") dolfin::Cell "

A Cell is a MeshEntity of topological codimension 0.

C++ includes: Cell.h ";

%feature("docstring")  dolfin::Cell::Cell "

Constructor. ";

%feature("docstring")  dolfin::Cell::~Cell "

Destructor. ";

%feature("docstring")  dolfin::Cell::type "

Return type of cell. ";

%feature("docstring")  dolfin::Cell::orientation "

Compute orientation of cell (0 is right, 1 is left). ";

%feature("docstring")  dolfin::Cell::volume "

Compute (generalized) volume of cell. ";

%feature("docstring")  dolfin::Cell::diameter "

Compute diameter of cell. ";

%feature("docstring")  dolfin::Cell::midpoint "

Compute midpoint of cell. ";

%feature("docstring")  dolfin::Cell::normal "

Compute component i of normal of given facet with respect to the cell.
";

%feature("docstring")  dolfin::Cell::normal "

Compute normal of given facet with respect to the cell. ";


// File: classdolfin_1_1CellIterator.xml
%feature("docstring") dolfin::CellIterator "

A CellIterator is a MeshEntityIterator of topological codimension 0.

C++ includes: Cell.h ";

%feature("docstring")  dolfin::CellIterator::CellIterator "";

%feature("docstring")  dolfin::CellIterator::CellIterator "";


// File: classdolfin_1_1cGqMethod.xml
%feature("docstring") dolfin::cGqMethod "

Contains all numeric constants, such as nodal points and nodal
weights, needed for the cG(q) method. The order q must be at least 1.
Note that q refers to the polynomial order and not the order of
convergence for the method, which is 2q.

C++ includes: cGqMethod.h ";

%feature("docstring")  dolfin::cGqMethod::cGqMethod "";

%feature("docstring")  dolfin::cGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::cGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::cGqMethod::ueval "

Evaluate solution at given node (inline optimized). ";

%feature("docstring")  dolfin::cGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::cGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::cGqMethod::timestep "

Compute new time step based on the given residual. ";

%feature("docstring")  dolfin::cGqMethod::error "

Compute error estimate (modulo stability factor). ";

%feature("docstring")  dolfin::cGqMethod::disp "

Display method data. ";


// File: classdolfin_1_1ComplexODE.xml
%feature("docstring") dolfin::ComplexODE "

A ComplexODE represents an initial value problem for a system of
complex-valued ordinary differential equations:

M(z, t) z'(t) = f(z(t), t) on (0,T]

z(0) = z0,

where z(t) is a complex-valued vector of length n. The imaginary unit
is provided by the member variable j satisfying j^2 = -1.

This class is a wrapper for a standard real-valued ODE, and provides
an interface that automatically translates the given complex-valued
ODE of size n to a standard real-valued ODE of size N = 2n.

The real and imaginary parts of the solution are stored in the
following order in the solution vector u(t):

u = (Re z0, Im z0, Re z1, Im z1, ..., Re z_n-1, Im z_n-1).

C++ includes: ComplexODE.h ";

%feature("docstring")  dolfin::ComplexODE::ComplexODE "

Constructor. ";

%feature("docstring")  dolfin::ComplexODE::~ComplexODE "

Destructor. ";

%feature("docstring")  dolfin::ComplexODE::z0 "

Set initial values. ";

%feature("docstring")  dolfin::ComplexODE::f "

Evaluate right-hand side (multi-adaptive version). ";

%feature("docstring")  dolfin::ComplexODE::f "

Evaluate right-hand side (mono-adaptive version). ";

%feature("docstring")  dolfin::ComplexODE::M "

Compute product y = Mx for implicit system. ";

%feature("docstring")  dolfin::ComplexODE::J "

Compute product y = Jx for Jacobian J. ";

%feature("docstring")  dolfin::ComplexODE::k "

Return time step for component i (optional). ";

%feature("docstring")  dolfin::ComplexODE::update "

Update ODE, return false to stop (optional). ";

%feature("docstring")  dolfin::ComplexODE::u0 "

Return initial value for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::f "

Return right-hand side for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::f "

Evaluate right-hand side for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::M "

Compute product y = Mx for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::J "

Compute product y = Jx for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::timestep "

Return time step for real-valued ODE. ";

%feature("docstring")  dolfin::ComplexODE::update "

Update for real-valued ODE. ";


// File: classdolfin_1_1DefaultFactory.xml
%feature("docstring") dolfin::DefaultFactory "";

%feature("docstring")  dolfin::DefaultFactory::DefaultFactory "

Constructor. ";

%feature("docstring")  dolfin::DefaultFactory::~DefaultFactory "

Destructor. ";

%feature("docstring")  dolfin::DefaultFactory::createMatrix "

Create empty matrix. ";

%feature("docstring")  dolfin::DefaultFactory::createVector "

Create empty vector. ";

%feature("docstring")  dolfin::DefaultFactory::createPattern "

Create empty sparsity pattern. ";


// File: classdolfin_1_1dGqMethod.xml
%feature("docstring") dolfin::dGqMethod "

Contains all numeric constants, such as nodal points and nodal
weights, needed for the dG(q) method. The order q must be at least 0.
Note that q refers to the polynomial order and not the order of
convergence for the method, which is 2q + 1.

C++ includes: dGqMethod.h ";

%feature("docstring")  dolfin::dGqMethod::dGqMethod "";

%feature("docstring")  dolfin::dGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::dGqMethod::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::dGqMethod::ueval "

Evaluate solution at given node (inline optimized). ";

%feature("docstring")  dolfin::dGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::dGqMethod::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::dGqMethod::timestep "

Compute new time step based on the given residual. ";

%feature("docstring")  dolfin::dGqMethod::error "

Compute error estimate (modulo stability factor). ";

%feature("docstring")  dolfin::dGqMethod::disp "

Display method data. ";


// File: classdolfin_1_1DirectedClique.xml
%feature("docstring") dolfin::DirectedClique "

A directed graph where all vertices are adjacent to each other. The
number of vertices is given by num_vertices >= 1. The number of edges
is given by (num_vertices - 1) * num_vertices)

C++ includes: DirectedClique.h ";

%feature("docstring")  dolfin::DirectedClique::DirectedClique "";


// File: classdolfin_1_1DirichletBC.xml
%feature("docstring") dolfin::DirichletBC "

This class specifies the interface for setting (strong) Dirichlet
boundary conditions for partial differential equations,

u = g on G,

where u is the solution to be computed, g is a function and G is a sub
domain of the mesh.

A DirichletBC is specified by the Function g, the Mesh, and boundary
indicators on (a subset of) the mesh boundary.

The boundary indicators may be specified in a number of different
ways.

The simplest approach is to specify the boundary by a SubDomain
object, using the inside() function to specify on which facets the
boundary conditions should be applied.

Alternatively, the boundary may be specified by a MeshFunction
labeling all mesh facets together with a number that specifies which
facets should be included in the boundary.

The third option is to attach the boundary information to the mesh.
This is handled automatically when exporting a mesh from for example
VMTK.

For mixed systems (vector-valued and mixed elements), an optional set
of parameters may be used to specify for which sub system the boundary
condition should be specified.

C++ includes: DirichletBC.h ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create boundary condition for sub domain. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create boundary condition for sub domain specified by index. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create boundary condition for boundary data included in the mesh. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create sub system boundary condition for sub domain. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create sub system boundary condition for sub domain specified by
index. ";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "

Create sub system boundary condition for boundary data included in the
mesh. ";

%feature("docstring")  dolfin::DirichletBC::~DirichletBC "

Destructor. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system for a nonlinear problem. ";

%feature("docstring")  dolfin::DirichletBC::apply "

Apply boundary condition to linear system for a nonlinear problem. ";

%feature("docstring")  dolfin::DirichletBC::zero "

Make row associated with boundary conditions zero, useful for non-
diagonal matrices in a block matrix. ";

%feature("docstring")  dolfin::DirichletBC::zero "

Make row associated with boundary conditions zero, useful for non-
diagonal matrices in a block matrix. ";

%feature("docstring")  dolfin::DirichletBC::setSubSystem "

Set (or update) value for sub system. ";

%feature("docstring")  dolfin::DirichletBC::mesh "

Return mesh. ";


// File: classdolfin_1_1DofMap.xml
%feature("docstring") dolfin::DofMap "

This class handles the mapping of degrees of freedom. It wraps a
ufc::dof_map on a specific mesh and provides optional precomputation
and reordering of dofs.

C++ includes: DofMap.h ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh. ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh (parallel). ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh. ";

%feature("docstring")  dolfin::DofMap::DofMap "

Create dof map on mesh (parallel). ";

%feature("docstring")  dolfin::DofMap::~DofMap "

Destructor. ";

%feature("docstring")  dolfin::DofMap::signature "

Return a string identifying the dof map. ";

%feature("docstring")  dolfin::DofMap::global_dimension "

Return the dimension of the global finite element function space. ";

%feature("docstring")  dolfin::DofMap::local_dimension "

Return the dimension of the local finite element function space. ";

%feature("docstring")  dolfin::DofMap::macro_local_dimension "

Return the dimension of the local finite element function space. ";

%feature("docstring")  dolfin::DofMap::num_facet_dofs "

Return number of facet dofs. ";

%feature("docstring")  dolfin::DofMap::tabulate_dofs "

Tabulate the local-to-global mapping of dofs on a cell. ";

%feature("docstring")  dolfin::DofMap::tabulate_facet_dofs "

Tabulate local-local facet dofs. ";

%feature("docstring")  dolfin::DofMap::tabulate_dofs "

Tabulate the local-to-global mapping of dofs on a ufc cell. ";

%feature("docstring")  dolfin::DofMap::tabulate_coordinates "";

%feature("docstring")  dolfin::DofMap::extractDofMap "

Extract sub dof map. ";

%feature("docstring")  dolfin::DofMap::mesh "

Return mesh associated with map. ";

%feature("docstring")  dolfin::DofMap::build "

Build parallel dof map. ";

%feature("docstring")  dolfin::DofMap::getMap "

Return renumbering (used for testing). ";

%feature("docstring")  dolfin::DofMap::disp "

Display mapping. ";


// File: classdolfin_1_1DofMapSet.xml
%feature("docstring") dolfin::DofMapSet "

This class provides storage and caching of (precomputed) dof maps and
enables reuse of already computed dof maps with equal signatures.

C++ includes: DofMapSet.h ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create empty set of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps (parallel). ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::DofMapSet "

Create set of dof maps (parallel). ";

%feature("docstring")  dolfin::DofMapSet::~DofMapSet "

Destructor. ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form. ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form (parallel). ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form. ";

%feature("docstring")  dolfin::DofMapSet::update "

Update set of dof maps for given form (parallel). ";

%feature("docstring")  dolfin::DofMapSet::size "

Return number of dof maps. ";

%feature("docstring")  dolfin::DofMapSet::build "

Build parallel dof maps. ";

%feature("docstring")  dolfin::DofMapSet::parallel "";


// File: classdolfin_1_1Edge.xml
%feature("docstring") dolfin::Edge "

An Edge is a MeshEntity of topological dimension 1.

C++ includes: Edge.h ";

%feature("docstring")  dolfin::Edge::Edge "

Create edge on given mesh. ";

%feature("docstring")  dolfin::Edge::Edge "

Create edge from mesh entity. ";

%feature("docstring")  dolfin::Edge::~Edge "

Destructor. ";

%feature("docstring")  dolfin::Edge::length "

Compute Euclidian length of edge. ";

%feature("docstring")  dolfin::Edge::midpoint "

Compute coordinates of edge midpoint as a 3D point value. ";


// File: classdolfin_1_1EdgeIterator.xml
%feature("docstring") dolfin::EdgeIterator "

An EdgeIterator is a MeshEntityIterator of topological dimension 1.

C++ includes: Edge.h ";

%feature("docstring")  dolfin::EdgeIterator::EdgeIterator "";

%feature("docstring")  dolfin::EdgeIterator::EdgeIterator "";


// File: classdolfin_1_1ElementLibrary.xml
%feature("docstring") dolfin::ElementLibrary "

Library of pregenerated finite elements and dof maps.

C++ includes: ElementLibrary.h ";


// File: classdolfin_1_1Event.xml
%feature("docstring") dolfin::Event "

A event is a string message which is displayed only a limited number
of times.

Example of usage:

Event event(\"System is stiff, damping is needed.\"); while () { ...
if ( ... ) { event(); ... } }

C++ includes: Event.h ";

%feature("docstring")  dolfin::Event::Event "

Constructor. ";

%feature("docstring")  dolfin::Event::~Event "

Destructor. ";

%feature("docstring")  dolfin::Event::count "

Display count. ";

%feature("docstring")  dolfin::Event::maxcount "

Maximum display count. ";


// File: classdolfin_1_1Face.xml
%feature("docstring") dolfin::Face "

A Face is a MeshEntity of topological dimension 2.

C++ includes: Face.h ";

%feature("docstring")  dolfin::Face::Face "

Constructor. ";

%feature("docstring")  dolfin::Face::~Face "

Destructor. ";


// File: classdolfin_1_1FaceIterator.xml
%feature("docstring") dolfin::FaceIterator "

A FaceIterator is a MeshEntityIterator of topological dimension 2.

C++ includes: Face.h ";

%feature("docstring")  dolfin::FaceIterator::FaceIterator "";

%feature("docstring")  dolfin::FaceIterator::FaceIterator "";


// File: classdolfin_1_1Facet.xml
%feature("docstring") dolfin::Facet "

A Facet is a MeshEntity of topological codimension 1.

C++ includes: Facet.h ";

%feature("docstring")  dolfin::Facet::Facet "

Constructor. ";

%feature("docstring")  dolfin::Facet::~Facet "

Destructor. ";


// File: classdolfin_1_1FacetIterator.xml
%feature("docstring") dolfin::FacetIterator "

A FacetIterator is a MeshEntityIterator of topological codimension 1.

C++ includes: Facet.h ";

%feature("docstring")  dolfin::FacetIterator::FacetIterator "";

%feature("docstring")  dolfin::FacetIterator::FacetIterator "";


// File: classdolfin_1_1FacetNormal.xml
%feature("docstring") dolfin::FacetNormal "

This function represents the outward unit normal on mesh facets. Note
that it is only nonzero on cell facets (not on cells).

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::FacetNormal::FacetNormal "";

%feature("docstring")  dolfin::FacetNormal::eval "

Evaluate function at given point (overload for scalar user-defined
function). ";


// File: classdolfin_1_1File.xml
%feature("docstring") dolfin::File "

A File represents a data file for reading and writing objects. Unless
specified explicitly, the format is determined by the file name
suffix.

C++ includes: File.h ";

%feature("docstring")  dolfin::File::File "

Create a file with given name. ";

%feature("docstring")  dolfin::File::File "

Create a file with given name and type (format). ";

%feature("docstring")  dolfin::File::~File "

Destructor. ";


// File: classdolfin_1_1Form.xml
%feature("docstring") dolfin::Form "

Base class for UFC code generated by FFC for DOLFIN with option -l.

C++ includes: Form.h ";

%feature("docstring")  dolfin::Form::Form "

Constructor. ";

%feature("docstring")  dolfin::Form::~Form "

Destructor. ";

%feature("docstring")  dolfin::Form::form "

Return UFC form. ";

%feature("docstring")  dolfin::Form::coefficients "

Return array of coefficients. ";

%feature("docstring")  dolfin::Form::updateDofMaps "

Create degree of freedom maps. ";

%feature("docstring")  dolfin::Form::updateDofMaps "

Create degree of freedom maps. ";

%feature("docstring")  dolfin::Form::setDofMaps "

Set degree of freedom maps. ";

%feature("docstring")  dolfin::Form::dofMaps "

Return DofMapSet. ";


// File: classdolfin_1_1Function.xml
%feature("docstring") dolfin::Function "

This class represents a function that can be evaluated on a mesh. The
actual representation of the function can vary, but the typical
representation is in terms of a mesh, a vector of degrees of freedom,
a finite element and a dof map that determines the distribution of
degrees of freedom on the mesh.

It is also possible to have user-defined functions, either by
overloading the eval function of this class or by giving a function
(pointer) that returns the value of the function.

C++ includes: Function.h ";

%feature("docstring")  dolfin::Function::Function "

Create empty function (read data from file). ";

%feature("docstring")  dolfin::Function::Function "

Create user-defined function (evaluation operator must be overloaded).
";

%feature("docstring")  dolfin::Function::Function "

Create constant function from given value. ";

%feature("docstring")  dolfin::Function::Function "

Create function from given ufc::function. ";

%feature("docstring")  dolfin::Function::Function "

Create function from given GenericFunction.

Create discrete function for argument function i of form ";

%feature("docstring")  dolfin::Function::Function "

Create discrete function for argument function i of form. ";

%feature("docstring")  dolfin::Function::Function "

Create discrete function from sub function. ";

%feature("docstring")  dolfin::Function::Function "

Create function from data file. ";

%feature("docstring")  dolfin::Function::Function "

Copy constructor. ";

%feature("docstring")  dolfin::Function::~Function "

Destructor. ";

%feature("docstring")  dolfin::Function::init "

Create discrete function for argument function i of form. ";

%feature("docstring")  dolfin::Function::init "

Create discrete function for argument function i of form. ";

%feature("docstring")  dolfin::Function::type "

Return the type of function. ";

%feature("docstring")  dolfin::Function::rank "

Return the rank of the value space. ";

%feature("docstring")  dolfin::Function::dim "

Return the dimension of the value space for axis i. ";

%feature("docstring")  dolfin::Function::mesh "

Return the mesh. ";

%feature("docstring")  dolfin::Function::vector "

Return the vector associated with a DiscreteFunction. ";

%feature("docstring")  dolfin::Function::numSubFunctions "

Return the number of sub functions (only for discrete functions). ";

%feature("docstring")  dolfin::Function::interpolate "

Interpolate function to vertices of mesh. ";

%feature("docstring")  dolfin::Function::interpolate "

Interpolate function to finite element space on cell. ";

%feature("docstring")  dolfin::Function::eval "

Evaluate function at given point (used for subclassing through SWIG
interface). ";

%feature("docstring")  dolfin::Function::eval "

Evaluate function at given point (overload for scalar user-defined
function). ";

%feature("docstring")  dolfin::Function::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1GaussianQuadrature.xml
%feature("docstring") dolfin::GaussianQuadrature "

Gaussian-type quadrature rule on the real line, including Gauss,
Radau, and Lobatto quadrature.

Points and weights are computed to be exact within a tolerance of
DOLFIN_EPS. Comparing with known exact values for n <= 3 shows that we
obtain full precision (16 digits, error less than 2e-16).

C++ includes: GaussianQuadrature.h ";

%feature("docstring")  dolfin::GaussianQuadrature::GaussianQuadrature
"";


// File: classdolfin_1_1GaussQuadrature.xml
%feature("docstring") dolfin::GaussQuadrature "

Gauss (Gauss-Legendre) quadrature on the interval [-1,1]. The n
quadrature points are given by the zeros of the n:th Legendre Pn(x).

The quadrature points are computed using Newton's method, and the
quadrature weights are computed by solving a linear system determined
by the condition that Gauss quadrature with n points should be exact
for polynomials of degree 2n-1.

C++ includes: GaussQuadrature.h ";

%feature("docstring")  dolfin::GaussQuadrature::GaussQuadrature "";

%feature("docstring")  dolfin::GaussQuadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1GenericMatrix.xml
%feature("docstring") dolfin::GenericMatrix "

This class defines a common interface for matrices.

C++ includes: GenericMatrix.h ";

%feature("docstring")  dolfin::GenericMatrix::~GenericMatrix "

Destructor. ";

%feature("docstring")  dolfin::GenericMatrix::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::GenericMatrix::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::GenericMatrix::rank "

Return tensor rank (number of dimensions). ";

%feature("docstring")  dolfin::GenericMatrix::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::GenericMatrix::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericMatrix::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericMatrix::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericMatrix::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::GenericMatrix::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::GenericMatrix::disp "

Display tensor. ";

%feature("docstring")  dolfin::GenericMatrix::init "

Initialize M x N matrix. ";

%feature("docstring")  dolfin::GenericMatrix::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericMatrix::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericMatrix::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericMatrix::getrow "

Get non-zero values of given row. ";

%feature("docstring")  dolfin::GenericMatrix::setrow "

Set values for given row. ";

%feature("docstring")  dolfin::GenericMatrix::zero "

Set given rows to zero. ";

%feature("docstring")  dolfin::GenericMatrix::ident "

Set given rows to identity matrix. ";

%feature("docstring")  dolfin::GenericMatrix::mult "

Matrix-vector product, y = Ax. ";

%feature("docstring")  dolfin::GenericMatrix::getitem "

Get value of given entry. ";

%feature("docstring")  dolfin::GenericMatrix::setitem "

Set given entry to value. ";


// File: classdolfin_1_1GenericSparsityPattern.xml
%feature("docstring") dolfin::GenericSparsityPattern "

Base class for sparsity patterns of vectors/matrices. Concrete sub
classes can be used to initialize vectors and sparse matrices.

C++ includes: GenericSparsityPattern.h ";

%feature("docstring")
dolfin::GenericSparsityPattern::GenericSparsityPattern "

Constructor. ";

%feature("docstring")
dolfin::GenericSparsityPattern::~GenericSparsityPattern "

Destructor. ";

%feature("docstring")  dolfin::GenericSparsityPattern::init "

Initialize sparsity pattern for a generic tensor. ";

%feature("docstring")  dolfin::GenericSparsityPattern::pinit "

Initialise sparsity pattern for a parallel generic tensor. ";

%feature("docstring")  dolfin::GenericSparsityPattern::insert "

Insert non-zero entry. ";

%feature("docstring")  dolfin::GenericSparsityPattern::pinsert "

Insert non-zero entry. ";

%feature("docstring")  dolfin::GenericSparsityPattern::size "

Return global size. ";

%feature("docstring")
dolfin::GenericSparsityPattern::numNonZeroPerRow "

Return array with number of non-zeroes per row. ";

%feature("docstring")  dolfin::GenericSparsityPattern::numNonZero "

Return total number of non-zeroes. ";

%feature("docstring")  dolfin::GenericSparsityPattern::apply "

Finalize sparsity pattern (needed by most parallel la backends). ";


// File: classdolfin_1_1GenericTensor.xml
%feature("docstring") dolfin::GenericTensor "

This class defines a common interface for arbitrary rank tensors.

C++ includes: GenericTensor.h ";

%feature("docstring")  dolfin::GenericTensor::~GenericTensor "

Destructor. ";

%feature("docstring")  dolfin::GenericTensor::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::GenericTensor::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::GenericTensor::rank "

Return tensor rank (number of dimensions). ";

%feature("docstring")  dolfin::GenericTensor::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::GenericTensor::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericTensor::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericTensor::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericTensor::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::GenericTensor::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::GenericTensor::disp "

Display tensor. ";

%feature("docstring")  dolfin::GenericTensor::factory "

Return linear algebra backend factory. ";

%feature("docstring")  dolfin::GenericTensor::down_cast "

Cast a GenericTensor to its derived class (const version). ";

%feature("docstring")  dolfin::GenericTensor::down_cast "

Cast a GenericTensor to its derived class (non-const version). ";

%feature("docstring")  dolfin::GenericTensor::has_type "

Check whether the GenericTensor instance matches a specific type. ";

%feature("docstring")  dolfin::GenericTensor::instance "

Return concrete instance / unwrap (const version). ";

%feature("docstring")  dolfin::GenericTensor::instance "

Return concrete instance / unwrap (non-const version). ";


// File: classdolfin_1_1GenericVector.xml
%feature("docstring") dolfin::GenericVector "

This class defines a common interface for vectors.

C++ includes: GenericVector.h ";

%feature("docstring")  dolfin::GenericVector::~GenericVector "

Destructor. ";

%feature("docstring")  dolfin::GenericVector::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::GenericVector::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::GenericVector::rank "

Return tensor rank (number of dimensions). ";

%feature("docstring")  dolfin::GenericVector::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::GenericVector::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericVector::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericVector::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericVector::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::GenericVector::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::GenericVector::disp "

Display tensor. ";

%feature("docstring")  dolfin::GenericVector::init "

Initialize vector of size N. ";

%feature("docstring")  dolfin::GenericVector::size "

Return size of vector. ";

%feature("docstring")  dolfin::GenericVector::get "

Get block of values. ";

%feature("docstring")  dolfin::GenericVector::set "

Set block of values. ";

%feature("docstring")  dolfin::GenericVector::add "

Add block of values. ";

%feature("docstring")  dolfin::GenericVector::get "

Get all values. ";

%feature("docstring")  dolfin::GenericVector::set "

Set all values. ";

%feature("docstring")  dolfin::GenericVector::add "

Add values to each entry. ";

%feature("docstring")  dolfin::GenericVector::axpy "

Add multiple of given vector (AXPY operation). ";

%feature("docstring")  dolfin::GenericVector::inner "

Return inner product with given vector. ";

%feature("docstring")  dolfin::GenericVector::norm "

Return norm of vector. ";

%feature("docstring")  dolfin::GenericVector::min "

Return minimum value of vector. ";

%feature("docstring")  dolfin::GenericVector::max "

Return maximum value of vector. ";

%feature("docstring")  dolfin::GenericVector::getitem "

Get value of given entry. ";

%feature("docstring")  dolfin::GenericVector::setitem "

Set given entry to value. ";


// File: classdolfin_1_1Graph.xml
%feature("docstring") dolfin::Graph "

A Graph consists of a set of vertices and edges.

The graph is stored in Compressed Sparse Row (CSR) format. This format
stores edges and vertices separately in two arrays, with the indices
into these arrays corresponding to the identifier for the vertex or
edge, respectively. The edge array stores the edge destination
vertices while the vertice array stores the offset into the edge
array. E.g. the edges connected to vertex i are: edges[vertices[i]],
edges[vertices[i]+1], ..., edges[vertices[i]-1].

In a graph with n vertices the vertex array will be of size n+1. The
edge array will be of size m in a directed graph and size 2m in a
undirected graph (an edge between vertices u and v is stored as (v,u)
as well as (u,v)).

Example graph: 0 -- 1 | \\\\ | | \\\\ | 2 -- 3

Stored as:

edges = [123030312] vertices = [03579]

Note that the last integer of vertices does not represent a vertex,
but is there to support edge iteration as described above.

CSR format minimizes memory usage and is suitable for large graphs
that do not change.

C++ includes: Graph.h ";

%feature("docstring")  dolfin::Graph::Graph "

Create empty graph. ";

%feature("docstring")  dolfin::Graph::Graph "

Copy constructor. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from given file. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from mesh. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from mesh. ";

%feature("docstring")  dolfin::Graph::Graph "

Create graph from mesh. ";

%feature("docstring")  dolfin::Graph::~Graph "

Destructor. ";

%feature("docstring")  dolfin::Graph::numVertices "

Assignment.

Return number of vertices ";

%feature("docstring")  dolfin::Graph::numEdges "

Return number of edges. ";

%feature("docstring")  dolfin::Graph::numEdges "

Return number of edges incident to vertex u. ";

%feature("docstring")  dolfin::Graph::numArches "

Return number of arches (outgoing edges). ";

%feature("docstring")  dolfin::Graph::adjacent "

Check if vertex u is adjacent to vertex v. ";

%feature("docstring")  dolfin::Graph::edgeWeights "

Return edge weights. ";

%feature("docstring")  dolfin::Graph::vertexWeights "

Return vertex weights. ";

%feature("docstring")  dolfin::Graph::connectivity "

Return array of edges for all vertices. ";

%feature("docstring")  dolfin::Graph::offsets "

Return array of offsets for edges of all vertices. ";

%feature("docstring")  dolfin::Graph::type "

Return graph type. ";

%feature("docstring")  dolfin::Graph::partition "

Partition a graph into num_part partitions. ";

%feature("docstring")  dolfin::Graph::typestr "

Return graph type as a string. ";

%feature("docstring")  dolfin::Graph::disp "

Display graph data. ";

%feature("docstring")  dolfin::Graph::clear "

Clear graph data. ";


// File: classdolfin_1_1GraphEditor.xml
%feature("docstring") dolfin::GraphEditor "

A simple graph editor for creating graphs.

C++ includes: GraphEditor.h ";

%feature("docstring")  dolfin::GraphEditor::GraphEditor "

Constructor. ";

%feature("docstring")  dolfin::GraphEditor::~GraphEditor "

Destructor. ";

%feature("docstring")  dolfin::GraphEditor::open "

Open graph of given type. ";

%feature("docstring")  dolfin::GraphEditor::open "

Open graph of given type. ";

%feature("docstring")  dolfin::GraphEditor::initVertices "

Specify number of vertices. ";

%feature("docstring")  dolfin::GraphEditor::initEdges "

Specify number of edges. ";

%feature("docstring")  dolfin::GraphEditor::addVertex "

Add vertex v. ";

%feature("docstring")  dolfin::GraphEditor::addEdge "

Add edge from vertex u to vertex v. ";

%feature("docstring")  dolfin::GraphEditor::close "

Close graph, finish editing. ";


// File: classdolfin_1_1GraphPartition.xml
%feature("docstring") dolfin::GraphPartition "

This class provides a set of functions to partition a Graph.

C++ includes: GraphPartition.h ";


// File: classdolfin_1_1Homotopy.xml
%feature("docstring") dolfin::Homotopy "";

%feature("docstring")  dolfin::Homotopy::Homotopy "

Create homotopy for system of given size. ";

%feature("docstring")  dolfin::Homotopy::~Homotopy "

Destructor. ";

%feature("docstring")  dolfin::Homotopy::solve "

Solve homotopy. ";

%feature("docstring")  dolfin::Homotopy::solutions "

Return array of solutions found. ";

%feature("docstring")  dolfin::Homotopy::z0 "

Return initial value (solution of G(z) = 0), optional. ";

%feature("docstring")  dolfin::Homotopy::F "

Compute y = F(z). ";

%feature("docstring")  dolfin::Homotopy::JF "

Compute y = F'(z) x. ";

%feature("docstring")  dolfin::Homotopy::G "

Compute y = G(z), optional. ";

%feature("docstring")  dolfin::Homotopy::JG "

Compute y = G'(z) x, optional. ";

%feature("docstring")  dolfin::Homotopy::modify "

Modify or substitute found solution (optional). ";

%feature("docstring")  dolfin::Homotopy::verify "

Check if found solution is correct (optional). ";

%feature("docstring")  dolfin::Homotopy::degree "

Return degree of polynomial F_i(z). ";


// File: classdolfin_1_1IntersectionDetector.xml
%feature("docstring") dolfin::IntersectionDetector "";

%feature("docstring")
dolfin::IntersectionDetector::IntersectionDetector "

Constructor. ";

%feature("docstring")
dolfin::IntersectionDetector::~IntersectionDetector "

Destructor. ";

%feature("docstring")  dolfin::IntersectionDetector::overlap "

Compute overlap with mesh. ";

%feature("docstring")  dolfin::IntersectionDetector::overlap "

Compute overlap with point. ";

%feature("docstring")  dolfin::IntersectionDetector::overlap "

Compute overlap with bounding box. ";

%feature("docstring")  dolfin::IntersectionDetector::overlap "

Compute which cells are intersected by a polygon (defined by points).
";


// File: classdolfin_1_1InvMeshSize.xml
%feature("docstring") dolfin::InvMeshSize "

This function represents the inverse of the local mesh size on a given
mesh.

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::InvMeshSize::InvMeshSize "";

%feature("docstring")  dolfin::InvMeshSize::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";


// File: classdolfin_1_1KrylovSolver.xml
%feature("docstring") dolfin::KrylovSolver "

This class defines an interface for a Krylov solver. The underlying
Krylov solver type is defined in default_type.h.

C++ includes: KrylovSolver.h ";

%feature("docstring")  dolfin::KrylovSolver::KrylovSolver "

Create Krylov solver. ";

%feature("docstring")  dolfin::KrylovSolver::~KrylovSolver "

Destructor. ";

%feature("docstring")  dolfin::KrylovSolver::solve "

Solve linear system Ax = b. ";


// File: classdolfin_1_1Lagrange.xml
%feature("docstring") dolfin::Lagrange "

Lagrange polynomial (basis) with given degree q determined by n = q +
1 nodal points.

Example: q = 1 (n = 2)

Lagrange p(1); p.set(0, 0.0); p.set(1, 1.0);

This creates a Lagrange polynomial (actually two Lagrange
polynomials):

p(0,x) = 1 - x (one at x = 0, zero at x = 1) p(1,x) = x (zero at x =
0, one at x = 1)

C++ includes: Lagrange.h ";

%feature("docstring")  dolfin::Lagrange::Lagrange "

Constructor. ";

%feature("docstring")  dolfin::Lagrange::Lagrange "

Copy constructor. ";

%feature("docstring")  dolfin::Lagrange::~Lagrange "

Destructor. ";

%feature("docstring")  dolfin::Lagrange::set "

Specify point. ";

%feature("docstring")  dolfin::Lagrange::size "

Return number of points. ";

%feature("docstring")  dolfin::Lagrange::degree "

Return degree. ";

%feature("docstring")  dolfin::Lagrange::point "

Return point. ";

%feature("docstring")  dolfin::Lagrange::eval "

Return value of polynomial i at given point x. ";

%feature("docstring")  dolfin::Lagrange::ddx "

Return derivate of polynomial i at given point x. ";

%feature("docstring")  dolfin::Lagrange::dqdx "

Return derivative q (a constant) of polynomial. ";

%feature("docstring")  dolfin::Lagrange::disp "";


// File: classdolfin_1_1Legendre.xml
%feature("docstring") dolfin::Legendre "

Legendre polynomial of given degree n on the interval [-1,1].

P0(x) = 1 P1(x) = x P2(x) = (3x^2 - 1) / 2 ...

The function values and derivatives are computed using three-term
recurrence formulas.

C++ includes: Legendre.h ";

%feature("docstring")  dolfin::Legendre::Legendre "";

%feature("docstring")  dolfin::Legendre::ddx "

Evaluation of derivative at given point. ";

%feature("docstring")  dolfin::Legendre::d2dx "

Evaluation of second derivative at given point. ";


// File: classdolfin_1_1LinearAlgebraFactory.xml
%feature("docstring") dolfin::LinearAlgebraFactory "";

%feature("docstring")
dolfin::LinearAlgebraFactory::LinearAlgebraFactory "

Constructor. ";

%feature("docstring")
dolfin::LinearAlgebraFactory::~LinearAlgebraFactory "

Destructor. ";

%feature("docstring")  dolfin::LinearAlgebraFactory::createMatrix "

Create empty matrix. ";

%feature("docstring")  dolfin::LinearAlgebraFactory::createVector "

Create empty vector. ";

%feature("docstring")  dolfin::LinearAlgebraFactory::createPattern "

Create empty sparsity pattern. ";


// File: classdolfin_1_1LinearPDE.xml
%feature("docstring") dolfin::LinearPDE "

A LinearPDE represents a (system of) linear partial differential
equation(s) in variational form: Find u in V such that

a(v, u) = L(v) for all v in V',

where a is a bilinear form and L is a linear form.

C++ includes: LinearPDE.h ";

%feature("docstring")  dolfin::LinearPDE::LinearPDE "

Define a linear PDE with natural boundary conditions. ";

%feature("docstring")  dolfin::LinearPDE::LinearPDE "

Define a linear PDE with a single Dirichlet boundary condition. ";

%feature("docstring")  dolfin::LinearPDE::LinearPDE "

Define a linear PDE with a set of Dirichlet boundary conditions. ";

%feature("docstring")  dolfin::LinearPDE::~LinearPDE "

Destructor. ";

%feature("docstring")  dolfin::LinearPDE::solve "

Solve PDE system. ";

%feature("docstring")  dolfin::LinearPDE::solve "

Solve PDE system and extract sub functions. ";

%feature("docstring")  dolfin::LinearPDE::solve "

Solve PDE system and extract sub functions. ";


// File: classdolfin_1_1LinearSolver.xml
%feature("docstring") dolfin::LinearSolver "

This class provides a general solver for linear systems Ax = b.
Available methods are defined in SolverType.h and available
preconditioners are defined in PreconditionerType.h.

C++ includes: LinearSolver.h ";

%feature("docstring")  dolfin::LinearSolver::LinearSolver "

Create linear solver. ";

%feature("docstring")  dolfin::LinearSolver::~LinearSolver "

Destructor. ";

%feature("docstring")  dolfin::LinearSolver::solve "

Solve linear system Ax = b. ";


// File: classdolfin_1_1List.xml
%feature("docstring") dolfin::List "

List is a container that provides O(n) access time to elements and
O(n) memory overhead. However, a List can be grown/shrunk without
reallocation and spliced together with other lists, etc.

It is a wrapper for std::list (doubly-linked list), so see the STL
manual for further details:http://www.sgi.com/tech/stl/

C++ includes: List.h ";

%feature("docstring")  dolfin::List::List "

Create empty list. ";

%feature("docstring")  dolfin::List::List "

Copy constructor. ";


// File: classdolfin_1_1LobattoQuadrature.xml
%feature("docstring") dolfin::LobattoQuadrature "

Lobatto (Gauss-Lobatto) quadrature on the interval [-1,1]. The n
quadrature points are given by the end-points -1 and 1, and the zeros
of P{n-1}'(x), where P{n-1}(x) is the (n-1):th Legendre polynomial.

The quadrature points are computed using Newton's method, and the
quadrature weights are computed by solving a linear system determined
by the condition that Lobatto quadrature with n points should be exact
for polynomials of degree 2n-3.

C++ includes: LobattoQuadrature.h ";

%feature("docstring")  dolfin::LobattoQuadrature::LobattoQuadrature "";

%feature("docstring")  dolfin::LobattoQuadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1LogStream.xml
%feature("docstring") dolfin::LogStream "";

%feature("docstring")  dolfin::LogStream::LogStream "";

%feature("docstring")  dolfin::LogStream::~LogStream "";

%feature("docstring")  dolfin::LogStream::disp "";


// File: classdolfin_1_1LUSolver.xml
%feature("docstring") dolfin::LUSolver "";

%feature("docstring")  dolfin::LUSolver::LUSolver "

LU solver for the built-in LA backends. ";

%feature("docstring")  dolfin::LUSolver::~LUSolver "";

%feature("docstring")  dolfin::LUSolver::solve "";

%feature("docstring")  dolfin::LUSolver::factorize "";

%feature("docstring")  dolfin::LUSolver::factorized_solve "";


// File: classdolfin_1_1Matrix.xml
%feature("docstring") dolfin::Matrix "

This class provides the default DOLFIN matrix class, based on the
default DOLFIN linear algebra backend.

C++ includes: Matrix.h ";

%feature("docstring")  dolfin::Matrix::Matrix "

Create empty matrix. ";

%feature("docstring")  dolfin::Matrix::Matrix "

Create M x N matrix. ";

%feature("docstring")  dolfin::Matrix::Matrix "

Copy constructor. ";

%feature("docstring")  dolfin::Matrix::~Matrix "

Destructor. ";

%feature("docstring")  dolfin::Matrix::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::Matrix::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::Matrix::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::Matrix::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::Matrix::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::Matrix::disp "

Display tensor. ";

%feature("docstring")  dolfin::Matrix::init "

Initialize M x N matrix. ";

%feature("docstring")  dolfin::Matrix::get "

Get block of values. ";

%feature("docstring")  dolfin::Matrix::set "

Set block of values. ";

%feature("docstring")  dolfin::Matrix::add "

Add block of values. ";

%feature("docstring")  dolfin::Matrix::getrow "

Get non-zero values of given row. ";

%feature("docstring")  dolfin::Matrix::setrow "

Set values for given row. ";

%feature("docstring")  dolfin::Matrix::zero "

Set given rows to zero. ";

%feature("docstring")  dolfin::Matrix::ident "

Set given rows to identity matrix. ";

%feature("docstring")  dolfin::Matrix::mult "

Matrix-vector product, y = Ax. ";

%feature("docstring")  dolfin::Matrix::factory "

Return linear algebra backend factory. ";

%feature("docstring")  dolfin::Matrix::instance "

Return concrete instance / unwrap (const version). ";

%feature("docstring")  dolfin::Matrix::instance "

Return concrete instance / unwrap (non-const version). ";


// File: classdolfin_1_1MatrixFactory.xml
%feature("docstring") dolfin::MatrixFactory "

This class provides functionality for computing a set of standard
finite element matrices, such as the mass matrix and the stiffness
matrix, with piecewise linear elements. For other matrices (forms) and
elements, forms must be defined in the FFC form language and
assembled.

C++ includes: MatrixFactory.h ";


// File: classdolfin_1_1Mesh.xml
%feature("docstring") dolfin::Mesh "

A Mesh consists of a set of connected and numbered mesh entities.

Both the representation and the interface are dimension-independent,
but a concrete interface is also provided for standard named mesh
entities:

Entity Dimension Codimension

Vertex 0 - Edge 1 - Face 2 -

Facet - 1 Cell - 0

When working with mesh iterators, all entities and connectivity are
precomputed automatically the first time an iterator is created over
any given topological dimension or connectivity.

Note that for efficiency, only entities of dimension zero (vertices)
and entities of the maximal dimension (cells) exist when creating a
Mesh. Other entities must be explicitly created by calling init(). For
example, all edges in a mesh may be created by a call to mesh.init(1).
Similarly, connectivities such as all edges connected to a given
vertex must also be explicitly created (in this case by a call to
mesh.init(0, 1)).

C++ includes: Mesh.h ";

%feature("docstring")  dolfin::Mesh::Mesh "

Create empty mesh. ";

%feature("docstring")  dolfin::Mesh::Mesh "

Copy constructor. ";

%feature("docstring")  dolfin::Mesh::Mesh "

Create mesh from data file. ";

%feature("docstring")  dolfin::Mesh::~Mesh "

Destructor. ";

%feature("docstring")  dolfin::Mesh::numVertices "

Return number of vertices. ";

%feature("docstring")  dolfin::Mesh::numEdges "

Return number of edges. ";

%feature("docstring")  dolfin::Mesh::numFaces "

Return number of faces. ";

%feature("docstring")  dolfin::Mesh::numFacets "

Return number of facets. ";

%feature("docstring")  dolfin::Mesh::numCells "

Return number of cells. ";

%feature("docstring")  dolfin::Mesh::coordinates "

Return coordinates of all vertices. ";

%feature("docstring")  dolfin::Mesh::coordinates "

Return coordinates of all vertices. ";

%feature("docstring")  dolfin::Mesh::cells "

Return connectivity for all cells. ";

%feature("docstring")  dolfin::Mesh::cells "

Return connectivity for all cells. ";

%feature("docstring")  dolfin::Mesh::size "

Return number of entities of given topological dimension. ";

%feature("docstring")  dolfin::Mesh::topology "

Return mesh topology (non-const version). ";

%feature("docstring")  dolfin::Mesh::topology "

Return mesh topology (const version). ";

%feature("docstring")  dolfin::Mesh::geometry "

Return mesh geometry (non-const version). ";

%feature("docstring")  dolfin::Mesh::geometry "

Return mesh geometry (const version). ";

%feature("docstring")  dolfin::Mesh::data "

Return mesh data. ";

%feature("docstring")  dolfin::Mesh::type "

Return mesh cell type. ";

%feature("docstring")  dolfin::Mesh::type "

Return mesh cell type. ";

%feature("docstring")  dolfin::Mesh::init "

Compute entities of given topological dimension and return number of
entities. ";

%feature("docstring")  dolfin::Mesh::init "

Compute connectivity between given pair of dimensions. ";

%feature("docstring")  dolfin::Mesh::init "

Compute all entities and connectivity. ";

%feature("docstring")  dolfin::Mesh::clear "

Clear all mesh data. ";

%feature("docstring")  dolfin::Mesh::order "

Order all mesh entities (not needed if \"mesh order entities\" is
set). ";

%feature("docstring")  dolfin::Mesh::refine "

Refine mesh uniformly. ";

%feature("docstring")  dolfin::Mesh::refine "

Refine mesh according to cells marked for refinement. ";

%feature("docstring")  dolfin::Mesh::coarsen "

Coarsen mesh uniformly. ";

%feature("docstring")  dolfin::Mesh::coarsen "

Coarsen mesh according to cells marked for coarsening. ";

%feature("docstring")  dolfin::Mesh::move "

Move coordinates of mesh according to new boundary coordinates. ";

%feature("docstring")  dolfin::Mesh::smooth "

Smooth mesh using Lagrangian mesh smoothing. ";

%feature("docstring")  dolfin::Mesh::partition "

Partition mesh into num_processes partitions. ";

%feature("docstring")  dolfin::Mesh::partition "

Partition mesh into num_partitions partitions. ";

%feature("docstring")  dolfin::Mesh::disp "

Display mesh data. ";

%feature("docstring")  dolfin::Mesh::str "

Return a short desriptive string. ";


// File: classdolfin_1_1MeshConnectivity.xml
%feature("docstring") dolfin::MeshConnectivity "

Mesh connectivity stores a sparse data structure of connections
(incidence relations) between mesh entities for a fixed pair of
topological dimensions.

The connectivity can be specified either by first giving the number of
entities and the number of connections for each entity, which may
either be equal for all entities or different, or by giving the entire
(sparse) connectivity pattern.

C++ includes: MeshConnectivity.h ";

%feature("docstring")  dolfin::MeshConnectivity::MeshConnectivity "

Create empty connectivity. ";

%feature("docstring")  dolfin::MeshConnectivity::MeshConnectivity "

Copy constructor. ";

%feature("docstring")  dolfin::MeshConnectivity::~MeshConnectivity "

Destructor. ";

%feature("docstring")  dolfin::MeshConnectivity::size "

Return total number of connections. ";

%feature("docstring")  dolfin::MeshConnectivity::size "

Return number of connections for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshConnectivity::init "

Initialize number of entities and number of connections (equal for
all). ";

%feature("docstring")  dolfin::MeshConnectivity::init "

Initialize number of entities and number of connections
(individually). ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set given connection for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set all connections for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set all connections for given entity. ";

%feature("docstring")  dolfin::MeshConnectivity::set "

Set all connections for all entities. ";

%feature("docstring")  dolfin::MeshConnectivity::disp "

Display data. ";


// File: classdolfin_1_1MeshData.xml
%feature("docstring") dolfin::MeshData "

The class MeshData is a container for auxiliary mesh data, represented
either as MeshFunctions over topological mesh entities or Arrays. Each
dataset is identified by a unique user-specified string.

Currently, only uint-valued data is supported.

C++ includes: MeshData.h ";

%feature("docstring")  dolfin::MeshData::MeshData "

Constructor. ";

%feature("docstring")  dolfin::MeshData::~MeshData "

Destructor. ";

%feature("docstring")  dolfin::MeshData::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshData::createMeshFunction "

Create MeshFunction with given name on entities of given dimension. ";

%feature("docstring")  dolfin::MeshData::createArray "

Create Array with given name and size. ";

%feature("docstring")  dolfin::MeshData::meshfunction "

Return MeshFunction with given name (returning zero if data is not
available). ";

%feature("docstring")  dolfin::MeshData::array "

Return Array with given name (returning zero if data is not
available). ";

%feature("docstring")  dolfin::MeshData::disp "

Display data. ";


// File: classdolfin_1_1MeshEditor.xml
%feature("docstring") dolfin::MeshEditor "

A simple mesh editor for creating simplicial meshes in 1D, 2D and 3D.

C++ includes: MeshEditor.h ";

%feature("docstring")  dolfin::MeshEditor::MeshEditor "

Constructor. ";

%feature("docstring")  dolfin::MeshEditor::~MeshEditor "

Destructor. ";

%feature("docstring")  dolfin::MeshEditor::open "

Open mesh of given cell type, topological and geometrical dimension.
";

%feature("docstring")  dolfin::MeshEditor::open "

Open mesh of given cell type, topological and geometrical dimension.
";

%feature("docstring")  dolfin::MeshEditor::initVertices "

Specify number of vertices. ";

%feature("docstring")  dolfin::MeshEditor::initCells "

Specify number of cells. ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given point p. ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given coordinate x. ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given coordinate (x, y). ";

%feature("docstring")  dolfin::MeshEditor::addVertex "

Add vertex v at given coordinate (x, y, z). ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell (interval) with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell (triangle) with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::addCell "

Add cell (tetrahedron) with given vertices. ";

%feature("docstring")  dolfin::MeshEditor::close "

Close mesh, finish editing. ";


// File: classdolfin_1_1MeshEntity.xml
%feature("docstring") dolfin::MeshEntity "

A MeshEntity represents a mesh entity associated with a specific
topological dimension of some mesh.

C++ includes: MeshEntity.h ";

%feature("docstring")  dolfin::MeshEntity::MeshEntity "

Constructor. ";

%feature("docstring")  dolfin::MeshEntity::~MeshEntity "

Destructor. ";

%feature("docstring")  dolfin::MeshEntity::mesh "

Return mesh associated with mesh entity. ";

%feature("docstring")  dolfin::MeshEntity::mesh "

Return mesh associated with mesh entity. ";

%feature("docstring")  dolfin::MeshEntity::dim "

Return topological dimension. ";

%feature("docstring")  dolfin::MeshEntity::index "

Return index of mesh entity. ";

%feature("docstring")  dolfin::MeshEntity::numEntities "

Return number of incident mesh entities of given topological
dimension. ";

%feature("docstring")  dolfin::MeshEntity::entities "

Return array of indices for incident mesh entitites of given
topological dimension. ";

%feature("docstring")  dolfin::MeshEntity::entities "

Return array of indices for incident mesh entitites of given
topological dimension. ";

%feature("docstring")  dolfin::MeshEntity::incident "

Check if given entity is indicent. ";

%feature("docstring")  dolfin::MeshEntity::index "

Compute local index of given incident entity (error if not found). ";


// File: classdolfin_1_1MeshEntityIterator.xml
%feature("docstring") dolfin::MeshEntityIterator "

MeshEntityIterator provides a common iterator for mesh entities over
meshes, boundaries and incidence relations. The basic use is
illustrated below.

The following example shows how to iterate over all mesh entities of a
mesh of topological dimension dim:

for ( MeshEntityIterator e(mesh, dim); !e. end(); ++e) { e->foo(); }

The following example shows how to iterate over mesh entities of
topological dimension dim connected (incident) to some mesh entity f:

for ( MeshEntityIterator e(f, dim); !e. end(); ++e) { e->foo(); }

In addition to the general iterator, a set of specific named iterators
are provided for entities of type Vertex, Edge, Face, Facet and Cell.
These iterators are defined along with their respective classes.

C++ includes: MeshEntityIterator.h ";

%feature("docstring")  dolfin::MeshEntityIterator::MeshEntityIterator
"

Create iterator for mesh entities over given topological dimension. ";

%feature("docstring")  dolfin::MeshEntityIterator::MeshEntityIterator
"

Create iterator for entities of given dimension connected to given
entity. ";

%feature("docstring")  dolfin::MeshEntityIterator::~MeshEntityIterator
"

Destructor. ";

%feature("docstring")  dolfin::MeshEntityIterator::pos "

Return current position. ";

%feature("docstring")  dolfin::MeshEntityIterator::end "

Check if iterator has reached the end. ";


// File: classdolfin_1_1MeshFunction.xml
%feature("docstring") dolfin::MeshFunction "

A MeshFunction is a function that can be evaluated at a set of mesh
entities. A MeshFunction is discrete and is only defined at the set of
mesh entities of a fixed topological dimension. A MeshFunction may for
example be used to store a global numbering scheme for the entities of
a (parallel) mesh, marking sub domains or boolean markers for mesh
refinement.

C++ includes: MeshFunction.h ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create empty mesh function. ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create empty mesh function on given mesh. ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create mesh function on given mesh of given dimension. ";

%feature("docstring")  dolfin::MeshFunction::MeshFunction "

Create function from data file. ";

%feature("docstring")  dolfin::MeshFunction::~MeshFunction "

Destructor. ";

%feature("docstring")  dolfin::MeshFunction::mesh "

Return mesh associated with mesh function. ";

%feature("docstring")  dolfin::MeshFunction::dim "

Return topological dimension. ";

%feature("docstring")  dolfin::MeshFunction::size "

Return size (number of entities). ";

%feature("docstring")  dolfin::MeshFunction::values "

Return array of values. ";

%feature("docstring")  dolfin::MeshFunction::values "

Return array of values. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension of given
size. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension. ";

%feature("docstring")  dolfin::MeshFunction::init "

Initialize mesh function for given topological dimension of given
size. ";

%feature("docstring")  dolfin::MeshFunction::get "

Get value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::get "

Get value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::set "

Set value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::set "

Set value at given entity. ";

%feature("docstring")  dolfin::MeshFunction::disp "

Display mesh function data. ";


// File: classdolfin_1_1MeshGeometry.xml
%feature("docstring") dolfin::MeshGeometry "

MeshGeometry stores the geometry imposed on a mesh. Currently, the
geometry is represented by the set of coordinates for the vertices of
a mesh, but other representations are possible.

C++ includes: MeshGeometry.h ";

%feature("docstring")  dolfin::MeshGeometry::MeshGeometry "

Create empty set of coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::MeshGeometry "

Copy constructor. ";

%feature("docstring")  dolfin::MeshGeometry::~MeshGeometry "

Destructor. ";

%feature("docstring")  dolfin::MeshGeometry::dim "

Return Euclidean dimension of coordinate system. ";

%feature("docstring")  dolfin::MeshGeometry::size "

Return number of coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return value of coordinate n in direction i. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return value of coordinate n in direction i. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for coordinate n. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for coordinate n. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for all coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::x "

Return array of values for all coordinates. ";

%feature("docstring")  dolfin::MeshGeometry::point "

Return coordinate n as a 3D point value. ";

%feature("docstring")  dolfin::MeshGeometry::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshGeometry::init "

Initialize coordinate list to given dimension and size. ";

%feature("docstring")  dolfin::MeshGeometry::set "

Set value of coordinate n in direction i. ";

%feature("docstring")  dolfin::MeshGeometry::disp "

Display data. ";


// File: classdolfin_1_1MeshSize.xml
%feature("docstring") dolfin::MeshSize "

This function represents the local mesh size on a given mesh.

C++ includes: SpecialFunctions.h ";

%feature("docstring")  dolfin::MeshSize::MeshSize "";

%feature("docstring")  dolfin::MeshSize::eval "

Evaluate scalar function at given point (overload for scalar user-
defined function). ";

%feature("docstring")  dolfin::MeshSize::min "

Compute minimal cell diameter. ";


// File: classdolfin_1_1MeshTopology.xml
%feature("docstring") dolfin::MeshTopology "

MeshTopology stores the topology of a mesh, consisting of mesh
entities and connectivity (incidence relations for the mesh entities).
Note that the mesh entities don't need to be stored, only the number
of entities and the connectivity. Any numbering scheme for the mesh
entities is stored separately in a MeshFunction over the entities.

A mesh entity e may be identified globally as a pair e = (dim, i),
where dim is the topological dimension and i is the index of the
entity within that topological dimension.

C++ includes: MeshTopology.h ";

%feature("docstring")  dolfin::MeshTopology::MeshTopology "

Create empty mesh topology. ";

%feature("docstring")  dolfin::MeshTopology::MeshTopology "

Copy constructor. ";

%feature("docstring")  dolfin::MeshTopology::~MeshTopology "

Destructor. ";

%feature("docstring")  dolfin::MeshTopology::dim "

Return topological dimension. ";

%feature("docstring")  dolfin::MeshTopology::size "

Return number of entities for given dimension. ";

%feature("docstring")  dolfin::MeshTopology::clear "

Clear all data. ";

%feature("docstring")  dolfin::MeshTopology::init "

Initialize topology of given maximum dimension. ";

%feature("docstring")  dolfin::MeshTopology::init "

Set number of entities (size) for given topological dimension. ";

%feature("docstring")  dolfin::MeshTopology::disp "

Display data. ";


// File: classdolfin_1_1Method.xml
%feature("docstring") dolfin::Method "

Base class for cGqMethod and dGqMethod, which contain all numeric
constants, such as nodal points and nodal weights, needed for the
method.

C++ includes: Method.h ";

%feature("docstring")  dolfin::Method::Method "

Constructor. ";

%feature("docstring")  dolfin::Method::~Method "

Destructor. ";

%feature("docstring")  dolfin::Method::type "

Return type (inline optimized). ";

%feature("docstring")  dolfin::Method::degree "

Return degree (inline optimized). ";

%feature("docstring")  dolfin::Method::order "

Return order (inline optimized). ";

%feature("docstring")  dolfin::Method::nsize "

Return number of nodal points (inline optimized). ";

%feature("docstring")  dolfin::Method::qsize "

Return number of quadrature points (inline optimized). ";

%feature("docstring")  dolfin::Method::npoint "

Return nodal point (inline optimized). ";

%feature("docstring")  dolfin::Method::qpoint "

Return quadrature point (inline optimized). ";

%feature("docstring")  dolfin::Method::nweight "

Return nodal weight j for node i, including quadrature (inline
optimized). ";

%feature("docstring")  dolfin::Method::qweight "

Return quadrature weight, including only quadrature (inline
optimized). ";

%feature("docstring")  dolfin::Method::eval "

Evaluation of trial space basis function i at given tau (inline
optimized). ";

%feature("docstring")  dolfin::Method::derivative "

Evaluation of derivative of basis function i at t = 1 (inline
optimized). ";

%feature("docstring")  dolfin::Method::update "

Update solution values using fixed-point iteration. ";

%feature("docstring")  dolfin::Method::update "

Update solution values using fixed-point iteration (damped version).
";

%feature("docstring")  dolfin::Method::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::Method::ueval "

Evaluate solution at given point. ";

%feature("docstring")  dolfin::Method::ueval "

Evaluate solution at given node. ";

%feature("docstring")  dolfin::Method::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::Method::residual "

Compute residual at right end-point. ";

%feature("docstring")  dolfin::Method::timestep "

Compute new time step based on the given residual. ";

%feature("docstring")  dolfin::Method::error "

Compute error estimate (modulo stability factor). ";

%feature("docstring")  dolfin::Method::disp "

Display method data. ";


// File: classdolfin_1_1MPIMeshCommunicator.xml
%feature("docstring") dolfin::MPIMeshCommunicator "

The class facilitates the transfer of a mesh between processes using
MPI.

C++ includes: MPIMeshCommunicator.h ";

%feature("docstring")
dolfin::MPIMeshCommunicator::MPIMeshCommunicator "

Constructor. ";

%feature("docstring")
dolfin::MPIMeshCommunicator::~MPIMeshCommunicator "

Destructor. ";


// File: classdolfin_1_1NewtonSolver.xml
%feature("docstring") dolfin::NewtonSolver "

This class defines a Newton solver for equations of the form F(u) = 0.

C++ includes: NewtonSolver.h ";

%feature("docstring")  dolfin::NewtonSolver::NewtonSolver "

Initialise nonlinear solver and choose LU solver. ";

%feature("docstring")  dolfin::NewtonSolver::NewtonSolver "

Initialise nonlinear solver and choose Krylov solver and
preconditioner. ";

%feature("docstring")  dolfin::NewtonSolver::~NewtonSolver "

Destructor. ";

%feature("docstring")  dolfin::NewtonSolver::solve "

Solve abstract nonlinear problem F(x) = 0 for given vector F and
Jacobian dF/dx ";

%feature("docstring")  dolfin::NewtonSolver::getIteration "

Return Newton iteration number. ";


// File: classdolfin_1_1NonlinearPDE.xml
%feature("docstring") dolfin::NonlinearPDE "

This class provides automated solution of nonlinear PDEs.

C++ includes: NonlinearPDE.h ";

%feature("docstring")  dolfin::NonlinearPDE::NonlinearPDE "

Constructor. ";

%feature("docstring")  dolfin::NonlinearPDE::NonlinearPDE "

Constructor. ";

%feature("docstring")  dolfin::NonlinearPDE::~NonlinearPDE "

Destructor. ";

%feature("docstring")  dolfin::NonlinearPDE::update "

Function called before Jacobian matrix and RHS vector are formed.
Users can supply this function to perform updates. ";

%feature("docstring")  dolfin::NonlinearPDE::form "

User-defined function to compute F(u) its Jacobian. ";

%feature("docstring")  dolfin::NonlinearPDE::solve "

Solve PDE. ";


// File: classdolfin_1_1NonlinearProblem.xml
%feature("docstring") dolfin::NonlinearProblem "

This is a base class for nonlinear problems which can return the
nonlinear function F(u) and its Jacobian J = dF(u)/du.

C++ includes: NonlinearProblem.h ";

%feature("docstring")  dolfin::NonlinearProblem::NonlinearProblem "

Create nonlinear problem. ";

%feature("docstring")  dolfin::NonlinearProblem::~NonlinearProblem "

Destructor. ";

%feature("docstring")  dolfin::NonlinearProblem::form "

User-defined function to compute F(u) its Jacobian. ";

%feature("docstring")  dolfin::NonlinearProblem::F "

User-defined function to compute F(u). ";

%feature("docstring")  dolfin::NonlinearProblem::J "

User-defined function to compute Jacobian matrix. ";


// File: classdolfin_1_1NonMatchingFunction.xml
%feature("docstring") dolfin::NonMatchingFunction "

Represent discrete function fA as pointwise user-defined function.

C++ includes: ProjectL2.h ";

%feature("docstring")
dolfin::NonMatchingFunction::NonMatchingFunction "";

%feature("docstring")  dolfin::NonMatchingFunction::eval "

Evaluate function at given point (overload for scalar user-defined
function). ";


// File: classdolfin_1_1ODE.xml
%feature("docstring") dolfin::ODE "

A ODE represents an initial value problem of the form

u'(t) = f(u(t),t) on (0,T],

u(0) = u0,

where u(t) is a vector of length N.

To define an ODE, a user must create a subclass of ODE and create the
function u0() defining the initial condition, as well the function f()
defining the right-hand side.

DOLFIN provides two types of ODE solvers: a set of standard mono-
adaptive solvers with equal adaptive time steps for all components as
well as a set of multi-adaptive solvers with individual and adaptive
time steps for the different components. The right-hand side f() is
defined differently for the two sets of methods, with the multi-
adaptive solvers requiring a component-wise evaluation of the right-
hand side. Only one right-hand side function f() needs to be defined
for use of any particular solver.

It is also possible to solve implicit systems of the form

M(u(t), t) u'(t) = f(u(t),t) on (0,T],

u(0) = u0,

by setting the option \"implicit\" to true and defining the function
M().

C++ includes: ODE.h ";

%feature("docstring")  dolfin::ODE::ODE "

Create an ODE of size N with final time T. ";

%feature("docstring")  dolfin::ODE::~ODE "

Destructor. ";

%feature("docstring")  dolfin::ODE::u0 "

Set initial values. ";

%feature("docstring")  dolfin::ODE::f "

Evaluate right-hand side y = f(u, t), mono-adaptive version (default,
optional). ";

%feature("docstring")  dolfin::ODE::f "

Evaluate right-hand side f_i(u, t), multi-adaptive version (optional).
";

%feature("docstring")  dolfin::ODE::M "

Compute product y = Mx for implicit system (optional). ";

%feature("docstring")  dolfin::ODE::J "

Compute product y = Jx for Jacobian J (optional). ";

%feature("docstring")  dolfin::ODE::JT "

Compute product y = tranpose(J)x for Jacobian J (optional) Used when
computing error estimate only ";

%feature("docstring")  dolfin::ODE::dfdu "

Compute entry of Jacobian (optional). ";

%feature("docstring")  dolfin::ODE::timestep "

Time step to use for the whole system at a given time t (optional). ";

%feature("docstring")  dolfin::ODE::timestep "

Time step to use for a given component at a given time t (optional).
";

%feature("docstring")  dolfin::ODE::update "

Update ODE, return false to stop (optional). ";

%feature("docstring")  dolfin::ODE::save "

Save sample (optional). ";

%feature("docstring")  dolfin::ODE::sparse "

Automatically detect sparsity (optional). ";

%feature("docstring")  dolfin::ODE::sparse "

Compute sparsity from given matrix (optional). ";

%feature("docstring")  dolfin::ODE::size "

Return number of components N. ";

%feature("docstring")  dolfin::ODE::endtime "

Return end time (final time T). ";

%feature("docstring")  dolfin::ODE::solve "

Solve ODE. ";


// File: classdolfin_1_1Parameter.xml
%feature("docstring") dolfin::Parameter "

This class represents a parameter of some given type. Supported value
types are real, int, bool, and string.

C++ includes: Parameter.h ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create int-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create int-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create real-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create bool-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create string-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Create string-valued parameter. ";

%feature("docstring")  dolfin::Parameter::Parameter "

Copy constructor. ";

%feature("docstring")  dolfin::Parameter::~Parameter "

Destructor. ";

%feature("docstring")  dolfin::Parameter::type "

Return type of parameter. ";


// File: classdolfin_1_1Parametrized.xml
%feature("docstring") dolfin::Parametrized "

This is a base class for parametrized classes. Each object of a
parametrized class holds a local database of parameters that override
the global database of parameters.

Hierarchies of parametrized objects may be created with the property
that each object inherits the parameters of its parent and all
parameters inherited by the parent. A parameter takes the value of the
first value specified in the hierarchy, starting at the current object
and following the parents back to the global database.

Thus, a parameter that has not been specified, using the set()
function, in any given object, takes the value specified for the
parent, whereas any parameter value that has been specified locally
overrides the value specified for the parent.

C++ includes: Parametrized.h ";

%feature("docstring")  dolfin::Parametrized::Parametrized "

Constructor. ";

%feature("docstring")  dolfin::Parametrized::~Parametrized "

Destructor. ";

%feature("docstring")  dolfin::Parametrized::add "

Add local parameter. ";

%feature("docstring")  dolfin::Parametrized::set "

Set value of local parameter. ";

%feature("docstring")  dolfin::Parametrized::set "

Set parent from which to inherit parameters (key must be \"parent\").
";

%feature("docstring")  dolfin::Parametrized::get "

Get value of parameter with given key (local or nonlocal). ";

%feature("docstring")  dolfin::Parametrized::has "

Check if parameter with given key has been defined locally. ";

%feature("docstring")  dolfin::Parametrized::readParameters "

Callback for changes in parameter values. ";


// File: classdolfin_1_1pAssembler.xml
%feature("docstring") dolfin::pAssembler "

This class provides automated assembly of linear systems, or more
generally, assembly of a sparse tensor from a given variational form.

C++ includes: pAssembler.h ";

%feature("docstring")  dolfin::pAssembler::pAssembler "

Constructor. ";

%feature("docstring")  dolfin::pAssembler::pAssembler "

Constructor. ";

%feature("docstring")  dolfin::pAssembler::~pAssembler "

Destructor. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given variational form. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given variational form over a sub domain. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given variational form over sub domains. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble scalar from given variational form. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble scalar from given variational form over a sub domain. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble scalar from given variational form over sub domains. ";

%feature("docstring")  dolfin::pAssembler::assemble "

Assemble tensor from given (UFC) form, coefficients and sub domains.
This is the main assembly function in DOLFIN. All other assembly
functions end up calling this function.

The MeshFunction arguments can be used to specify assembly over
subdomains of the mesh cells, exterior facets and interior facets.
Either a null pointer or an empty MeshFunction may be used to specify
that the tensor should be assembled over the entire set of cells or
facets. ";


// File: classdolfin_1_1PeriodicBC.xml
%feature("docstring") dolfin::PeriodicBC "

This class specifies the interface for setting periodic boundary
conditions for partial differential equations,

u(x) = u(F^{-1}(x)) on G, u(x) = u(F(x)) on H,

where F : H --> G is a map from a subdomain H to a subdomain G.

A PeriodicBC is specified by a Mesh and a SubDomain. The given
subdomain must overload both the inside() function, which specifies
the points of G, and the map() function, which specifies the map from
the points of H to the points of G.

For mixed systems (vector-valued and mixed elements), an optional set
of parameters may be used to specify for which sub system the boundary
condition should be specified.

C++ includes: PeriodicBC.h ";

%feature("docstring")  dolfin::PeriodicBC::PeriodicBC "

Create periodic boundary condition for sub domain. ";

%feature("docstring")  dolfin::PeriodicBC::PeriodicBC "

Create sub system boundary condition for sub domain. ";

%feature("docstring")  dolfin::PeriodicBC::~PeriodicBC "

Destructor. ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system. ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system for a nonlinear problem (not
implemented). ";

%feature("docstring")  dolfin::PeriodicBC::apply "

Apply boundary condition to linear system for a nonlinear problem (not
implemented). ";


// File: classdolfin_1_1PETScObject.xml
%feature("docstring") dolfin::PETScObject "

This class calls SubSystemsManger to initialise PETSc.

All PETSc objects must be derived from this class.

C++ includes: PETScObject.h ";

%feature("docstring")  dolfin::PETScObject::PETScObject "";


// File: classdolfin_1_1Point.xml
%feature("docstring") dolfin::Point "

A Point represents a point in R^3 with coordinates x, y, z, or,
alternatively, a vector in R^3, supporting standard operations like
the norm, distances, scalar and vector products etc.

C++ includes: Point.h ";

%feature("docstring")  dolfin::Point::Point "

Create a point at (x, y, z). ";

%feature("docstring")  dolfin::Point::Point "

Copy constructor. ";

%feature("docstring")  dolfin::Point::~Point "

Destructor. ";

%feature("docstring")  dolfin::Point::x "

Return x-coordinate. ";

%feature("docstring")  dolfin::Point::y "

Return y-coordinate. ";

%feature("docstring")  dolfin::Point::z "

Return z-coordinate. ";

%feature("docstring")  dolfin::Point::distance "

Compute distance to given point. ";

%feature("docstring")  dolfin::Point::norm "

Compute norm of point representing a vector from the origin. ";

%feature("docstring")  dolfin::Point::cross "

Compute cross product with given vector. ";

%feature("docstring")  dolfin::Point::dot "

Compute dot product with given vector. ";


// File: classdolfin_1_1Progress.xml
%feature("docstring") dolfin::Progress "

This class provides a simple way to create and update progress bars
during a computation. A progress bar may be used either in an
iteration with a known number of steps:

Progress p(\"Iterating...\", n); for (int i = 0; i < n; i++) { ...
p++; }

or in an iteration with an unknown number of steps:

Progress p(\"Iterating...\"); while (t < T) { ... p = t / T; }

C++ includes: Progress.h ";

%feature("docstring")  dolfin::Progress::Progress "

Create progress bar with a known number of steps. ";

%feature("docstring")  dolfin::Progress::Progress "

Create progress bar with an unknown number of steps. ";

%feature("docstring")  dolfin::Progress::~Progress "

Destructor. ";


// File: classdolfin_1_1ProjectionLibrary.xml
%feature("docstring") dolfin::ProjectionLibrary "

Library of pregenerated L2 projections.

C++ includes: ProjectionLibrary.h ";


// File: classdolfin_1_1Quadrature.xml
%feature("docstring") dolfin::Quadrature "";

%feature("docstring")  dolfin::Quadrature::Quadrature "

Constructor. ";

%feature("docstring")  dolfin::Quadrature::~Quadrature "

Destructor. ";

%feature("docstring")  dolfin::Quadrature::size "

Return number of quadrature points. ";

%feature("docstring")  dolfin::Quadrature::point "

Return quadrature point. ";

%feature("docstring")  dolfin::Quadrature::weight "

Return quadrature weight. ";

%feature("docstring")  dolfin::Quadrature::measure "

Return sum of weights (length, area, volume). ";

%feature("docstring")  dolfin::Quadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1RadauQuadrature.xml
%feature("docstring") dolfin::RadauQuadrature "

Radau (Gauss-Radau) quadrature on the interval [-1,1]. The n
quadrature points are given by the zeros of

( Pn-1(x) + Pn(x) ) / (1+x)

where Pn is the n:th Legendre polynomial.

The quadrature points are computed using Newton's method, and the
quadrature weights are computed by solving a linear system determined
by the condition that Radau quadrature with n points should be exact
for polynomials of degree 2n-2.

C++ includes: RadauQuadrature.h ";

%feature("docstring")  dolfin::RadauQuadrature::RadauQuadrature "";

%feature("docstring")  dolfin::RadauQuadrature::disp "

Display quadrature data. ";


// File: classdolfin_1_1Scalar.xml
%feature("docstring") dolfin::Scalar "

This class represents a real-valued scalar quantity and implements the
GenericTensor interface for scalars.

C++ includes: Scalar.h ";

%feature("docstring")  dolfin::Scalar::Scalar "

Create zero scalar. ";

%feature("docstring")  dolfin::Scalar::~Scalar "

Destructor. ";

%feature("docstring")  dolfin::Scalar::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::Scalar::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::Scalar::rank "

Return tensor rank (number of dimensions). ";

%feature("docstring")  dolfin::Scalar::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::Scalar::get "

Get block of values. ";

%feature("docstring")  dolfin::Scalar::set "

Set block of values. ";

%feature("docstring")  dolfin::Scalar::add "

Add block of values. ";

%feature("docstring")  dolfin::Scalar::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::Scalar::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::Scalar::disp "

Display tensor. ";

%feature("docstring")  dolfin::Scalar::factory "

Return a factory for the default linear algebra backend. ";

%feature("docstring")  dolfin::Scalar::getval "

Get value. ";


// File: classdolfin_1_1simple__array.xml
%feature("docstring") dolfin::simple_array "

The array class is a minimal wrapper for an array that knows its own
size. It is not yet another array class; it is only intended to be
used to pass data through the SWIG generated interface. Note that
users of this class are always responsible for allocating and
deallocating data.

C++ includes: simple_array.h ";

%feature("docstring")  dolfin::simple_array::simple_array "

Constructor. ";

%feature("docstring")  dolfin::simple_array::simple_array "

Destructor. ";


// File: classdolfin_1_1SingularSolver.xml
%feature("docstring") dolfin::SingularSolver "

This class provides a linear solver for singular linear systems Ax = b
where A has a one-dimensional null-space (kernel). This may happen for
example when solving Poisson's equation with pure Neumann boundary
conditions.

The solver attempts to create an extended non-singular system by
adding the constraint [1, 1, 1, ...]^T x = 0.

If an optional mass matrix M is supplied, the solver attempts to
create an extended non-singular system by adding the constraint m^T x
= 0 where m is the lumped mass matrix. This corresponds to setting the
average (integral) of the finite element function with coefficients x
to zero.

The solver makes not attempt to check that the null-space is indeed
one-dimensional. It is also assumed that the system Ax = b retains its
sparsity pattern between calls to solve().

C++ includes: SingularSolver.h ";

%feature("docstring")  dolfin::SingularSolver::SingularSolver "

Create linear solver. ";

%feature("docstring")  dolfin::SingularSolver::~SingularSolver "

Destructor. ";

%feature("docstring")  dolfin::SingularSolver::solve "

Solve linear system Ax = b. ";

%feature("docstring")  dolfin::SingularSolver::solve "

Solve linear system Ax = b using mass matrix M for setting constraint.
";


// File: classdolfin_1_1SparsityPattern.xml
%feature("docstring") dolfin::SparsityPattern "

This class represents the sparsity pattern of a vector/matrix. It can
be used to initalise vectors and sparse matrices. It must be
initialised before use.

C++ includes: SparsityPattern.h ";

%feature("docstring")  dolfin::SparsityPattern::SparsityPattern "

Create empty sparsity pattern. ";

%feature("docstring")  dolfin::SparsityPattern::SparsityPattern "

Create sparsity pattern for matrix of given dimensions. ";

%feature("docstring")  dolfin::SparsityPattern::SparsityPattern "

Create sparsity pattern for vector of given dimension. ";

%feature("docstring")  dolfin::SparsityPattern::~SparsityPattern "

Destructor. ";

%feature("docstring")  dolfin::SparsityPattern::init "

Initialise sparsity pattern for a matrix with total number of rows and
columns. ";

%feature("docstring")  dolfin::SparsityPattern::pinit "

Initialise sparsity pattern for a parallel matrix with total number of
rows and columns. ";

%feature("docstring")  dolfin::SparsityPattern::insert "

Insert non-zero entries. ";

%feature("docstring")  dolfin::SparsityPattern::insert "

Insert non-zero entries. ";

%feature("docstring")  dolfin::SparsityPattern::pinsert "

Insert non-zero entry for parallel matrices. ";

%feature("docstring")  dolfin::SparsityPattern::size "

Return global size. ";

%feature("docstring")  dolfin::SparsityPattern::numNonZeroPerRow "

Return array with number of non-zeroes per row. ";

%feature("docstring")  dolfin::SparsityPattern::numNonZeroPerRow "

Return array with number of non-zeroes per row diagonal and
offdiagonal for process_number. ";

%feature("docstring")  dolfin::SparsityPattern::numNonZero "

Return total number of non-zeroes. ";

%feature("docstring")  dolfin::SparsityPattern::pattern "

Return underlying sparsity pattern. ";

%feature("docstring")  dolfin::SparsityPattern::disp "

Display sparsity pattern. ";

%feature("docstring")  dolfin::SparsityPattern::apply "

Finalize sparsity pattern (needed by most parallel la backends). ";

%feature("docstring")  dolfin::SparsityPattern::processRange "

Return array with row range for process_number. ";

%feature("docstring")  dolfin::SparsityPattern::numLocalRows "

Return number of local rows for process_number. ";


// File: classstd_1_1vector.xml
%feature("docstring") std::vector "";


// File: classdolfin_1_1SubDomain.xml
%feature("docstring") dolfin::SubDomain "

This class defines the interface for definition of sub domains.
Alternatively, sub domains may be defined by a Mesh and a
MeshFunction<uint> over the mesh.

C++ includes: SubDomain.h ";

%feature("docstring")  dolfin::SubDomain::SubDomain "

Constructor. ";

%feature("docstring")  dolfin::SubDomain::~SubDomain "

Destructor. ";

%feature("docstring")  dolfin::SubDomain::inside "

Return true for points inside the sub domain (used for subclassing
through SWIG interface). ";

%feature("docstring")  dolfin::SubDomain::inside "

Return true for points inside the sub domain. ";

%feature("docstring")  dolfin::SubDomain::map "

Map coordinate x in domain H to coordinate y in domain G (used for
subclassing through SWIG interface). ";

%feature("docstring")  dolfin::SubDomain::map "

Map coordinate x in domain H to coordinate y in domain G (used for
periodic boundary conditions). ";

%feature("docstring")  dolfin::SubDomain::mark "

Set sub domain markers for given sub domain. ";


// File: classdolfin_1_1SubSystem.xml
%feature("docstring") dolfin::SubSystem "

This class represents a sub system that may be specified as a
recursively nested sub system of some given system.

The sub system is specified by an array of indices. For example, the
array [3, 0, 2] specifies sub system 2 of sub system 0 of sub system
3.

C++ includes: SubSystem.h ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create empty sub system (no sub systems). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create given sub system (one level). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create given sub sub system (two levels). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Create sub system for given array (n levels). ";

%feature("docstring")  dolfin::SubSystem::SubSystem "

Copy constructor. ";

%feature("docstring")  dolfin::SubSystem::depth "

Return number of levels for nested sub system. ";

%feature("docstring")  dolfin::SubSystem::extractFiniteElement "

Extract sub finite element of given finite element. ";

%feature("docstring")  dolfin::SubSystem::array "

Return array which defines sub system. ";


// File: classdolfin_1_1TimeDependent.xml
%feature("docstring") dolfin::TimeDependent "

Associates an object with time t.

C++ includes: TimeDependent.h ";

%feature("docstring")  dolfin::TimeDependent::TimeDependent "

Constructors. ";

%feature("docstring")  dolfin::TimeDependent::TimeDependent "";

%feature("docstring")  dolfin::TimeDependent::~TimeDependent "

Destructor. ";

%feature("docstring")  dolfin::TimeDependent::sync "

Associate object with time t. ";

%feature("docstring")  dolfin::TimeDependent::time "

Return the current time t. ";


// File: classdolfin_1_1uBlasFactory.xml
%feature("docstring") dolfin::uBlasFactory "";

%feature("docstring")  dolfin::uBlasFactory::~uBlasFactory "

Destructor. ";

%feature("docstring")  dolfin::uBlasFactory::createMatrix "

Create empty matrix. ";

%feature("docstring")  dolfin::uBlasFactory::createPattern "

Create empty sparsity pattern. ";

%feature("docstring")  dolfin::uBlasFactory::createVector "

Create empty vector. ";


// File: classdolfin_1_1uBlasILUPreconditioner.xml
%feature("docstring") dolfin::uBlasILUPreconditioner "

This class implements an incomplete LU factorization (ILU)
preconditioner for the uBlas Krylov solver.

C++ includes: uBlasILUPreconditioner.h ";

%feature("docstring")
dolfin::uBlasILUPreconditioner::uBlasILUPreconditioner "

Constructor. ";

%feature("docstring")
dolfin::uBlasILUPreconditioner::uBlasILUPreconditioner "

Constructor. ";

%feature("docstring")
dolfin::uBlasILUPreconditioner::~uBlasILUPreconditioner "

Destructor. ";

%feature("docstring")  dolfin::uBlasILUPreconditioner::solve "

Solve linear system Ax = b approximately. ";


// File: classdolfin_1_1uBlasKrylovSolver.xml
%feature("docstring") dolfin::uBlasKrylovSolver "

This class implements Krylov methods for linear systems of the form Ax
= b using uBlas data types.

C++ includes: uBlasKrylovSolver.h ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular method and preconditioner. ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular preconditioner (set by name). ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular uBlasPreconditioner. ";

%feature("docstring")  dolfin::uBlasKrylovSolver::uBlasKrylovSolver "

Create Krylov solver for a particular method and uBlasPreconditioner.
";

%feature("docstring")  dolfin::uBlasKrylovSolver::~uBlasKrylovSolver "

Destructor. ";

%feature("docstring")  dolfin::uBlasKrylovSolver::solve "

Solve linear system Ax = b and return number of iterations (dense
matrix). ";

%feature("docstring")  dolfin::uBlasKrylovSolver::solve "

Solve linear system Ax = b and return number of iterations (sparse
matrix). ";

%feature("docstring")  dolfin::uBlasKrylovSolver::solve "

Solve linear system Ax = b and return number of iterations (virtual
matrix). ";


// File: classdolfin_1_1uBlasLUSolver.xml
%feature("docstring") dolfin::uBlasLUSolver "

This class implements the direct solution (LU factorization) of linear
systems of the form Ax = b using uBlas data types. Dense matrices are
solved using uBlas LU factorisation, and sparse matrices are solved
using UMFPACK (http://www.cise.ufl.edu/research/sparse/umfpack/) is
installed. Matrices can also be inverted.

C++ includes: uBlasLUSolver.h ";

%feature("docstring")  dolfin::uBlasLUSolver::uBlasLUSolver "

Constructor. ";

%feature("docstring")  dolfin::uBlasLUSolver::~uBlasLUSolver "

Destructor. ";

%feature("docstring")  dolfin::uBlasLUSolver::solve "

Solve linear system Ax = b for a dense matrix. ";

%feature("docstring")  dolfin::uBlasLUSolver::solve "

Solve linear system Ax = b for a sparse matrix using UMFPACK if
installed. ";

%feature("docstring")  dolfin::uBlasLUSolver::factorize "

LU-factor sparse matrix A if UMFPACK is installed. ";

%feature("docstring")  dolfin::uBlasLUSolver::factorized_solve "

Solve factorized system (UMFPACK). ";

%feature("docstring")  dolfin::uBlasLUSolver::solve "

Solve linear system Ax = b for a Krylov matrix. ";

%feature("docstring")  dolfin::uBlasLUSolver::solveInPlaceUBlas "

Solve linear system Ax = b in place (A is dense). ";

%feature("docstring")  dolfin::uBlasLUSolver::invert "

Compute the inverse of A (A is dense or sparse). ";


// File: classdolfin_1_1uBlasMatrix.xml
%feature("docstring") dolfin::uBlasMatrix "

This class provides a simple matrix class based on uBLAS. It is a
simple wrapper for a uBLAS matrix implementing the GenericMatrix
interface.

The interface is intentionally simple. For advanced usage, access the
underlying uBLAS matrix and use the standard uBLAS interface which is
documented athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

Developer note: specialised member functions must be inlined to avoid
link errors.

C++ includes: uBlasMatrix.h ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Create empty matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Create M x N matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Copy constructor. ";

%feature("docstring")  dolfin::uBlasMatrix::uBlasMatrix "

Create matrix from given uBLAS matrix expression. ";

%feature("docstring")  dolfin::uBlasMatrix::~uBlasMatrix "

Destructor. ";

%feature("docstring")  dolfin::uBlasMatrix::init "

Initialize zero tensor using sparsity pattern. ";

%feature("docstring")  dolfin::uBlasMatrix::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::uBlasMatrix::size "

Return size of given dimension. ";

%feature("docstring")  dolfin::uBlasMatrix::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::uBlasMatrix::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::uBlasMatrix::disp "

Display tensor. ";

%feature("docstring")  dolfin::uBlasMatrix::init "

Initialize M x N matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::get "

Get block of values. ";

%feature("docstring")  dolfin::uBlasMatrix::set "

Set block of values. ";

%feature("docstring")  dolfin::uBlasMatrix::add "

Add block of values. ";

%feature("docstring")  dolfin::uBlasMatrix::getrow "

Get non-zero values of given row. ";

%feature("docstring")  dolfin::uBlasMatrix::setrow "

Set values for given row. ";

%feature("docstring")  dolfin::uBlasMatrix::zero "

Set given rows to zero. ";

%feature("docstring")  dolfin::uBlasMatrix::ident "

Set given rows to identity matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::mult "

Matrix-vector product, y = Ax. ";

%feature("docstring")  dolfin::uBlasMatrix::factory "

Return linear algebra backend factory. ";

%feature("docstring")  dolfin::uBlasMatrix::mat "

Return reference to uBLAS matrix (const version). ";

%feature("docstring")  dolfin::uBlasMatrix::mat "

Return reference to uBLAS matrix (non-const version). ";

%feature("docstring")  dolfin::uBlasMatrix::solve "

Solve Ax = b out-of-place (A is not destroyed). ";

%feature("docstring")  dolfin::uBlasMatrix::invert "

Compute inverse of matrix. ";

%feature("docstring")  dolfin::uBlasMatrix::lump "

Lump matrix into vector m. ";

%feature("docstring")  dolfin::uBlasMatrix::compress "

Compress matrix (eliminate all non-zeros from a sparse matrix). ";

%feature("docstring")  dolfin::uBlasMatrix::init "

Initialize zero tensor using sparsity pattern. ";


// File: classdolfin_1_1uBlasPreconditioner.xml
%feature("docstring") dolfin::uBlasPreconditioner "

This class specifies the interface for preconditioners for the uBlas
Krylov solver.

C++ includes: uBlasPreconditioner.h ";

%feature("docstring")
dolfin::uBlasPreconditioner::uBlasPreconditioner "

Constructor. ";

%feature("docstring")
dolfin::uBlasPreconditioner::~uBlasPreconditioner "

Destructor. ";

%feature("docstring")  dolfin::uBlasPreconditioner::init "

Initialise preconditioner (dense matrix). ";

%feature("docstring")  dolfin::uBlasPreconditioner::init "

Initialise preconditioner (dense matrix). ";

%feature("docstring")  dolfin::uBlasPreconditioner::init "

Initialise preconditioner (virtual matrix). ";

%feature("docstring")  dolfin::uBlasPreconditioner::solve "

Solve linear system (M^-1)Ax = y. ";


// File: classdolfin_1_1uBlasVector.xml
%feature("docstring") dolfin::uBlasVector "

This class provides a simple vector class based on uBLAS. It is a
simple wrapper for a uBLAS vector implementing the GenericVector
interface.

The interface is intentionally simple. For advanced usage, access the
underlying uBLAS vector and use the standard uBLAS interface which is
documented athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

C++ includes: uBlasVector.h ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Create empty vector. ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Create vector of size N. ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Copy constructor. ";

%feature("docstring")  dolfin::uBlasVector::uBlasVector "

Create vector from given uBLAS vector expression. ";

%feature("docstring")  dolfin::uBlasVector::~uBlasVector "

Destructor. ";

%feature("docstring")  dolfin::uBlasVector::copy "

Create copy of tensor. ";

%feature("docstring")  dolfin::uBlasVector::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::uBlasVector::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::uBlasVector::disp "

Display tensor. ";

%feature("docstring")  dolfin::uBlasVector::init "

Initialize vector of size N. ";

%feature("docstring")  dolfin::uBlasVector::size "

Return size of vector. ";

%feature("docstring")  dolfin::uBlasVector::get "

Get block of values. ";

%feature("docstring")  dolfin::uBlasVector::set "

Set block of values. ";

%feature("docstring")  dolfin::uBlasVector::add "

Add block of values. ";

%feature("docstring")  dolfin::uBlasVector::get "

Get all values. ";

%feature("docstring")  dolfin::uBlasVector::set "

Set all values. ";

%feature("docstring")  dolfin::uBlasVector::add "

Add values to each entry. ";

%feature("docstring")  dolfin::uBlasVector::axpy "

Add multiple of given vector (AXPY operation). ";

%feature("docstring")  dolfin::uBlasVector::inner "

Return inner product with given vector. ";

%feature("docstring")  dolfin::uBlasVector::norm "

Compute norm of vector. ";

%feature("docstring")  dolfin::uBlasVector::min "

Return minimum value of vector. ";

%feature("docstring")  dolfin::uBlasVector::max "

Return maximum value of vector. ";

%feature("docstring")  dolfin::uBlasVector::factory "

Return linear algebra backend factory. ";

%feature("docstring")  dolfin::uBlasVector::vec "

Return reference to uBLAS vector (const version). ";

%feature("docstring")  dolfin::uBlasVector::vec "

Return reference to uBLAS vector (non-const version). ";


// File: classdolfin_1_1UndirectedClique.xml
%feature("docstring") dolfin::UndirectedClique "

A undirected graph where all vertices are adjacent to each other. The
number of vertices is given by num_vertices >= 1. The number of edges
is given by ((num_vertices - 1) * num_vertices) / 2

C++ includes: UndirectedClique.h ";

%feature("docstring")  dolfin::UndirectedClique::UndirectedClique "";


// File: classdolfin_1_1UnitCube.xml
%feature("docstring") dolfin::UnitCube "

Tetrahedral mesh of the 3D unit cube (0,1) x (0,1) x (0,1). Given the
number of cells (nx, ny, nz) in each direction, the total number of
tetrahedra will be 6*nx*ny*nz and the total number of vertices will be
(nx + 1)*(ny + 1)*(nz + 1).

C++ includes: UnitCube.h ";

%feature("docstring")  dolfin::UnitCube::UnitCube "";


// File: classdolfin_1_1UnitInterval.xml
%feature("docstring") dolfin::UnitInterval "

Interval mesh of the 1D unit line (0,1). Given the number of cells
(nx) in the axial direction, the total number of intervals will be nx
and the total number of vertices will be (nx + 1).

C++ includes: UnitInterval.h ";

%feature("docstring")  dolfin::UnitInterval::UnitInterval "";


// File: classdolfin_1_1UnitSquare.xml
%feature("docstring") dolfin::UnitSquare "

Triangular mesh of the 2D unit square (0,1) x (0,1). Given the number
of cells (nx, ny) in each direction, the total number of triangles
will be 2*nx*ny and the total number of vertices will be (nx + 1)*(ny
+ 1). The Type is an enumerater taking values in {left, right or
crisscross} indicating the direction of the diagonals for left/right
or both == crisscross. The default is right.

C++ includes: UnitSquare.h ";

%feature("docstring")  dolfin::UnitSquare::UnitSquare "";


// File: classdolfin_1_1Variable.xml
%feature("docstring") dolfin::Variable "";

%feature("docstring")  dolfin::Variable::Variable "";

%feature("docstring")  dolfin::Variable::Variable "";

%feature("docstring")  dolfin::Variable::Variable "";

%feature("docstring")  dolfin::Variable::rename "";

%feature("docstring")  dolfin::Variable::name "";

%feature("docstring")  dolfin::Variable::label "";


// File: classdolfin_1_1Vector.xml
%feature("docstring") dolfin::Vector "

This class provides the default DOLFIN vector class, based on the
default DOLFIN linear algebra backend.

C++ includes: Vector.h ";

%feature("docstring")  dolfin::Vector::Vector "

Create empty vector. ";

%feature("docstring")  dolfin::Vector::Vector "

Create vector of size N. ";

%feature("docstring")  dolfin::Vector::Vector "

Copy constructor. ";

%feature("docstring")  dolfin::Vector::~Vector "

Destructor. ";

%feature("docstring")  dolfin::Vector::copy "

Return copy of tensor. ";

%feature("docstring")  dolfin::Vector::zero "

Set all entries to zero and keep any sparse structure. ";

%feature("docstring")  dolfin::Vector::apply "

Finalize assembly of tensor. ";

%feature("docstring")  dolfin::Vector::disp "

Display tensor. ";

%feature("docstring")  dolfin::Vector::init "

Initialize vector of size N. ";

%feature("docstring")  dolfin::Vector::size "

Return size of vector. ";

%feature("docstring")  dolfin::Vector::get "

Get block of values. ";

%feature("docstring")  dolfin::Vector::set "

Set block of values. ";

%feature("docstring")  dolfin::Vector::add "

Add block of values. ";

%feature("docstring")  dolfin::Vector::get "

Get all values. ";

%feature("docstring")  dolfin::Vector::set "

Set all values. ";

%feature("docstring")  dolfin::Vector::add "

Add values to each entry. ";

%feature("docstring")  dolfin::Vector::axpy "

Add multiple of given vector (AXPY operation). ";

%feature("docstring")  dolfin::Vector::inner "

Return inner product with given vector. ";

%feature("docstring")  dolfin::Vector::norm "

Return norm of vector. ";

%feature("docstring")  dolfin::Vector::min "

Return minimum value of vector. ";

%feature("docstring")  dolfin::Vector::max "

Return maximum value of vector. ";

%feature("docstring")  dolfin::Vector::factory "

Return linear algebra backend factory. ";

%feature("docstring")  dolfin::Vector::instance "

Return concrete instance / unwrap (const version). ";

%feature("docstring")  dolfin::Vector::instance "

Return concrete instance / unwrap (non-const version). ";


// File: classdolfin_1_1Vertex.xml
%feature("docstring") dolfin::Vertex "

A Vertex is a MeshEntity of topological dimension 0.

C++ includes: Vertex.h ";

%feature("docstring")  dolfin::Vertex::Vertex "

Create vertex on given mesh. ";

%feature("docstring")  dolfin::Vertex::Vertex "

Create vertex from mesh entity. ";

%feature("docstring")  dolfin::Vertex::~Vertex "

Destructor. ";

%feature("docstring")  dolfin::Vertex::x "

Return value of vertex coordinate i. ";

%feature("docstring")  dolfin::Vertex::point "

Return vertex coordinates as a 3D point value. ";

%feature("docstring")  dolfin::Vertex::x "

Return array of vertex coordinates. ";

%feature("docstring")  dolfin::Vertex::x "

Return array of vertex coordinates. ";


// File: classdolfin_1_1VertexIterator.xml
%feature("docstring") dolfin::VertexIterator "

A VertexIterator is a MeshEntityIterator of topological dimension 0.

C++ includes: Vertex.h ";

%feature("docstring")  dolfin::VertexIterator::VertexIterator "";

%feature("docstring")  dolfin::VertexIterator::VertexIterator "";


// File: namespacedolfin.xml
%feature("docstring")  dolfin::tic "

Start timing. ";

%feature("docstring")  dolfin::toc "

Return elapsed CPU time. ";

%feature("docstring")  dolfin::tocd "

Return and display elapsed CPU time. ";

%feature("docstring")  dolfin::time "

Return current CPU time used by process. ";

%feature("docstring")  dolfin::dolfin_get "

Get value of parameter with given key. ";

%feature("docstring")  dolfin::dolfin_set "

Set value of parameter. ";

%feature("docstring")  dolfin::dolfin_set "

Set special key/value pair. ";

%feature("docstring")  dolfin::dolfin_add "

Add parameter. ";

%feature("docstring")  dolfin::message "

Print message.

The DOLFIN log system provides the following set of functions for
uniform handling of log messages, warnings and errors. In addition,
macros are provided for debug messages and assertions.

Only messages with a debug level higher than or equal to the global
debug level are printed (the default being zero). The global debug
level may be controlled by

set(\"debug level\", debug_level);

where debug_level is the desired debug level.

The output destination can be controlled by

set(\"output destination\", destination);

where destination is one of \"terminal\" (default) or \"silent\".
Setting the output destination to \"silent\" means no messages will be
printed. ";

%feature("docstring")  dolfin::message "

Print message. ";

%feature("docstring")  dolfin::warning "

Print warning. ";

%feature("docstring")  dolfin::error "

Print error message and throw an exception. ";

%feature("docstring")  dolfin::begin "

Begin task (increase indentation level). ";

%feature("docstring")  dolfin::begin "

Begin task (increase indentation level). ";

%feature("docstring")  dolfin::end "

End task (decrease indentation level). ";

%feature("docstring")  dolfin::__debug "";

%feature("docstring")  dolfin::__dolfin_assert "";

%feature("docstring")  dolfin::solve "

Solve linear system Ax = b. ";

%feature("docstring")  dolfin::residual "

Compute residual ||Ax - b||. ";

%feature("docstring")  dolfin::normalize "

Normalize vector according to given normalization type. ";

%feature("docstring")  dolfin::projectL2 "

Compute L2 projection fB of fA on FEM space element. ";

%feature("docstring")  dolfin::projectL2NonMatching "

Compute L2 projection fB of fA (discrete function) on FEM space
element. ";

%feature("docstring")  dolfin::dolfin_init "

Initialize DOLFIN (and PETSc) with command-line arguments. This should
not be needed in most cases since the initialization is otherwise
handled automatically. ";

%feature("docstring")  dolfin::sqr "

Return the square of x. ";

%feature("docstring")  dolfin::ipow "

Return a to the power n. ";

%feature("docstring")  dolfin::rand "

Return a random number, uniformly distributed between [0.0, 1.0). ";

%feature("docstring")  dolfin::seed "

Seed random number generator. ";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given variational form and mesh.

These functions provide automated assembly of linear systems, or more
generally, assembly of a sparse tensor from a given variational form.
If you need to assemble a system more than once, consider using the
Assembler class, which may improve performance by reuse of data
structures. ";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given variational form and mesh over a sub
domain. ";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given variational form and mesh over sub domains.
";

%feature("docstring")  dolfin::assemble "

Assemble scalar from given variational form and mesh. ";

%feature("docstring")  dolfin::assemble "

Assemble scalar from given variational form and mesh over a sub
domain. ";

%feature("docstring")  dolfin::assemble "

Assemble scalar from given variational form and mesh over sub domains.
";

%feature("docstring")  dolfin::assemble "

Assemble tensor from given (UFC) form, mesh, coefficients and sub
domains. ";


// File: Array_8h.xml


// File: constants_8h.xml


// File: List_8h.xml


// File: simple__array_8h.xml


// File: TimeDependent_8h.xml


// File: timing_8h.xml


// File: types_8h.xml


// File: Variable_8h.xml


// File: ElementLibrary_8h.xml


// File: ProjectionLibrary_8h.xml


// File: assemble_8h.xml


// File: Assembler_8h.xml


// File: BoundaryCondition_8h.xml


// File: DirichletBC_8h.xml


// File: DofMap_8h.xml


// File: DofMapSet_8h.xml


// File: Form_8h.xml


// File: pAssembler_8h.xml


// File: PeriodicBC_8h.xml


// File: SubSystem_8h.xml


// File: Function_8h.xml


// File: ProjectL2_8h.xml


// File: SpecialFunctions_8h.xml


// File: DirectedClique_8h.xml


// File: Graph_8h.xml


// File: GraphEditor_8h.xml


// File: GraphPartition_8h.xml


// File: UndirectedClique_8h.xml


// File: File_8h.xml


// File: DefaultFactory_8h.xml


// File: EpetraFactory_8h.xml


// File: EpetraMatrix_8h.xml


// File: EpetraVector_8h.xml


// File: GenericMatrix_8h.xml


// File: GenericSparsityPattern_8h.xml


// File: GenericTensor_8h.xml


// File: GenericVector_8h.xml


// File: KrylovSolver_8h.xml


// File: LinearAlgebraFactory_8h.xml


// File: LinearSolver_8h.xml


// File: LUSolver_8h.xml


// File: Matrix_8h.xml


// File: PETScFactory_8h.xml


// File: PETScKrylovSolver_8h.xml


// File: PETScLUSolver_8h.xml


// File: PETScMatrix_8h.xml


// File: PETScObject_8h.xml


// File: PETScVector_8h.xml


// File: PreconditionerType_8h.xml


// File: Scalar_8h.xml


// File: SingularSolver_8h.xml


// File: SLEPcEigenvalueSolver_8h.xml


// File: solve_8h.xml


// File: SolverType_8h.xml


// File: SparsityPattern_8h.xml


// File: uBlasDenseMatrix_8h.xml


// File: uBlasFactory_8h.xml


// File: uBlasILUPreconditioner_8h.xml


// File: uBlasKrylovSolver_8h.xml


// File: uBlasLUSolver_8h.xml


// File: uBlasMatrix_8h.xml


// File: uBlasPreconditioner_8h.xml


// File: uBlasVector_8h.xml


// File: Vector_8h.xml


// File: VectorNormType_8h.xml


// File: Event_8h.xml


// File: log_8h.xml


// File: LogStream_8h.xml


// File: Progress_8h.xml


// File: init_8h.xml


// File: basic_8h.xml


// File: Lagrange_8h.xml


// File: Legendre_8h.xml


// File: ALE_8h.xml


// File: BoundaryMesh_8h.xml


// File: Cell_8h.xml


// File: Edge_8h.xml


// File: Face_8h.xml


// File: Facet_8h.xml


// File: IntersectionDetector_8h.xml


// File: Mesh_8h.xml


// File: MeshConnectivity_8h.xml


// File: MeshData_8h.xml


// File: MeshEditor_8h.xml


// File: MeshEntity_8h.xml


// File: MeshEntityIterator_8h.xml


// File: MeshFunction_8h.xml


// File: MeshGeometry_8h.xml


// File: MeshTopology_8h.xml


// File: MPIMeshCommunicator_8h.xml


// File: Point_8h.xml


// File: SubDomain_8h.xml


// File: UnitCube_8h.xml


// File: UnitInterval_8h.xml


// File: UnitSquare_8h.xml


// File: Vertex_8h.xml


// File: MatrixFactory_8h.xml


// File: NewtonSolver_8h.xml


// File: NonlinearProblem_8h.xml


// File: cGqMethod_8h.xml


// File: ComplexODE_8h.xml


// File: dGqMethod_8h.xml


// File: Homotopy_8h.xml


// File: Method_8h.xml


// File: ODE_8h.xml


// File: Parameter_8h.xml


// File: parameters_8h.xml


// File: Parametrized_8h.xml


// File: LinearPDE_8h.xml


// File: NonlinearPDE_8h.xml


// File: GaussianQuadrature_8h.xml


// File: GaussQuadrature_8h.xml


// File: LobattoQuadrature_8h.xml


// File: Quadrature_8h.xml


// File: RadauQuadrature_8h.xml


// File: dir_293bcaf04d4ecbfb69c98d86ebc5275e.xml


// File: dir_c2d8b013fd04ed882f8d87b68325caba.xml


// File: dir_1890b655131c1abe796835d1d7e57599.xml


// File: dir_fa7665f4f771f6b9bd3285cc3526e10d.xml


// File: dir_7ae9b525fa735889416df9a88318a409.xml


// File: dir_4c8349339c79835b7014fb341fef0206.xml


// File: dir_4d7e92e23f6ea876d470371aa3d29376.xml


// File: dir_3c2ad13ee8805033db44e75511328743.xml


// File: dir_837f57fa7b99817fc9c065cd33a24294.xml


// File: dir_2e3d752c0dc6db1308f89f3ade9719f6.xml


// File: dir_40fb3cedb271a8bfe5ce264c8f153c9b.xml


// File: dir_4051ad071076088e8c66a6e80c9a9988.xml


// File: dir_cfbe19ce0dad3eee24aad31a4afa5d0e.xml


// File: dir_c5290f3dab994c0c9dba61554566fc4f.xml


// File: dir_f52db9cf4adc49528fc87123266f9c76.xml


// File: dir_913f640bc454e255461704ebdcb6a817.xml


// File: dir_a66f8f551e7465104f1dbcd89b910c46.xml

