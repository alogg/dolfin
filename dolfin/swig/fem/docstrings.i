// Auto generated SWIG file for Python interface of DOLFIN
//
// Copyright (C) 2012 Kristian B. Oelgaard
//
// This file is part of DOLFIN.
//
// DOLFIN is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// DOLFIN is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
//

// Autogenerated docstrings file, extracted from the DOLFIN source C++ files.

// Documentation extracted from: (module=fem, header=GenericDofMap.h)
%feature("docstring")  dolfin::GenericDofMap "
This class provides a generic interface for dof maps
";

%feature("docstring")  dolfin::GenericDofMap::is_view "
True if dof map is a view into another map (is a sub-dofmap)
";

%feature("docstring")  dolfin::GenericDofMap::needs_mesh_entities "
Return true iff mesh entities of topological dimension d are needed
";

%feature("docstring")  dolfin::GenericDofMap::global_dimension "
Return the dimension of the global finite element function space
";

%feature("docstring")  dolfin::GenericDofMap::cell_dimension "
Return the dimension of the local finite element function space on a
cell
";

%feature("docstring")  dolfin::GenericDofMap::max_cell_dimension "
Return the maximum dimension of the local finite element function space
";

%feature("docstring")  dolfin::GenericDofMap::num_facet_dofs "
Return number of facet dofs
";

%feature("docstring")  dolfin::GenericDofMap::ownership_range "
Return the ownership range (dofs in this range are owned by this process)
";

%feature("docstring")  dolfin::GenericDofMap::off_process_owner "
Return map from nonlocal-dofs (that appear in local dof map) to owning process
";

%feature("docstring")  dolfin::GenericDofMap::cell_dofs "
Local-to-global mapping of dofs on a cell
";

%feature("docstring")  dolfin::GenericDofMap::tabulate_dofs "
Tabulate the local-to-global mapping of dofs on a cell
";

%feature("docstring")  dolfin::GenericDofMap::tabulate_facet_dofs "
Tabulate local-local facet dofs
";

%feature("docstring")  dolfin::GenericDofMap::tabulate_coordinates "
**Overloaded versions**

* tabulate_coordinates\ (coordinates, ufc_cell)

  Tabulate the coordinates of all dofs on a cell (UFC cell version)

* tabulate_coordinates\ (coordinates, cell)

  Tabulate the coordinates of all dofs on a cell (DOLFIN cell version)
";

%feature("docstring")  dolfin::GenericDofMap::copy "
Create a copy of the dof map
";

%feature("docstring")  dolfin::GenericDofMap::extract_sub_dofmap "
Extract sub dofmap component
";

%feature("docstring")  dolfin::GenericDofMap::collapse "
Create a \"collapsed\" a dofmap (collapses from a sub-dofmap view)
";

%feature("docstring")  dolfin::GenericDofMap::set "
Set dof entries in vector to a specified value. Parallel layout
of vector must be consistent with dof map range.
";

%feature("docstring")  dolfin::GenericDofMap::set_x "
Set dof entries in vector to the x[i] coordinate of the dof
spatial coordinate. Parallel layout of vector must be consistent
with dof map range.
";

%feature("docstring")  dolfin::GenericDofMap::dofs "
Return the set of dof indices
";

%feature("docstring")  dolfin::GenericDofMap::shared_dofs "
Return map from shared dofs to the processes (not including the current
process) that share it.
";

%feature("docstring")  dolfin::GenericDofMap::neighbours "
Return set of all processes that share dofs with the current process.
";

%feature("docstring")  dolfin::GenericDofMap::str "
Return informal string representation (pretty-print)
";

// Documentation extracted from: (module=fem, header=DofMap.h)
%feature("docstring")  dolfin::DofMap "
This class handles the mapping of degrees of freedom. It builds
a dof map based on a ufc::dofmap on a specific mesh. It will
reorder the dofs when running in parallel. Sub-dofmaps, both
views and copies, are supported.
";

%feature("docstring")  dolfin::DofMap::DofMap "
**Overloaded versions**

* DofMap\ (ufc_dofmap, mesh)

  Create dof map on mesh (data is not shared)
  
  *Arguments*
      ufc_dofmap (ufc::dofmap)
          The ufc::dofmap.
      mesh (:py:class:`Mesh`)
          The mesh.

* DofMap\ (dofmap)

  Copy constructor
  
  *Arguments*
      dofmap (:py:class:`DofMap`)
          The object to be copied.
";

%feature("docstring")  dolfin::DofMap::is_view "
True if dof map is a view into another map

*Returns*
    bool
        True if the dof map is a sub-dof map (a view into
        another map).
";

%feature("docstring")  dolfin::DofMap::needs_mesh_entities "
Return true iff mesh entities of topological dimension d are
needed

*Arguments*
    d (int)
        Topological dimension.

*Returns*
    bool
        True if the mesh entities are needed.
";

%feature("docstring")  dolfin::DofMap::global_dimension "
Return the dimension of the global finite element function
space

*Returns*
    int
        The dimension of the global finite element function space.
";

%feature("docstring")  dolfin::DofMap::cell_dimension "
Return the dimension of the local finite element function
space on a cell

*Arguments*
    cell_index (int)
        Index of cell

*Returns*
    int
        Dimension of the local finite element function space.
";

%feature("docstring")  dolfin::DofMap::max_cell_dimension "
Return the maximum dimension of the local finite element
function space

*Returns*
    int
        Maximum dimension of the local finite element function
        space.
";

%feature("docstring")  dolfin::DofMap::geometric_dimension "
Return the geometric dimension of the coordinates this dof map
provides

*Returns*
    int
        The geometric dimension.
";

%feature("docstring")  dolfin::DofMap::num_facet_dofs "
Return number of facet dofs

*Returns*
    int
        The number of facet dofs.
";

%feature("docstring")  dolfin::DofMap::ownership_range "
Return the ownership range (dofs in this range are owned by
this process)

*Returns*
    (int, int)
        The ownership range.
";

%feature("docstring")  dolfin::DofMap::off_process_owner "
Return map from nonlocal dofs that appear in local dof map to
owning process

*Returns*
    boost::unordered_map<unsigned int, unsigned int>
        The map from non-local dofs.
";

%feature("docstring")  dolfin::DofMap::shared_dofs "
Return map from all shared dofs to the processes (not including the current
process) that share it.

*Returns*
    boost::unordered_map<uint, std::vector<uint> >
        The map from dofs to list of processes
";

%feature("docstring")  dolfin::DofMap::neighbours "
Return set of all neighbouring processes.

*Returns*
    boost::unordered_set<uint>
        The set of processes
";

%feature("docstring")  dolfin::DofMap::cell_dofs "
Local-to-global mapping of dofs on a cell

*Arguments*
    cell_index (int)
        The cell index.

*Returns*
    numpy.array(int)
        Local-to-global mapping of dofs.
";

%feature("docstring")  dolfin::DofMap::tabulate_dofs "
Tabulate the local-to-global mapping of dofs on a cell

*Arguments*
    dofs (int)
        Degrees of freedom on a cell.
    cell (:py:class:`Cell`)
        The cell.
";

%feature("docstring")  dolfin::DofMap::tabulate_facet_dofs "
Tabulate local-local facet dofs

*Arguments*
    dofs (int)
        Degrees of freedom.
    local_facet (int)
        The local facet.
";

%feature("docstring")  dolfin::DofMap::tabulate_coordinates "
**Overloaded versions**

* tabulate_coordinates\ (coordinates, ufc_cell)

  Tabulate the coordinates of all dofs on a cell (UFC cell
  version)
  
  *Arguments*
      coordinates (boost::multi_array<double, 2>)
          The coordinates of all dofs on a cell.
      ufc_cell (ufc::cell)
          The cell.

* tabulate_coordinates\ (coordinates, cell)

  Tabulate the coordinates of all dofs on a cell (DOLFIN cell
  version)
  
  *Arguments*
      coordinates (boost::multi_array<double, 2>)
          The coordinates of all dofs on a cell.
      cell (:py:class:`Cell`)
          The cell.
";

%feature("docstring")  dolfin::DofMap::copy "
Create a copy of the dof map

*Arguments*
    mesh (:py:class:`Mesh`)
        The object to be copied.
";

%feature("docstring")  dolfin::DofMap::extract_sub_dofmap "
Extract subdofmap component

*Arguments*
    component (numpy.array(int))
        The component.
    mesh (:py:class:`Mesh`)
        The mesh.

*Returns*
    DofMap
        The subdofmap component.
";

%feature("docstring")  dolfin::DofMap::collapse "
Create a \"collapsed\" dofmap (collapses a sub-dofmap)

*Arguments*
    collapsed_map (boost::unordered_map<uint, uint>)
        The \"collapsed\" map.
    mesh (:py:class:`Mesh`)
        The mesh.

*Returns*
    DofMap
        The collapsed dofmap.
";

%feature("docstring")  dolfin::DofMap::set "
Set dof entries in vector to a specified value. Parallel layout
of vector must be consistent with dof map range.

*Arguments*
    vector (:py:class:`GenericVector`)
        The vector to set.
    value (float)
        The value to set.
";

%feature("docstring")  dolfin::DofMap::set_x "
Set dof entries in vector to the x[i] coordinate of the dof
spatial coordinate. Parallel layout of vector must be consistent
with dof map range.

*Arguments*
    vector (:py:class:`GenericVector`)
        The vector to set.
    mesh (:py:class:`Mesh`)
        The mesh.
    component (int)
        The coordinate index.
";

%feature("docstring")  dolfin::DofMap::dofs "
Return the set of dof indices

*Returns*
    boost::unordered_set<dolfin::uint>
        The set of dof indices.
";

%feature("docstring")  dolfin::DofMap::data "
Return the underlying dof map data. Intended for internal library
use only.

*Returns*
    std::vector<std::vector<dolfin::uint> >
        The local-to-global map for each cell.
";

%feature("docstring")  dolfin::DofMap::str "
Return informal string representation (pretty-print)

*Arguments*
    verbose (bool)
        Flag to turn on additional output.

*Returns*
    str
        An informal representation of the function space.
";

// Documentation extracted from: (module=fem, header=Equation.h)
%feature("docstring")  dolfin::Equation "
This class represents a variational equation lhs == rhs.
The equation can be either linear or nonlinear:

1. Linear (a == L), in which case a must be a bilinear form
   and L must be a linear form.

2. Nonlinear (F == 0), in which case F must be a linear form.
";

%feature("docstring")  dolfin::Equation::Equation "
**Overloaded versions**

* Equation\ (a, L)

  Create equation a == L

* Equation\ (F, rhs)

  Create equation F == 0
";

%feature("docstring")  dolfin::Equation::is_linear "
Check whether equation is linear
";

%feature("docstring")  dolfin::Equation::lhs "
Return form for left-hand side
";

%feature("docstring")  dolfin::Equation::rhs "
Return form for right-hand side
";

%feature("docstring")  dolfin::Equation::rhs_int "
Return value for right-hand side
";

// Documentation extracted from: (module=fem, header=FiniteElement.h)
%feature("docstring")  dolfin::FiniteElement "
This is a wrapper for a UFC finite element (ufc::finite_element).
";

%feature("docstring")  dolfin::FiniteElement::FiniteElement "
Create finite element from UFC finite element (data may be shared)
";

%feature("docstring")  dolfin::FiniteElement::signature "
Return a string identifying the finite element
";

%feature("docstring")  dolfin::FiniteElement::cell_shape "
Return the cell shape
";

%feature("docstring")  dolfin::FiniteElement::space_dimension "
Return the dimension of the finite element function space
";

%feature("docstring")  dolfin::FiniteElement::value_rank "
Return the rank of the value space
";

%feature("docstring")  dolfin::FiniteElement::value_dimension "
Return the dimension of the value space for axis i
";

%feature("docstring")  dolfin::FiniteElement::evaluate_basis "
**Overloaded versions**

* evaluate_basis\ (i, values, x, cell)

  Evaluate basis function i at given point in cell

* evaluate_basis\ (i, values, x, cell)

  Evaluate basis function i at given point in cell
";

%feature("docstring")  dolfin::FiniteElement::evaluate_basis_all "
**Overloaded versions**

* evaluate_basis_all\ (values, coordinates, c)

  Evaluate all basis functions at given point in cell

* evaluate_basis_all\ (values, coordinates, cell)

  Evaluate all basis functions at given point in cell
";

%feature("docstring")  dolfin::FiniteElement::evaluate_basis_derivatives "
Evaluate order n derivatives of basis function i at given point in cell
";

%feature("docstring")  dolfin::FiniteElement::evaluate_basis_derivatives_all "
Evaluate order n derivatives of all basis functions at given point in cell
";

%feature("docstring")  dolfin::FiniteElement::evaluate_dof "
Evaluate linear functional for dof i on the function f
";

%feature("docstring")  dolfin::FiniteElement::evaluate_dofs "
Evaluate linear functionals for all dofs on the function f
";

%feature("docstring")  dolfin::FiniteElement::interpolate_vertex_values "
Interpolate vertex values from dof values
";

%feature("docstring")  dolfin::FiniteElement::map_from_reference_cell "
Map coordinate xhat from reference cell to coordinate x in cell
";

%feature("docstring")  dolfin::FiniteElement::map_to_reference_cell "
Map from coordinate x in cell to coordinate xhat in reference cell
";

%feature("docstring")  dolfin::FiniteElement::num_sub_elements "
Return the number of sub elements (for a mixed element)
";

%feature("docstring")  dolfin::FiniteElement::hash "
Return simple hash of the signature string
";

%feature("docstring")  dolfin::FiniteElement::create_sub_element "
Create a new finite element for sub element i (for a mixed element)
";

%feature("docstring")  dolfin::FiniteElement::create "
Create a new class instance
";

%feature("docstring")  dolfin::FiniteElement::extract_sub_element "
Extract sub finite element for component
";

// Documentation extracted from: (module=fem, header=BasisFunction.h)
%feature("docstring")  dolfin::BasisFunction "
This class represents a finite element basis function. It can be
used for computation of basis function values and derivatives.

Evaluation of basis functions is also possible through the use
of the functions ``evaluate_basis`` and ``evaluate_basis_derivatives``
available in the :py:class:`FiniteElement` class. The BasisFunction class
relies on these functions for evaluation but also implements the
ufc::function interface which allows evaluate_dof to be
evaluated for a basis function (on a possibly different
element).
";

%feature("docstring")  dolfin::BasisFunction::BasisFunction "
Create basis function with given index on element on given cell

*Arguments*
    index (int)
        The index of the basis function.
    element (:py:class:`FiniteElement`)
        The element to create basis function on.
    cell (ufc::cell)
        The cell.
";

%feature("docstring")  dolfin::BasisFunction::eval "
Evaluate basis function at given point

*Arguments*
    values (float)
        The values of the function at the point.
    x (float)
        The coordinates of the point.
";

%feature("docstring")  dolfin::BasisFunction::eval_derivatives "
Evaluate all order n derivatives at given point

*Arguments*
    values (float)
        The values of derivatives at the point.
    x (float)
        The coordinates of the point.
    n (int)
        The order of derivation.
";

%feature("docstring")  dolfin::BasisFunction::evaluate "
Evaluate function at given point in cell

*Arguments*
    values (float)
        The values of the function at the point..
    coordinates (float)
        The coordinates of the point.
    cell (ufc::cell)
        The cell.
";

// Documentation extracted from: (module=fem, header=BoundaryCondition.h)
%feature("docstring")  dolfin::BoundaryCondition "
Common base class for boundary conditions
";

%feature("docstring")  dolfin::BoundaryCondition::BoundaryCondition "
**Overloaded versions**

* BoundaryCondition\ (V)

  Constructor

* BoundaryCondition\ (V)

  Constructor
";

%feature("docstring")  dolfin::BoundaryCondition::apply "
**Overloaded versions**

* apply\ (A)

  Apply boundary condition to a matrix

* apply\ (b)

  Apply boundary condition to a vector

* apply\ (A, b)

  Apply boundary condition to a linear system

* apply\ (b, x)

  Apply boundary condition to a vector for a nonlinear problem

* apply\ (A, b, x)

  Apply boundary condition to a linear system for a nonlinear problem
";

%feature("docstring")  dolfin::BoundaryCondition::function_space "
Return shared pointer to function space
";

// Documentation extracted from: (module=fem, header=DirichletBC.h)
%feature("docstring")  dolfin::DirichletBC "
This class specifies the interface for setting (strong)
Dirichlet boundary conditions for partial differential
equations,

.. math::

    u = g \hbox{ on } G,

where :math:`u` is the solution to be computed, :math:`g` is a function
and :math:`G` is a sub domain of the mesh.

A DirichletBC is specified by the function g, the function space
(trial space) and boundary indicators on (a subset of) the mesh
boundary.

The boundary indicators may be specified in a number of
different ways.

The simplest approach is to specify the boundary by a :py:class:`SubDomain`
object, using the inside() function to specify on which facets
the boundary conditions should be applied.

Alternatively, the boundary may be specified by a :py:class:`MeshFunction`
labeling all mesh facets together with a number that specifies
which facets should be included in the boundary.

The third option is to attach the boundary information to the
mesh. This is handled automatically when exporting a mesh from
for example VMTK.

The ``method`` variable may be used to specify the type of
method used to identify degrees of freedom on the
boundary. Available methods are: topological approach (default),
geometric approach, and pointwise approach. The topological
approach is faster, but will only identify degrees of freedom
that are located on a facet that is entirely on the boundary. In
particular, the topological approach will not identify degrees
of freedom for discontinuous elements (which are all internal to
the cell).  A remedy for this is to use the geometric
approach. To apply pointwise boundary conditions
e.g. pointloads, one will have to use the pointwise approach
which in turn is the slowest of the three possible methods.  The
three possibilties are \"topological\", \"geometric\" and
\"pointwise\".
";

%feature("docstring")  dolfin::DirichletBC::DirichletBC "
**Overloaded versions**

* DirichletBC\ (V, g, sub_domain, method=\"topological\")

  Create boundary condition for subdomain
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      g (:py:class:`GenericFunction`)
          The value.
      sub_domain (:py:class:`SubDomain`)
          The subdomain.
      method (str)
          Optional argument: A string specifying
          the method to identify dofs.

* DirichletBC\ (V, g, sub_domain, method=\"topological\")

  Create boundary condition for subdomain
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space
      g (:py:class:`GenericFunction`)
          The value
      sub_domain (:py:class:`SubDomain`)
          The subdomain
      method (str)
          Optional argument: A string specifying
          the method to identify dofs

* DirichletBC\ (V, g, sub_domains, sub_domain, method=\"topological\")

  Create boundary condition for subdomain specified by index
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      g (:py:class:`GenericFunction`)
          The value.
      sub_domains (:py:class:`MeshFunction`)
          Subdomain markers
      sub_domain (int)
          The subdomain index (number)
      method (str)
          Optional argument: A string specifying the
          method to identify dofs.

* DirichletBC\ (V, g, sub_domains, sub_domain, method=\"topological\")

  Create boundary condition for subdomain specified by index
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      g (:py:class:`GenericFunction`)
          The value.
      sub_domains (:py:class:`MeshFunction`)
          Subdomain markers
      sub_domain (int)
          The subdomain index (number)
      method (str)
          Optional argument: A string specifying the
          method to identify dofs.

* DirichletBC\ (V, g, sub_domain, method=\"topological\")

  Create boundary condition for boundary data included in the mesh
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      g (:py:class:`GenericFunction`)
          The value.
      sub_domain (int)
          The subdomain index (number)
      method (str)
          Optional argument: A string specifying the
          method to identify dofs.

* DirichletBC\ (V, g, sub_domain, method=\"topological\")

  Create boundary condition for boundary data included in the mesh
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      g (:py:class:`GenericFunction`)
          The value.
      sub_domain (int)
          The subdomain index (number)
      method (str)
          Optional argument: A string specifying the
          method to identify dofs.

* DirichletBC\ (V, g, markers, method=\"topological\")

  Create boundary condition for subdomain by boundary markers
  (cells, local facet numbers)
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      g (:py:class:`GenericFunction`)
          The value.
      markers (numpy.array((int, int)))
          Subdomain markers (cells, local facet number)
      method (str)
          Optional argument: A string specifying the
          method to identify dofs.

* DirichletBC\ (bc)

  Copy constructor
  
  *Arguments*
      bc (:py:class:`DirichletBC`)
          The object to be copied.
";

%feature("docstring")  dolfin::DirichletBC::operator= "
Assignment operator

*Arguments*
    bc (:py:class:`DirichletBC`)
        Another DirichletBC object.
";

%feature("docstring")  dolfin::DirichletBC::apply "
**Overloaded versions**

* apply\ (A)

  Apply boundary condition to a matrix
  
  *Arguments*
      A (:py:class:`GenericMatrix`)
          The matrix to apply boundary condition to.

* apply\ (b)

  Apply boundary condition to a vector
  
  *Arguments*
      b (:py:class:`GenericVector`)
          The vector to apply boundary condition to.

* apply\ (A, b)

  Apply boundary condition to a linear system
  
  *Arguments*
      A (:py:class:`GenericMatrix`)
          The matrix to apply boundary condition to.
      b (:py:class:`GenericVector`)
          The vector to apply boundary condition to.

* apply\ (b, x)

  Apply boundary condition to vectors for a nonlinear problem
  
  *Arguments*
      b (:py:class:`GenericVector`)
          The vector to apply boundary conditions to.
      x (:py:class:`GenericVector`)
          Another vector (nonlinear problem).

* apply\ (A, b, x)

  Apply boundary condition to a linear system for a nonlinear problem
  
  *Arguments*
      A (:py:class:`GenericMatrix`)
          The matrix to apply boundary conditions to.
      b (:py:class:`GenericVector`)
          The vector to apply boundary conditions to.
      x (:py:class:`GenericVector`)
          Another vector (nonlinear problem).
";

%feature("docstring")  dolfin::DirichletBC::get_boundary_values "
Get Dirichlet dofs and values. If a method other than 'pointwise' is
used in parallel, the map may not be complete for local vertices since
a vertex can have a bc applied, but the partition might not have a
facet on the boundary. To ensure all local boundary dofs are marked,
it is necessary to call gather() on the returned boundary values.

*Arguments*
    boundary_values (boost::unordered_map<uint, double>)
        Map from dof to boundary value.
    method (str)
        Optional argument: A string specifying which
        method to use.
";

%feature("docstring")  dolfin::DirichletBC::gather "
Get boundary values from neighbour processes. If a method other than
\"pointwise\" is used, this is necessary to ensure all boundary dofs are
marked on all processes.

*Arguments*
    boundary_values (boost::unordered_map<uint, double>)
        Map from dof to boundary value.
";

%feature("docstring")  dolfin::DirichletBC::zero "
Make rows of matrix associated with boundary condition zero,
useful for non-diagonal matrices in a block matrix.

*Arguments*
    A (:py:class:`GenericMatrix`)
        The matrix
";

%feature("docstring")  dolfin::DirichletBC::zero_columns "
Make columns of matrix associated with boundary condition
zero, and update a (right-hand side) vector to reflect the
changes. Useful for non-diagonals.

*Arguments*
    A (:py:class:`GenericMatrix`)
        The matrix
    b (:py:class:`GenericVector`)
        The vector
    diag_val (float)
        This parameter would normally be -1, 0 or 1.
";

%feature("docstring")  dolfin::DirichletBC::markers "
Return boundary markers

*Returns*
    numpy.array((int, int))
        Boundary markers (facets stored as pairs of cells and
        local facet numbers).
";

%feature("docstring")  dolfin::DirichletBC::value "
Return boundary value g

*Returns*
    :py:class:`GenericFunction`
        The boundary values.
";

%feature("docstring")  dolfin::DirichletBC::user_sub_domain "
Return shared pointer to subdomain

*Returns*
    :py:class:`SubDomain`
        Shared pointer to subdomain.
";

%feature("docstring")  dolfin::DirichletBC::is_compatible "
Check if given function is compatible with boundary condition
(checking only vertex values)

*Arguments*
    v (:py:class:`GenericFunction`)
        The function to check for compability
        with boundary condition.

*Returns*
    bool
        True if compatible.
";

%feature("docstring")  dolfin::DirichletBC::set_value "
**Overloaded versions**

* set_value\ (g)

  Set value g for boundary condition, domain remains unchanged
  
  *Arguments*
      g (:py:class:`GenericFunction`)
          The value.

* set_value\ (g)

  Set value g for boundary condition, domain remains unchanged
  
  *Arguments*
      g (:py:class:`GenericFunction`)
          The value.
";

%feature("docstring")  dolfin::DirichletBC::homogenize "
Set value to 0.0
";

%feature("docstring")  dolfin::DirichletBC::method "
Return method used for computing Dirichet dofs

*Returns*
    str
        Method used for computing Dirichet dofs (\"topological\",
        \"geometric\" or \"pointwise\").
";

%feature("docstring")  dolfin::DirichletBC::default_parameters "
Default parameter values
";

// Documentation extracted from: (module=fem, header=PeriodicBC.h)
%feature("docstring")  dolfin::PeriodicBC "
This class specifies the interface for setting periodic boundary
conditions for partial differential equations,

.. math::

    u(x) &= u(F^{-1}(x)) \hbox { on } G,

    u(x) &= u(F(x))      \hbox{ on } H,

where F : H --> G is a map from a subdomain H to a subdomain G.

A periodic boundary condition must be defined by the domain G
and the map F pulling coordinates back from H to G. The domain
and the map are both defined by a subclass of :py:class:`SubDomain` which
must overload both the inside() function, which specifies the
points of G, and the map() function, which specifies the map
from the points of H to the points of G.

The implementation is based on matching degrees of freedom on G
with degrees of freedom on H and only works when the mapping F
is bijective between the sets of coordinates associated with the
two domains. In other words, the nodes (degrees of freedom) must
be aligned on G and H.

The matching of degrees of freedom is done at the construction
of the periodic boundary condition and is reused on subsequent
applications to a linear system. The matching may be recomputed
by calling the ``rebuild()`` function.
";

%feature("docstring")  dolfin::PeriodicBC::PeriodicBC "
**Overloaded versions**

* PeriodicBC\ (V, sub_domain)

  Create periodic boundary condition for subdomain
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      sub_domain (:py:class:`SubDomain`)
          The sub domain.

* PeriodicBC\ (V, sub_domain)

  Create periodic boundary condition for subdomain
  
  *Arguments*
      V (:py:class:`FunctionSpace`)
          The function space.
      sub_domain (:py:class:`SubDomain`)
          The subdomain.
";

%feature("docstring")  dolfin::PeriodicBC::apply "
**Overloaded versions**

* apply\ (A)

  Apply boundary condition to a matrix
  
  *Arguments*
      A (:py:class:`GenericMatrix`)
          The matrix to apply bc to.

* apply\ (b)

  Apply boundary condition to a vector
  
  *Arguments*
      b (:py:class:`GenericVector`)
          The vector to apply bc to.

* apply\ (A, b)

  Apply boundary condition to a linear system
  
  *Arguments*
      A (:py:class:`GenericMatrix`)
          The matrix.
      b (:py:class:`GenericVector`)
          The vector.

* apply\ (b, x)

  Apply boundary condition to a vector for a nonlinear problem
  
  *Arguments*
      b (:py:class:`GenericVector`)
          The vector to apply bc to.
      x (:py:class:`GenericVector`)
          Another vector (nonlinear problem).

* apply\ (A, b, x)

  Apply boundary condition to a linear system for a nonlinear
  problem
  
  *Arguments*
      A (:py:class:`GenericMatrix`)
          The matrix to apply bc to.
      b (:py:class:`GenericVector`)
          The vector to apply bc to.
      x (:py:class:`GenericVector`)
          Another vector (nonlinear problem).
";

%feature("docstring")  dolfin::PeriodicBC::sub_domain "
Return shared pointer to subdomain

*Returns*
    :py:class:`SubDomain`
        Shared pointer to subdomain.
";

%feature("docstring")  dolfin::PeriodicBC::rebuild "
Rebuild mapping between dofs
";

%feature("docstring")  dolfin::PeriodicBC::compute_dof_pairs "
**Overloaded versions**

* compute_dof_pairs\ ()

  Compute dof pairs (master dof, slave dof)

* compute_dof_pairs\ (uint>, dof_pairs)

  Compute dof pairs (master dof, slave dof)
";

// Documentation extracted from: (module=fem, header=PointSource.h)
%feature("docstring")  dolfin::PointSource "
This class provides an easy mechanism for adding a point source
(Dirac delta function) to the right-hand side vector in a
variational problem. The associated function space must be
scalar in order for the inner product with the (scalar) Dirac
delta function to be well defined.
";

%feature("docstring")  dolfin::PointSource::PointSource "
**Overloaded versions**

* PointSource\ (V, p, magnitude=1.0)

  Create point source at given point of given magnitude

* PointSource\ (V, p, magnitude=1.0)

  Create point source at given point of given magnitude
";

%feature("docstring")  dolfin::PointSource::apply "
Apply (add) point source to right-hand side vector
";

// Documentation extracted from: (module=fem, header=assemble.h)
%feature("docstring")  dolfin::assemble "
**Overloaded versions**

* assemble\ (A, a, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor

* assemble\ (A, a, sub_domain, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor on sub domain

* assemble\ (A, a, cell_domains, exterior_facet_domains, interior_facet_domains, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor on sub domains

* assemble\ (a, reset_sparsity=true, add_values=false, finalize_tensor=true)

  Assemble scalar

* assemble\ (a, sub_domain, reset_sparsity=true, add_values=false, finalize_tensor=true)

  Assemble scalar on sub domain

* assemble\ (a, cell_domains, exterior_facet_domains, interior_facet_domains, reset_sparsity=true, add_values=false, finalize_tensor=true)

  Assemble scalar on sub domains
";

%feature("docstring")  dolfin::assemble_system "
**Overloaded versions**

* assemble_system\ (A, b, a, L, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b)

* assemble_system\ (A, b, a, L, bc, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b) and apply Dirichlet boundary condition

* assemble_system\ (A, b, a, L, bcs, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b) and apply Dirichlet boundary conditions

* assemble_system\ (A, b, a, L, bcs, cell_domains, exterior_facet_domains, interior_facet_domains, x0, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b) on sub domains and apply Dirichlet boundary conditions
";

%feature("docstring")  dolfin::symmetric_assemble "
**Overloaded versions**

* symmetric_assemble\ (As, An, a, bcs, cell_domains=NULL, exterior_facet_domains=NULL, interior_facet_domains=NULL, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Symmetric assembly of As, storing the modifications in An. To create
  matching RHS, assemble and apply bcs normally, then subtract An*b.
  In this variant of symmetric_assemble, rows and columns use the same BCs.

* symmetric_assemble\ (As, An, a, row_bcs, col_bcs, cell_domains=NULL, exterior_facet_domains=NULL, interior_facet_domains=NULL, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Symmetric assembly of As, storing the modifications in An. To create
  matching RHS, assemble and apply bcs normally, then subtract An*b.
  In this variant of symmetric_assemble, rows and columns use (potentially)
  different BCs. The BCs will be different for example in coupling
  (i.e., off-diagonal) blocks of a block matrix.
";

// Documentation extracted from: (module=fem, header=solve.h)
%feature("docstring")  dolfin::solve "
**Overloaded versions**

* solve\ (equation, u, params=empty_parameters)

  Solve linear variational problem a(u, v) == L(v) or nonlinear
  variational problem F(u; v) = 0 without boundary conditions
  Parameters to the Linear/Nonlinear VariationalSolver can be passed
  using params

* solve\ (equation, u, bc, params=empty_parameters)

  Solve linear variational problem a(u, v) == L(v) or nonlinear
  variational problem F(u; v) = 0 with a single boundary condition
  Parameters to the Linear/Nonlinear VariationalSolver can be passed
  using params

* solve\ (equation, u, bcs, params=empty_parameters)

  Solve linear variational problem a(u, v) == L(v) or nonlinear
  variational problem F(u; v) = 0 with a list of boundary conditions
  Parameters to the Linear/Nonlinear VariationalSolver can be passed
  using params

* solve\ (equation, u, J, params=empty_parameters)

  Solve nonlinear variational problem F(u; v) == 0 without boundary
  conditions. The argument J should provide the Jacobian bilinear
  form J = dF/du. Parameters to the Nonlinear VariationalSolver
  can be passed using params

* solve\ (equation, u, bc, J, params=empty_parameters)

  Solve nonlinear variational problem F(u; v) == 0 with a single
  boundary condition. The argument J should provide the Jacobian
  bilinear form J = dF/du. Parameters to the Nonlinear
  VariationalSolver can be passed using params

* solve\ (equation, u, bcs, J, params=empty_parameters)

  Solve nonlinear variational problem F(u; v) == 0 with a list of
  boundary conditions. The argument J should provide the Jacobian
  bilinear form J = dF/du. Parameters to the Nonlinear
  VariationalSolver can be passed using params
";

// Documentation extracted from: (module=fem, header=Form.h)
%feature("docstring")  dolfin::Form "
Base class for UFC code generated by FFC for DOLFIN with option -l.

A note on the order of trial and test spaces: FEniCS numbers
argument spaces starting with the leading dimension of the
corresponding tensor (matrix). In other words, the test space is
numbered 0 and the trial space is numbered 1. However, in order
to have a notation that agrees with most existing finite element
literature, in particular

    a = a(u, v)

the spaces are numbered from right to

    a: V_1 x V_0 -> R

.. note::

    Figure out how to write this in math mode without it getting
    messed up in the Python version.

This is reflected in the ordering of the spaces that should be
supplied to generated subclasses. In particular, when a bilinear
form is initialized, it should be initialized as

.. code-block:: c++

    a(V_1, V_0) = ...

where ``V_1`` is the trial space and ``V_0`` is the test space.
However, when a form is initialized by a list of argument spaces
(the variable ``function_spaces`` in the constructors below, the
list of spaces should start with space number 0 (the test space)
and then space number 1 (the trial space).
";

%feature("docstring")  dolfin::Form::Form "
**Overloaded versions**

* Form\ (rank, num_coefficients)

  Create form of given rank with given number of coefficients
  
  *Arguments*
      rank (int)
          The rank.
      num_coefficients (int)
          The number of coefficients.

* Form\ (ufc_form, function_spaces, coefficients)

  Create form (shared data)
  
  *Arguments*
      ufc_form (ufc::form)
          The UFC form.
      function_spaces (list of :py:class:`FunctionSpace`)
          Vector of function spaces.
      coefficients (list of :py:class:`GenericFunction`)
          Vector of coefficients.
";

%feature("docstring")  dolfin::Form::rank "
Return rank of form (bilinear form = 2, linear form = 1,
functional = 0, etc)

*Returns*
    int
        The rank of the form.
";

%feature("docstring")  dolfin::Form::num_coefficients "
Return number of coefficients

*Returns*
    int
        The number of coefficients.
";

%feature("docstring")  dolfin::Form::coloring "
Return coloring type for colored (multi-threaded) assembly of form
over a mesh entity of a given dimension

*Arguments*
    entity_dim (int)
        Dimension.

*Returns*
    numpy.array(int)
        Coloring type.
";

%feature("docstring")  dolfin::Form::set_mesh "
Set mesh, necessary for functionals when there are no function spaces

*Arguments*
    mesh (:py:class:`Mesh`)
        The mesh.
";

%feature("docstring")  dolfin::Form::mesh "
Extract common mesh from form

*Returns*
    :py:class:`Mesh`
        The mesh.
";

%feature("docstring")  dolfin::Form::mesh_shared_ptr "
Return mesh shared pointer (if any)

*Returns*
    :py:class:`Mesh`
        The mesh shared pointer.
";

%feature("docstring")  dolfin::Form::function_space "
Return function space for given argument

*Arguments*
    i (int)
        Index

*Returns*
    :py:class:`FunctionSpace`
        Function space shared pointer.
";

%feature("docstring")  dolfin::Form::function_spaces "
Return function spaces for arguments

*Returns*
    list of :py:class:`FunctionSpace`
        Vector of function space shared pointers.
";

%feature("docstring")  dolfin::Form::set_coefficient "
**Overloaded versions**

* set_coefficient\ (i, coefficient)

  Set coefficient with given number (shared pointer version)
  
  *Arguments*
      i (int)
          The given number.
      coefficient (:py:class:`GenericFunction`)
          The coefficient.

* set_coefficient\ (name, coefficient)

  Set coefficient with given name (shared pointer version)
  
  *Arguments*
      name (str)
          The name.
      coefficient (:py:class:`GenericFunction`)
          The coefficient.
";

%feature("docstring")  dolfin::Form::set_coefficients "
Set all coefficients in given map, possibly a subset (shared
pointer version)

*Arguments*
    coefficients (:py:class:`GenericFunction`)
        The map of coefficients.
";

%feature("docstring")  dolfin::Form::coefficient "
**Overloaded versions**

* coefficient\ (i)

  Return coefficient with given number
  
  *Arguments*
      i (int)
          Index
  
  *Returns*
      :py:class:`GenericFunction`
          The coefficient.

* coefficient\ (name)

  Return coefficient with given name
  
  *Arguments*
      name (str)
          The name.
  
  *Returns*
      :py:class:`GenericFunction`
          The coefficient.
";

%feature("docstring")  dolfin::Form::coefficients "
Return all coefficients

*Returns*
    list of :py:class:`GenericFunction`
        All coefficients.
";

%feature("docstring")  dolfin::Form::coefficient_number "
Return the number of the coefficient with this name

*Arguments*
    name (str)
        The name.

*Returns*
    int
        The number of the coefficient with the given name.
";

%feature("docstring")  dolfin::Form::coefficient_name "
Return the name of the coefficient with this number

*Arguments*
    i (int)
        The number

*Returns*
    str
        The name of the coefficient with the given number.
";

%feature("docstring")  dolfin::Form::cell_domains_shared_ptr "
Return cell domains (zero pointer if no domains have been
specified)

*Returns*
    :py:class:`MeshFunction`
        The cell domains.
";

%feature("docstring")  dolfin::Form::exterior_facet_domains_shared_ptr "
Return exterior facet domains (zero pointer if no domains have
been specified)

*Returns*
    :py:class:`MeshFunction`
        The exterior facet domains.
";

%feature("docstring")  dolfin::Form::interior_facet_domains_shared_ptr "
Return interior facet domains (zero pointer if no domains have
been specified)

*Returns*
    :py:class:`MeshFunction`
        The interior facet domains.
";

%feature("docstring")  dolfin::Form::set_cell_domains "
Set cell domains

*Arguments*
    cell_domains (:py:class:`MeshFunction`)
        The cell domains.
";

%feature("docstring")  dolfin::Form::set_exterior_facet_domains "
Set exterior facet domains

*Arguments*
    exterior_facet_domains (:py:class:`MeshFunction`)
        The exterior facet domains.
";

%feature("docstring")  dolfin::Form::set_interior_facet_domains "
Set interior facet domains

*Arguments*
    interior_facet_domains (:py:class:`MeshFunction`)
        The interior facet domains.
";

%feature("docstring")  dolfin::Form::ufc_form "
Return UFC form shared pointer

*Returns*
    ufc::form
        The UFC form.
";

%feature("docstring")  dolfin::Form::check "
Check function spaces and coefficients
";

%feature("docstring")  dolfin::Form::operator== "
**Overloaded versions**

* operator==\ (rhs)

  Comparison operator, returning equation lhs == rhs

* operator==\ (rhs)

  Comparison operator, returning equation lhs == 0
";

// Documentation extracted from: (module=fem, header=Assembler.h)
%feature("docstring")  dolfin::Assembler "
This class provides automated assembly of linear systems, or
more generally, assembly of a sparse tensor from a given
variational form.

Subdomains for cells and facets may be specified in a number of
different ways:

1. By explicitly passing :py:class:`MeshFunction` (as pointers) to the
   assemble functions

2. By assigning subdomain indicators specified by :py:class:`MeshFunction`
   to the :py:class:`Form` being assembled:

   .. code-block:: c++

       form.dx = cell_domains
       form.ds = exterior_facet_domains
       form.dS = interior_facet_domains

3. By markers stored as part of the :py:class:`Mesh` (in :py:class:`MeshDomains`)

4. By specifying a :py:class:`SubDomain` which specifies the domain numbered
   as 0 (with the rest treated as domain number 1)

Note that (1) overrides (2), which overrides (3).
";

%feature("docstring")  dolfin::Assembler::assemble "
**Overloaded versions**

* assemble\ (A, a, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor from given form
  
  *Arguments*
      A (:py:class:`GenericTensor`)
          The tensor to assemble.
      a (:py:class:`Form`)
          The form to assemble the tensor from.
      reset_sparsity (bool)
          Optional argument: Default value is true.
          This controls whether the sparsity pattern of the
          given tensor is reset prior to assembly.
      add_values (bool)
          Optional argument: Default value is false.
          This controls whether values are added to the given
          tensor or if it is zeroed prior to assembly.
      finalize_tensor (bool)
          Optional argument: Default value is true.
          This controls whether the assembler finalizes the
          given tensor after assembly is completed by calling
          A.apply().

* assemble\ (A, a, sub_domain, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor from given form on subdomain
  
  *Arguments*
      A (:py:class:`GenericTensor`)
          The tensor to assemble.
      a (:py:class:`Form`)
          The form to assemble the tensor from.
      sub_domain (:py:class:`SubDomain`)
          The subdomain to assemble on.
      reset_sparsity (bool)
          Optional argument: Default value is true.
          This controls whether the sparsity pattern of the
          given tensor is reset prior to assembly.
      add_values (bool)
          Optional argument: Default value is false.
          This controls whether values are added to the given
          tensor or if it is zeroed prior to assembly.
      finalize_tensor (bool)
          Optional argument: Default value is true.
          This controls whether the assembler finalizes the
          given tensor after assembly is completed by calling
          A.apply().

* assemble\ (A, a, cell_domains, exterior_facet_domains, interior_facet_domains, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor from given form on subdomains
  
  *Arguments*
      A (:py:class:`GenericTensor`)
          The tensor to assemble.
      a (:py:class:`Form`)
          The form to assemble the tensor from.
      cell_domains (:py:class:`MeshFunction`)
          Cell domains.
      exterior_facet_domains (:py:class:`MeshFunction`)
          The exterior facet domains.
      interior_facet_domains (:py:class:`MeshFunction`)
          The interior facet domains.
      reset_sparsity (bool)
          Optional argument: Default value is true.
          This controls whether the sparsity pattern of the
          given tensor is reset prior to assembly.
      add_values (bool)
          Optional argument: Default value is false.
          This controls whether values are added to the given
          tensor or if it is zeroed prior to assembly.
      finalize_tensor (bool)
          Optional argument: Default value is true.
          This controls whether the assembler finalizes the
          given tensor after assembly is completed by calling
          A.apply().
";

%feature("docstring")  dolfin::Assembler::assemble_cells "
Assemble tensor from given form over cells. This function is
provided for users who wish to build a customized assembler.
";

%feature("docstring")  dolfin::Assembler::assemble_exterior_facets "
Assemble tensor from given form over exterior facets. This
function is provided for users who wish to build a customized
assembler.
";

%feature("docstring")  dolfin::Assembler::assemble_interior_facets "
Assemble tensor from given form over interior facets. This
function is provided for users who wish to build a customized
assembler.
";

// Documentation extracted from: (module=fem, header=SparsityPatternBuilder.h)
%feature("docstring")  dolfin::SparsityPatternBuilder "
This class provides functions to compute the sparsity pattern.
";

%feature("docstring")  dolfin::SparsityPatternBuilder::build "
Build sparsity pattern for assembly of given form
";

// Documentation extracted from: (module=fem, header=SymmetricAssembler.h)
%feature("docstring")  dolfin::SymmetricAssembler "
This class provides implements an assembler for systems
of the form Ax = b. Its assembly algorithms are similar to SystemAssember's,
but it saves the matrix modifications into a separate tensor so that it
can later apply the symmetric modifications to a RHS vector.
The non-symmetric part is only nonzero in BC columns, and is zero in all BC
rows, so that [(A_s+A_n) x = b] implies [A_s x = b - A_n b], IF b has
boundary conditions applied. (If the final A is composed from a sum of
A_s matrices, BCs must be reapplied to make the diagonal value for BC
dofs 1.0. The matrix will remain symmetric since only the diagonal is
changed.)

*Example*
    .. note::
    
        No example code available for this function.
";

%feature("docstring")  dolfin::SymmetricAssembler::assemble "
Assemble A and apply Dirichlet boundary conditions. Returns two
matrices, where the second contains the symmetric modifications
suitable for modifying RHS vectors.

Note: row_bcs and col_bcs will normally be the same, but are different
for e.g. off-diagonal block matrices in a mixed PDE.
";

// Documentation extracted from: (module=fem, header=SystemAssembler.h)
%feature("docstring")  dolfin::SystemAssembler "
This class provides implements an assembler for systems
of the form Ax = b. It differs from the default DOLFIN
assembler in that it assembles both A and b and the same
time (leading to better performance) and in that it applies
boundary conditions at the time of assembly.
";

%feature("docstring")  dolfin::SystemAssembler::assemble "
**Overloaded versions**

* assemble\ (A, b, a, L, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b)

* assemble\ (A, b, a, L, bc, reset_sparsity=true, add_values=true, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b) and apply Dirichlet boundary condition

* assemble\ (A, b, a, L, bcs, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b) and apply Dirichlet boundary conditions

* assemble\ (A, b, a, L, bcs, cell_domains, exterior_facet_domains, interior_facet_domains, x0, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble system (A, b) and apply Dirichlet boundary conditions
";

// Documentation extracted from: (module=fem, header=LinearVariationalProblem.h)
%feature("docstring")  dolfin::LinearVariationalProblem "
This class represents a linear variational problem:

Find u in V such that

    a(u, v) = L(v)  for all v in V^,

where V is the trial space and V^ is the test space.
";

%feature("docstring")  dolfin::LinearVariationalProblem::LinearVariationalProblem "
**Overloaded versions**

* LinearVariationalProblem\ (a, L, u)

  Create linear variational problem without boundary conditions

* LinearVariationalProblem\ (a, L, u, bc)

  Create linear variational problem with a single boundary condition

* LinearVariationalProblem\ (a, L, u, bcs)

  Create linear variational problem with a list of boundary conditions

* LinearVariationalProblem\ (a, L, u, bcs)

  Create linear variational problem with a list of boundary conditions
  (shared pointer version)
";

%feature("docstring")  dolfin::LinearVariationalProblem::bilinear_form "
Return bilinear form
";

%feature("docstring")  dolfin::LinearVariationalProblem::linear_form "
Return linear form
";

%feature("docstring")  dolfin::LinearVariationalProblem::solution "
**Overloaded versions**

* solution\ ()

  Return solution variable

* solution\ ()

  Return solution variable (const version)
";

%feature("docstring")  dolfin::LinearVariationalProblem::bcs "
Return boundary conditions
";

%feature("docstring")  dolfin::LinearVariationalProblem::trial_space "
Return trial space
";

%feature("docstring")  dolfin::LinearVariationalProblem::test_space "
Return test space
";

// Documentation extracted from: (module=fem, header=LinearVariationalSolver.h)
%feature("docstring")  dolfin::LinearVariationalSolver "
This class implements a solver for linear variational problems.
";

%feature("docstring")  dolfin::LinearVariationalSolver::LinearVariationalSolver "
**Overloaded versions**

* LinearVariationalSolver\ (problem)

  Create linear variational solver for given problem

* LinearVariationalSolver\ (problem)

  Create linear variational solver for given problem (shared pointer version)
";

%feature("docstring")  dolfin::LinearVariationalSolver::solve "
Solve variational problem
";

%feature("docstring")  dolfin::LinearVariationalSolver::default_parameters "
Default parameter values
";

// Documentation extracted from: (module=fem, header=NonlinearVariationalProblem.h)
%feature("docstring")  dolfin::NonlinearVariationalProblem "
This class represents a nonlinear variational problem:

Find u in V such that

    F(u; v) = 0  for all v in V^,

where V is the trial space and V^ is the test space.
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::NonlinearVariationalProblem "
**Overloaded versions**

* NonlinearVariationalProblem\ (F, u)

  Create nonlinear variational problem without boundary conditions.
  The Jacobian form is not specified which requires the use of a
  nonlinear solver that does not rely on the Jacobian.

* NonlinearVariationalProblem\ (F, u, J)

  Create nonlinear variational problem without boundary conditions.
  The Jacobian form is specified which allows the use of a nonlinear
  solver that relies on the Jacobian (using Newton's method).

* NonlinearVariationalProblem\ (F, u, bc)

  Create nonlinear variational problem with a single boundary condition.
  The Jacobian form is not specified which requires the use of a
  nonlinear solver that does not rely on the Jacobian.

* NonlinearVariationalProblem\ (F, u, bc, J)

  Create nonlinear variational problem with a single boundary condition.
  The Jacobian form is specified which allows the use of a nonlinear
  solver that relies on the Jacobian (using Newton's method).

* NonlinearVariationalProblem\ (F, u, bcs)

  Create nonlinear variational problem with a list of boundary conditions.
  The Jacobian form is not specified which requires the use of a
  nonlinear solver that does not rely on the Jacobian.

* NonlinearVariationalProblem\ (F, u, bcs, J)

  Create nonlinear variational problem with a list of boundary conditions.
  The Jacobian form is specified which allows the use of a nonlinear
  solver that relies on the Jacobian (using Newton's method).

* NonlinearVariationalProblem\ (F, u, bcs)

  Create nonlinear variational problem, shared pointer version.
  The Jacobian form is not specified which requires the use of a
  nonlinear solver that does not rely on the Jacobian.

* NonlinearVariationalProblem\ (F, u, bcs, J)

  Create nonlinear variational problem, shared pointer version.
  The Jacobian form is specified which allows the use of a nonlinear
  solver that relies on the Jacobian (using Newton's method).
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::residual_form "
Return residual form
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::jacobian_form "
Return Jacobian form
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::solution "
**Overloaded versions**

* solution\ ()

  Return solution variable

* solution\ ()

  Return solution variable (const version)
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::bcs "
Return boundary conditions
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::trial_space "
Return trial space
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::test_space "
Return test space
";

%feature("docstring")  dolfin::NonlinearVariationalProblem::has_jacobian "
Check whether Jacobian has been defined
";

// Documentation extracted from: (module=fem, header=NonlinearVariationalSolver.h)
%feature("docstring")  dolfin::NonlinearVariationalSolver "
This class implements a solver for nonlinear variational problems.
";

%feature("docstring")  dolfin::NonlinearVariationalSolver::NonlinearVariationalSolver "
**Overloaded versions**

* NonlinearVariationalSolver\ (problem)

  Create nonlinear variational solver for given problem

* NonlinearVariationalSolver\ (problem)

  Create nonlinear variational solver for given problem (shared pointer version)
";

%feature("docstring")  dolfin::NonlinearVariationalSolver::solve "
Solve variational problem

*Returns*
    (int, bool)
        Pair of number of Newton iterations, and whether
        iteration converged)
";

%feature("docstring")  dolfin::NonlinearVariationalSolver::default_parameters "
Default parameter values
";

// Documentation extracted from: (module=fem, header=OpenMpAssembler.h)
%feature("docstring")  dolfin::OpenMpAssembler "
This class provides automated assembly of linear systems, or
more generally, assembly of a sparse tensor from a given
variational form.

The MeshFunction arguments can be used to specify assembly over
subdomains of the mesh cells, exterior facets or interior
facets. Either a null pointer or an empty MeshFunction may be
used to specify that the tensor should be assembled over the
entire set of cells or facets.
";

%feature("docstring")  dolfin::OpenMpAssembler::assemble "
**Overloaded versions**

* assemble\ (A, a, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor from given form

* assemble\ (A, a, cell_domains, exterior_facet_domains, interior_facet_domains, reset_sparsity=true, add_values=false, finalize_tensor=true, keep_diagonal=false)

  Assemble tensor from given form on sub domains
";

// Documentation extracted from: (module=fem, header=VariationalProblem.h)
%feature("docstring")  dolfin::VariationalProblem "
This class is deprecated and is only here to give an informative error
message to users about the new interface.
";

%feature("docstring")  dolfin::VariationalProblem::VariationalProblem "
**Overloaded versions**

* VariationalProblem\ (form_0, form_1)

  Deprecated

* VariationalProblem\ (form_0, form_1, bc)

  Deprecated

* VariationalProblem\ (form_0, form_1, bcs)

  Deprecated

* VariationalProblem\ (form_0, form_1, bcs)

  Deprecated
";

%feature("docstring")  dolfin::VariationalProblem::solve "
**Overloaded versions**

* solve\ (u)

  Deprecated

* solve\ (u0, u1)

  Deprecated

* solve\ (u0, u1, u2)

  Deprecated

* solve\ (u, tol, M)

  Deprecated

* solve\ (u, tol, M, ec)

  Deprecated
";

