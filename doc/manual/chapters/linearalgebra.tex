\chapter{Linear algebra}

\dolfin{} does not have its own linear algebra routines, 
but instead use the external package PETSc \cite{www:petsc} 
for linear algebra functionality.    

PETSc is a suite of data structures and routines for the scalable 
(parallel) solution of scientific applications modeled by partial 
differential equations. 
It employs the MPI standard for all message-passing communication.  

For convenience \dolfin{} provide wrappers for some of the most 
common linear algebra functionality. For more advanced usage of 
PETSc, \dolfin{} provide direct access to the PETSc pointers 
to be used with the standard PETSc interface. 

\section{Matrices and Vectors}

The matrix class \texttt{Matrix} provides wrappers for initiating a 
sequential sparse matrix, or a sequential sparse matrix in 
block compressed row format. For parallel matrices one has to use 
the PETSc interface directly. 

The code for initializing a sequential sparse $M\times N$ matrix 
take the form: 
%
\begin{code}
uint M = 100; 
uint N = 100; 
Matrix A(M,N);
\end{code}

Similarly, the vector class \texttt{Vector} allows for a simple 
initialization of a M vector:  
%
\begin{code}
Vector b(M);
\end{code}

Further, wrappers for some basic functionality, such as matrix vector 
multiplication, norms etc., are provided with an intentionally simple interface, 
e.g. matrix vector multiplication: 
%
\begin{code}
Vector Ax;
A.mult(b,Ax);
\end{code} 

For more advanced operations, a pointer to the PETSc matrix and vector is 
accessed by \texttt{mat()} and \texttt{vec()} respectively. 

\section{Matrix-free matrices}

The \dolfin{} class \texttt{VirtualMatrix} represents a matrix-free 
matrix of dimension $M\times M$. 
The matrix-free matrix is a simple wrapper for a PETSc shell matrix. 
The interface is intentionally simple, and for advanced usage the 
PETSc \texttt{Mat} pointer is accessed by the function \texttt{mat()}.  

The class \texttt{VirtualMatrix} enables the use of Krylov subspace
methods for linear systems $Ax = b$, without having to explicitly
store the matrix $A$. All that is needed is that the user-defined
\texttt{VirtualMatrix} implements multiplication with vectors. 
Note that the multiplication operator needs to be defined in terms of
PETSc data structures (\texttt{Vec}), since it will be called from PETSc.

\section{Linear solvers}

A general interface to all linear solvers for systems of the form 
$Ax=b$ is provided through the class \texttt{LinearSolver}. 

In particular, wrappers for a direct LU solver and an iterative 
Krylov GMRES solver are implemented in the classes \texttt{LU} and \texttt{GMRES}. 

To solve the linear system $Ax=b$ using GMRES in \dolfin{}, we simply write:  
%
\begin{code} 
Vec x;
GMRES solver; 
solver.solve(A,x,b);
\end{code} 
%
\dolfin{} also provides a wrapper for an eigenvalue 
solver\index{eigenvalue solver} in PETSc. The following code computes the 
eigenvalues of the matrix $A$,
\begin{code} 
Vector er, ec;
EigenvalueSolver esolver; 
esolver.eigen(A,er,ec);
\end{code} 
The real components of the eigenvalues are returned in the vector \texttt{er} and
the complex components of the eigenvalues are returned in the vector \texttt{ec}.
The procedure for computing the eigenvalues of a matrix is computationally 
intensive and should only be used for relatively small matrices.


\section{Preconditioning}

The \texttt{Preconditioner} class specifies the interface for user-defined 
Krylov method preconditioners. To implement our own preconditioner we only 
need to supply a function that approximately solves the linear system given 
a right-hand side.

As a complement to PETSc, \dolfin{} also uses Hypre \cite{www:hypre}, which is a 
library for solving large, sparse linear systems of equations on 
massively parallel computers. 

To use a preconditioner from Hypre with our PETSc solver in \dolfin{}, we write:  
%
\begin{code}
PCSetType(PC pc, PCHYPRE );
PCHYPRESetType(PC pc,"boomeramg");
\end{code}

In particular, the above preconditioner \texttt{boomeramg} is an algebraic multigrid 
preconditioner, which is very useful. 

