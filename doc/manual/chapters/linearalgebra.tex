\chapter{Linear algebra}

\dolfin{} does not have its own linear algebra routines, 
but instead uses the external package PETSc \cite{www:petsc} 
for linear algebra functionality.    

PETSc is a suite of data structures and routines for the scalable 
(parallel) solution of scientific applications modeled by partial 
differential equations. 
It employs the MPI standard for all message-passing communication.  

For convenience \dolfin{} provides wrappers for some of the most 
common linear algebra functionality. For more advanced usage, 
\dolfin{} provides direct access to the PETSc pointers 
to be used with the standard PETSc interface. 

\section{Matrices and Vectors}

The matrix class \texttt{Matrix} provides wrappers for initializing 
a sequential sparse matrix, or a sequential sparse matrix in 
block compressed row format. For parallel matrices the PETSc 
interface has to be used directly. 

The code for initializing a sequential sparse $M\times N$ matrix 
takes the form: 
%
\begin{code}
uint M = 100; 
uint N = 100; 
Matrix A(M,N);
\end{code}

Similarly, the vector class \texttt{Vector} allows for a simple 
initialization of a M vector:  
%
\begin{code}
Vector b(M);
\end{code}

Further, wrappers for some basic linear algebra functionality, such as matrix vector 
multiplication, norms etc., are provided with an intentionally simple interface, 
for exmple, matrix vector multiplication is defined by: 
%
\begin{code}
Vector Ax;
A.mult(b,Ax);
\end{code} 

For more advanced operations, a pointer to the PETSc matrix and vector is 
accessed by \texttt{mat()} and \texttt{vec()} respectively. 

\section{Matrix-free matrices}

The \dolfin{} class \texttt{VirtualMatrix} represents a matrix-free 
matrix of dimension $M\times M$. 
The matrix-free matrix is a simple wrapper for a PETSc shell matrix. 
The interface is intentionally simple, and for advanced usage the 
PETSc \texttt{Mat} pointer is accessed by the function \texttt{mat()}.  

The class \texttt{VirtualMatrix} enables the use of Krylov subspace
methods for linear systems $Ax = b$, without having to explicitly
store the matrix $A$. All that is needed is that the user-defined
\texttt{VirtualMatrix} implements multiplication with vectors. 
Note that the multiplication operator needs to be defined in terms of
PETSc data structures (\texttt{Vec}), since it will be called from PETSc.

\section{Linear solvers}

A general interface to all linear solvers for systems of the form 
$Ax=b$ is provided through the class \texttt{LinearSolver}. 

In particular, wrappers for a direct LU solver and an iterative 
Krylov GMRES solver are implemented in the classes \texttt{LU} and \texttt{GMRES}. 

To solve the linear system $Ax=b$ using GMRES in \dolfin{}, simply write:  
%
\begin{code} 
Vec x;
GMRES solver; 
solver.solve(A,x,b);
\end{code} 
%
\dolfin{} also provides a wrapper for an eigenvalue 
solver\index{eigenvalue solver} in PETSc. The following code computes the 
eigenvalues of the matrix $A$,
\begin{code} 
Vector er, ec;
EigenvalueSolver esolver; 
esolver.eigen(A,er,ec);
\end{code} 
The real components of the eigenvalues are returned in the vector \texttt{er} and
the complex components of the eigenvalues are returned in the vector \texttt{ec}.
The procedure for computing the eigenvalues of a matrix is computationally 
intensive and should only be used for relatively small matrices.


\section{Preconditioning}

The \texttt{Preconditioner} class specifies the interface for user-defined 
Krylov method preconditioners. To implement our own preconditioner we only 
need to supply a function that approximately solves the linear system given 
a right-hand side.

To change the default preconditioner in the \dolfin{} GMRES solver, edit the 
constructor of the \texttt{GMRES} class. For example, to choose the 
ILU preconditioner for GMRES we write 
%
\begin{code}
PC pc;
KSPGetPC(ksp, &pc);
PCSetType(pc, PCILU);
\end{code}

As a complement to the preconditioners avaliable in PETSc, 
\dolfin{} also uses Hypre \cite{www:hypre}, which is a 
library for solving large, sparse linear systems of equations on 
massively parallel computers. 

To use a preconditioner from Hypre together with a PETSc solver in \dolfin{}, we write:  
%
\begin{code}
PCSetType(PC pc, PCHYPRE );
PCHYPRESetType(PC pc,"boomeramg");
\end{code}

In particular, the above preconditioner \texttt{boomeramg} is an algebraic multigrid 
preconditioner, which is very useful. 

