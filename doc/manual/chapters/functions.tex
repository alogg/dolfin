\chapter{Functions}
\index{functions}
\index{Function}

The central concept of a function on a domain $\Omega \subset \R^d$ is
modeled by the class \texttt{Function}, which is used in \dolfin{} to
represent coefficients or solutions of partial differential equations.

%------------------------------------------------------------------------------
\section{Basic properties}

The following basic properties hold for all \texttt{Function}s:
\begin{itemize}
\item
  A \texttt{Function} can be scalar or vector-valued;
\item
  A \texttt{Function} can be evaluated at each \texttt{Vertex} of a \texttt{Mesh};
\item
  A \texttt{Function} can be restricted to each local \texttt{Cell} of a \texttt{Mesh};
\item
  The underlying representation of a \texttt{Function} may vary.
\end{itemize}

Depending on the actual underlying representation of a \texttt{Function}, it
may also be possible to evaluate a \texttt{Function} at any given \texttt{Point}.

\subsection{Representation}

Currently supported representations of \texttt{Function}s include
\emph{discrete} \texttt{Function}s and \emph{user-defined}
\texttt{Function}s. These are discussed in detail below.

\subsection{Evaluation}

All \texttt{Function}s can be evaluated at the \texttt{Vertices} of a
\texttt{Mesh}. The following example illustrates how to evaluate a
scalar \texttt{Function} at each \texttt{Vertex} of a given
\texttt{Mesh}:
\begin{code}
  Function u;
  Mesh mesh;

  for (VertexIterator vertex(mesh); !vertex.end(); ++vertex)
    cout << ``Value at vertex `` << *vertex << ``: ``
         << u(*vertex) << endl;
\end{code}

If the \texttt{Function} is vector-valued, an additional argument is
needed to specify the component.  The following example illustrates
how to evaluate all components of a vector-valued \texttt{Function}
at all each \texttt{Vertex} of a given \texttt{Mesh}:
\begin{code}
  Function u;
  Mesh mesh;

  for (VertexIterator vertex(mesh); !vertex.end(); ++vertex)
    for (unsigned int i = 0; i < u.vectordim(); i++)
      cout << ``Value of component `` << i << `` at vertex ``
           << *vertex << ``: `` << u(*vertex, i) << endl;
\end{code}

If allowed by the underlying representation, a \texttt{Function}
\texttt{u} may also be evaluated directly at any given \texttt{Point}:
\begin{code}
  Point p(0.5, 0.5, 0.5);
  cout << ``Value at p = `` << p << ``: `` << u(p) << endl;
\end{code}
As in the case of evaluation at a \texttt{Vertex}, the component index
may be given as an additional argument for a vector-valued \texttt{Function}.

\subsection{Assignment}

One \texttt{Function} may be assigned to another \texttt{Function}:
\begin{code}
  Function v;
  Function u = v;
\end{code}
Assignment creates a new \texttt{Function} sharing the same data.  In
particular, this means that modifying the data of one of the two
\texttt{Function}s will also affect the other \texttt{Function}.

\subsection{Components and sub functions}

If a \texttt{Function} is vector-valued, a new \texttt{Function} may be
created to represent any given component of the original \texttt{Function},
as illustrated by the following example:
\begin{code}
  Function u;         // Function with three components
  Function u0 = u[0]; // first component
  Function u1 = u[1]; // second component
  Function u2 = u[2]; // third component
\end{code}

If a \texttt{Function} represents a \emph{mixed} function (one defined in terms
of a mixed \texttt{FiniteElement}, see below), then indexing has the effect of
picking out sub functions. With \texttt{w} a \texttt{Function} representing the
solution $w = (u, p)$ of a Stokes or Navier-Stokes system (with $u$ the vector-valued
velocity and $p$ the scalar pressure), the following example illustrates how to
pick sub functions and components of \texttt{w}:
\begin{code}
  Function w;  // mixed Function (u, p)
  u = w[0];    // first sub function (velocity)
  p = w[1];    // second sub function (pressure)
  u[0] = u[0]; // first component of the velocity
  u[1] = u[1]; // second component of the velocity
  u[2] = u[2]; // third component of the velocity
\end{code}

Note that picking a component or sub function creates a new
\texttt{Function} that shares data with the original \texttt{Function}.

\subsection{Output}
\index{ParaView}
\index{MayaVi}

A \texttt{Function} can be written to a file in various file formats.
To write a \texttt{Function}~\texttt{u} to file in VTK~format,
suitable for viewing in ParaView or MayaVi, create a file with
extension \texttt{.pvd}:
\begin{code}
  File file(``solution.pvd'');
  file << u;
\end{code}

For further details on available file formats, see
Chapter~\ref{chapter:io}.

%------------------------------------------------------------------------------
\section{Discrete functions}

A \emph{discrete} \texttt{Function} is defined in terms of a \texttt{Vector} of nodal
values (degrees of freedom), a \texttt{Mesh} and
a \texttt{FiniteElement} specifying the distribution of the nodal values
on the \texttt{Mesh}. In particular, a discrete \texttt{Function}
is given by a linear combinations of basis functions:
\begin{equation}
  v = \sum_{i=1}^{N} v_i \phi_{i},
\end{equation}
where $\{\phi_i\}_{i=1}^N$ is the global basis of the finite element
space defined by the \texttt{Mesh} and the \texttt{FiniteElement}, and
the nodal values $\{v_i\}_{i=1}^N$ are given by the values of a
\texttt{Vector}.

Note that a \emph{discrete} \texttt{Function} may not be evaluated at
arbitrary points (only at each \texttt{Vertex} of a \texttt{Mesh}).

\subsection{Creating a discrete function}

A discrete \texttt{Function} can be initialized in several ways.
In the simplest case, only a \texttt{Vector} \texttt{x} of nodal
values needs to be specified:
\begin{code}
  Vector x;

  Function u(x);
\end{code}
If possible, \dolfin{} will then automatically try to determine the
\texttt{Mesh} and the \texttt{FiniteElement}.

In some cases, it is necessary to also supply a \texttt{Mesh}
when initializing a discrete \texttt{Function}:
\begin{code}
  Vector x;
  Mesh mesh;

  Function u(x, mesh);
\end{code}
If possible, \dolfin{} will then automatically try to determine the
\texttt{FiniteElement}.

In general however, a discrete \texttt{Function} must be initialized
from a given \texttt{Vector}, a \texttt{Mesh}
and a \texttt{FiniteElement}:
\begin{code}
  Vector x;
  Mesh mesh;
  FiniteElement element;

  Function u(x, mesh, element);
\end{code}

\subsection{Accessing discrete function data}

It is possible to access the data of a discrete \texttt{Function},
including the associated \texttt{Vector}, \texttt{Mesh}
and \texttt{FiniteElement}:
\begin{code}
  Vector& x              = u.vector();
  Mesh& mesh             = u.mesh();
  FiniteElement& element = u.element();
\end{code}

\subsection{Attaching discrete function data}

After a discrete \texttt{Function} has been initialized, it is
possible to associate or reassociate data with the \texttt{Function}:
\begin{code}
  Vector x;
  Mesh mesh;
  FiniteElement element;

  Function u(x);
  u.attach(mesh);
  u.attach(element);
\end{code}

Usually, the \texttt{FiniteElement} is given by the
\texttt{BilinearForm} defining the problem. Considering the Poisson
example in Chapter~\ref{chap:quickstart}, a \texttt{Function}
\texttt{u} representing the solution can be initialized as follows:
\begin{code}
  Vector x;
  Mesh mesh;
  Function u(x, mesh);

  Poisson::BilinearForm a;

  FiniteElement& element = a.trial();
  u.attach(element); 
\end{code}
In this example, the \texttt{Function}~\texttt{u} represents a
function in the trial space for the \texttt{BilinearForm}~\texttt{a}.

%------------------------------------------------------------------------------
\section{User-defined functions}
\index{user-defined functions}

In the simplest case, a user-defined \texttt{Function} is just an
expression in terms of the coordinates and is typically used for
defining source terms and initial conditions. For example, a source
term could be given by
\begin{equation} \label{eq:functionexample}
  f = f(x, y, z) = xy \sin(z / \pi).
\end{equation}

There are two ways to create a user-defined \texttt{Function}; either
by creating a sub class of \texttt{Function} or by creating a
\texttt{Function} from a given function pointer.

\subsection{Creating a sub class}

A user-defined \texttt{Function} may be defined by creating a sub
class of \texttt{Function} and overloading the \texttt{eval()}
function.  The following example illustrates how to create a
\texttt{Function} representing the function in
(\ref{eq:functionexample}):
\begin{code}
  class Source : public Function
  \{
    real eval(const Point& p, unsigned int i)
    \{
      return x*y*sin(z / DOLFIN_PI);
    \}
  \};

  Source f;
\end{code}

To create a vector-valued \texttt{Function}, the vector dimension must
be supplied to the constructor of \texttt{Function}:
\begin{code}
  class Source : public Function
  \{
  public:

    Source() : Function(3) \{\}

    real eval(const Point& p, unsigned int i)
    \{
      if ( i == 0 )
        return 0.0;
      else if ( i == 1 )
        return x*y*sin(z / DOLFIN_PI);
      else
        return x + y;
    \}
  \};

  Source f;
\end{code}

\subsection{Specifying a function-pointer}

A user-defined \texttt{Function} may alternatively be defined by
specifying a function pointer. The following example illustrates
an alternative way of creating a \texttt{Function} representing the
function in (\ref{eq:functionexample}):
\begin{code}
  real source(const Point& p, unsigned int i)
  \{
    return x*y*sin(z / DOLFIN_PI);
  \}

  Function f(source);
\end{code}

As before, for vector-valued \texttt{Function}s, the vector dimension
must be supplied to the constructor of \texttt{Function}:
\begin{code}
  real source(const Point& p, unsigned int i)
  \{
    if ( i == 0 )
      return 0.0;
    else if ( i == 1 )
      return x*y*sin(z / DOLFIN_PI);
    else
      return x + y;
  \}
  
  Function f(source, 3);
\end{code}

\subsection{Cell-dependent functions}

In some cases, it may be convenient to define a \texttt{Function} in
terms of properties of the current \texttt{Cell}. One such example is
a \texttt{Function} that at any given point takes the value of the
mesh size at that point.

The following example illustrates how to create such as
\texttt{Function} by overloading the \texttt{eval()} function:
\begin{code}
  class MeshSize : public Function
  \{
    real eval(const Point& p, unsigned int i)
    \{
      return cell().diameter();
    \}
  \}

  MeshSize h;
\end{code}

Note that the current \texttt{Cell} is only available during assembly
and has no meaning otherwise. It is thus not possible to write the
\texttt{Function}~\texttt{h} to file, since the current \texttt{Cell}
is not available when evaluating a \texttt{Function} at any given
\texttt{Vertex}. Furthermore, note that the current \texttt{Cell} is
not available when creating a \texttt{Function} from a function pointer.

%------------------------------------------------------------------------------
\section{Time-dependent functions}

\devnote{Write about time-dependent and pseudo time-dependent functions.}
