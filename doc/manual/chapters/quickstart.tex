\chapter{Quickstart}
\label{chap:quickstart}
\index{quickstart}

This chapter demonstrates how to get started with \dolfin{}, including
downloading and installing the latest version of \dolfin{}, and solving
Poisson's equation. These topics are discussed in more detail
elsewhere in this manual. In particular, see
Appendix~\ref{app:installation} for detailed installation instructions
and Chapter~\ref{sec:pde} for a detailed discussion of how to solve
partial differential equations with \dolfin{}.

%------------------------------------------------------------------------------
\section{Downloading and installing \dolfin{}}
\index{downloading}
\index{installation}

The latest version of \dolfin{} can be found on the \fenics{} web page:
\begin{code}
http://www.fenics.org/
\end{code}
The following commands illustrate the installation process, assuming
that you have downloaded release x.y.z of \dolfin{}:
\begin{code}
# tar zxfv dolfin-x.y.z.tar.gz
# cd dolfin-x.y.z
# sudo scons install
\end{code}

Since \dolfin{} depends on a number of other packages, you may also
need to download and install those packages before you can compile
\dolfin{}. (See Appendix~\ref{app:installation} for detailed
instructions.)

%------------------------------------------------------------------------------
\section{Solving Poisson's equation with \dolfin{}}
\index{Poisson's equation}

Let's say that we want to solve Poisson's equation on the unit square
$\Omega = (0,1) \times (0,1)$ with homogeneous Dirichlet boundary
conditions on the boundary $\Gamma = \{(x, y) \in \partial \Omega : x = 0 \mbox{ or } x = 1\}$,
homogeneous Neumann boundary conditions $\partial_n u = 0$ on the remaining part of the boundary,
and right-hand side given by $f(x, y) = 500 \exp(-((x-0.5)^2 + (y-0.5)^2)/0.02)$:
\begin{eqnarray} \label{eq:poisson,quickstart}
  - \Delta u(x, y) &=& f(x, y), \quad
  x \in \Omega = (0,1) \times (0,1), \\
  u(x, y) &=& 0, \quad
  (x, y) \in \Gamma = \{(x, y) \in \partial \Omega : x = 0 \mbox{ or } x = 1\}, \\
  \partial_n u(x, y) &=& 0, \quad
  (x, y) \in \partial \Omega \setminus \Gamma.
\end{eqnarray}

% FIXME: Explain this better

To solve a partial differential equation with \dolfin{}, it must first
be written in \emph{variational form}.  The (discrete) variational
formulation of Poisson's equation reads: Find $u_h \in V_h$ such that
\begin{equation} \label{eq:varform}
  a(v, u_h) = L(v) \quad \forall v\in \hat{V}_h, 
\end{equation}
with $(\hat{V}_h, V_h)$ a pair of suitable discrete function spaces
(the test and trial spaces). The bilinear form $a : \hat{V}_h \times V_h
\rightarrow \R$ is given by
\begin{equation}
  a(v, u_h) = \int_{\Omega} \nabla v \cdot \nabla u_h \dx
\end{equation}
and the linear form $L : \hat{V}_h \rightarrow \R$ is given by
\begin{equation}
  L(v) = \int_{\Omega} v f \dx.
\end{equation}

\subsection{Setting up the variational formulation}
\index{ffc}

The variational formulation (\ref{eq:varform}) must be given to
\dolfin{} as a pair of bilinear and linear forms $(a, L)$ using a
form compiler like \ffc{}. This is done by entering the definition of
the forms in a text file with extension \texttt{.form},
e.g., \texttt{Poisson.form}, as follows:
\begin{code}
element = FiniteElement("Lagrange", "triangle", 1)

v = TestFunction(element)
u = TrialFunction(element)
f = Function(element)

a = dot(grad(v), grad(u))*dx
L = v*f*dx
\end{code}

The example is given here for piecewise linear finite elements in two
dimensions, but other choices are available, including arbitrary order
Lagrange elements in two and three dimensions.

To compile the pair of forms $(a, L)$, now call the form compiler on
the command-line as follows:
\begin{code}
# ffc -l dolfin Poisson.form
\end{code}
This generates the file \texttt{Poisson.h} which implements the forms
in C++ for inclusion in your \dolfin{} program.

\subsection{Writing the solver}

Having compiled the variational formulation (\ref{eq:varform}) with
\ffc{}, it is now easy to implement a solver for Poisson's
equation. We first discuss the implementation line by line and then
present the complete program. The source code for this example is
available in the directory \texttt{demo/pde/poisson/cpp/} of the
\dolfin{} source tree.\footnote{A corresponding Python demo is available in \texttt{demo/pde/poisson/python/}}

At the beginning of our C++ program, which we write in a text file
named \texttt{main.cpp}, we must first include the header file
\texttt{dolfin.h}, which gives our program access to the \dolfin{}
class library. In addition, we include the header file
\texttt{Poisson.h} generated by the form compiler. Since all classes
in the \dolfin{} class library are defined within the namespace
\texttt{dolfin}, we also specify that we want to work within this
namespace:
\begin{code}
#include <dolfin.h>
#include "Poisson.h"
  
using namespace dolfin;
\end{code}

Since we are writing a C++ program, we need to create a \texttt{main}
function.  You are free to organize your program any way you like, but
in this simple example we just write our program inside the
\texttt{main} function:

\begin{code}
// Include headers and define classes here

int main()
{
  // Write your program here
  return 0;
}
\end{code}

We now proceed to specify the right-hand side $f$ of
(\ref{eq:poisson,quickstart}). This is done by defining a new subclass
of \texttt{Function} (which we here name \texttt{Source}) and
by overloading the \texttt{eval()} function to return the value $f(x, y)
= 500 \exp(-((x-0.5)^2 + (y-0.5)^2)/0.02)$:
\begin{code}
class Source : public Function
{
  void eval(double* values, const double* x) const
  {
    double dx = x[0] - 0.5;
    double dy = x[1] - 0.5;
    values[0] = 500.0*exp(-(dx*dx + dy*dy) / 0.02);
  }
};
\end{code}

To define the Dirichlet boundary condition, we define a
\texttt{SubDomain} for the Dirichlet boundary:
\begin{code}
class DirichletBoundary : public SubDomain
{
  bool inside(const double* x, bool on_boundary) const
  {
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS;
  }
};
\end{code}

Next, we need to create a mesh. \dolfin{} relies on external programs
for mesh generation, and imports meshes in \dolfin{} XML
format. Meshes in other formats can be converted to the \dolfin{} XML
format using the script \texttt{dolfin-convert}. However, for simple
domains like the unit square or unit cube, \dolfin{} provides a
built-in mesh generator. To generate a uniform mesh of the unit square
with mesh size $1/32$ (with a total of $2\cdot 32^2 = 2048$
triangles), we can just type
\begin{code}
UnitSquare mesh(32, 32);
\end{code}

Next, we instantiate a finite element function space on the mesh as follows:
\begin{code}
PoissonFunctionSpace V(mesh);
\end{code}
Here, we make use of the code generated by the form compiler (the
class \texttt{PoissonFunctionSpace}).

Next, we define the Dirichlet boundary condition by specifying the
value that the solution should take and the subset of the boundary
where it should be applied:
\begin{code}
Constant u0(0.0);
DirichletBoundary boundary;
DirichletBC bc(V, u0, boundary);
\end{code}
Note the difference in how Dirichlet and Neumann boundary conditions
are applied. Dirichlet conditions are here applied strongly (but may
also be applied weakly) using the \texttt{DirichletBC} class,
while Neumann boundary conditions are defined as part of the
variational problem. (It is a \emph{natural} boundary condition for
this variational formulation of Poisson's equation.)

Next, we initialize the pair of bilinear and linear forms that we have
previously compiled with \ffc{}. We also instantiate the right-hand
side function and attach it to the linear form:
\begin{code}
PoissonBilinearForm a(V, V);
PoissonLinearForm L(V);
Source f;
L.f = f;
\end{code}

To solve the variational problem, we use the class
\texttt{VariationalProblem}, which automatically assembles and solves
the corresponding linear system:
\begin{code}
VariationalProblem problem(a, L, bc);
Function u;
problem.solve(u);
\end{code}

To plot the solution, one may simply type
\begin{code}
plot(u);
\end{code}
This requires the installation of PyDOLFIN and Viper. (A warning will
be issued if plotting is not available.)

Finally, we export the solution \texttt{u} to a file for
visualization. Here, we choose to save the solution in VTK format for
visualization in ParaView or MayaVi, which we do by specifying a file
name with extension \texttt{.pvd}:
\begin{code}
File file("poisson.pvd");
file << u;
\end{code}

The complete program for Poisson's equation now looks as follows:
\small
\begin{code}
#include <dolfin.h>
#include "Poisson.h"

using namespace dolfin;

// Source term
class Source : public Function
{
  void eval(double* values, const double* x) const
  {
    double dx = x[0] - 0.5;
    double dy = x[1] - 0.5;
    values[0] = 500.0*exp(-(dx*dx + dy*dy) / 0.02);
  }
};

// Sub domain for Dirichlet boundary condition
class DirichletBoundary : public SubDomain
{
  bool inside(const double* x, bool on_boundary) const
  {
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS;
  }
};

int main()
{
  // Create mesh and function space
  UnitSquare mesh(32, 32);
  PoissonFunctionSpace V(mesh);

  // Define boundary condition
  Constant u0(0.0);
  DirichletBoundary boundary;
  DirichletBC bc(V, u0, boundary);

  // Define variational problem
  PoissonBilinearForm a(V, V);
  PoissonLinearForm L(V);
  Source f;
  L.f = f;

  // Compute solution
  VariationalProblem problem(a, L, bc);
  Function u;
  problem.solve(u);

  // Plot solution
  plot(u);

  // Save solution in VTK format
  File file("poisson.pvd");
  file << u;

  return 0;
}
\end{code}
\normalsize

\subsection{Compiling the program}

The easiest way to compile the program is to create a
\texttt{SConstruct} file that tells \texttt{scons} how to build the
program.  The following example shows how to write a
\texttt{SConstruct} file for the above example:
\footnotesize
\begin{code}
import os, commands

# Get compiler from pkg-config
compiler = commands.getoutput('pkg-config --variable=compiler dolfin')

# Create a SCons Environment based on the main os environment
env = Environment(ENV=os.environ, CXX=compiler)

# Get compiler flags from pkg-config
env.ParseConfig('pkg-config --cflags --libs dolfin')

# Program name
env.Program('demo', 'main.cpp')
\end{code}
\normalsize

With this file in place, we just need to type
\texttt{scons} to compile the program, generating the executable as the
file \texttt{demo}. Note that this requires \texttt{pkg-config} to be
able to find the file \texttt{dolfin.pc}. That file is generated by
the \texttt{configure} script during the configuration of
\dolfin{}. If \texttt{pkg-config} fails to find it, you need to add
the directory containing it to the environment variable
\texttt{PKG\_CONFIG\_PATH}.

\subsection{Running the program}

To run the program, simply type the name of the executable:
\begin{code}
# ./demo
\end{code}

\subsection{Visualizing the solution}

The solution may be visualized either by the built-in \texttt{plot()}
command or by calling an external application. The built-in plotting
requires the installation of both PyDOLFIN and Viper. In this
example, we chose to save the solution in VTK format, which can be
imported into for example ParaView or MayaVi.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=10cm]{eps/poisson.eps}
    \caption{The solution of Poisson's equation
      (\ref{eq:poisson,quickstart}) visualized using the \texttt{plot()}
      command (Viper).}
  \end{center}
\end{figure}
