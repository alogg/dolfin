// This code conforms with the UFC specification version 1.0
// and was automatically generated by FFC version 0.7.1.
//
// Warning: This code was generated with the option '-l dolfin'
// and contains DOLFIN-specific wrappers that depend on DOLFIN.

#ifndef __FORMS_H
#define __FORMS_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>
    
/// This class defines the interface for a finite element.

class forms_0_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  forms_0_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_0_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Reset values
    values[0] = 0;
    values[1] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];
    
    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Compute number of derivatives
    unsigned int num_derivatives = 1;
    
    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;
    
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    static const double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    
    static const double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175274, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.30940107675851, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756887, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5.00000000000001, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};
    
    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];
    
    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;
    
    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;
    
    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];
    
      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;
    
        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }
    
      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }
    
    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }
    
    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    static const double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    static const double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    static const double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];
      
      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];
      
      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);
      
      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola 
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];
    
      // Note that we do not map the weights (yet).
    
      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];
    
    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new forms_0_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class forms_0_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  forms_0_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_0_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Reset values
    values[0] = 0;
    values[1] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];
    
    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Compute number of derivatives
    unsigned int num_derivatives = 1;
    
    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;
    
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    static const double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    
    static const double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175274, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.30940107675851, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756887, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5.00000000000001, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};
    
    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];
    
    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;
    
    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;
    
    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];
    
      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;
    
        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }
    
      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }
    
    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }
    
    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    static const double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    static const double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    static const double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];
      
      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];
      
      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);
      
      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola 
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];
    
      // Note that we do not map the weights (yet).
    
      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];
    
    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new forms_0_finite_element_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class forms_0_dof_map_0: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  forms_0_dof_map_0() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~forms_0_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new forms_0_dof_map_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class forms_0_dof_map_1: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  forms_0_dof_map_1() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~forms_0_dof_map_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new forms_0_dof_map_1();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class forms_0_cell_integral_0_quadrature: public ufc::cell_integral
{
public:

  /// Constructor
  forms_0_cell_integral_0_quadrature() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_0_cell_integral_0_quadrature()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    
    // Array of quadrature weights
    static const double W9[9] = {0.0558144204830443, 0.063678085099885, 0.0193963833059595, 0.0893030727728709, 0.101884936159816, 0.0310342132895351, 0.0558144204830443, 0.063678085099885, 0.0193963833059595};
    // Quadrature points on the UFC reference element: (0.102717654809626, 0.088587959512704), (0.0665540678391645, 0.409466864440735), (0.0239311322870806, 0.787659461760847), (0.455706020243648, 0.088587959512704), (0.295266567779633, 0.409466864440735), (0.106170269119576, 0.787659461760847), (0.80869438567767, 0.088587959512704), (0.523979067720101, 0.409466864440735), (0.188409405952072, 0.787659461760847)
    
    // Value of basis functions at quadrature points.
    static const double FE0_C0_D01[9][15] = \
    {{-0.632234065853992, 0.369377026105217, -1.19666027510339, 1.29644912275629, -1.6978071399098, 0.532445218201102, -11.4264574934774, 6.42684293955393, -1.92413966611943, 7.72759793934033, -15.0335463595925, -10.1536650688121, 1.87868388360728, 2.92784719045042, 3.32107528451145},
    {0.450621756164914, -0.577937279558468, 2.5906885818127, -1.88275877577321, 3.44221131877507, -1.1585515622044, 0.79690388516117, 0.719388048157267, 0.412211200346585, 0.756420301692758, 6.54374394890768, 15.5304795642209, -4.05069519261328, -2.34613603538014, -7.1606850980415},
    {-1.19265564113958, 5.83168392912962, -7.71192687135928, 2.34446535106554, -8.13530334898153, 6.56011716143332, 1.30580542077409, -0.218779538961619, -0.622387040332554, -5.00283340362406, 7.12726695117509, -5.92252774573894, 3.25780982610061, -2.64186899150162, 5.75904854962978},
    {0.774293014515853, 0.356230878553266, -0.363260944923049, -0.936904214017929, -0.0310084795491136, 0.525872144425125, -3.12587745398555, -1.4608973179406, -2.33697944811675, 10.8767407876972, 4.41177922298695, -8.78657643109809, -0.459933927459188, -4.34652721259017, -0.813055997510381},
    {0.477448099138993, -1.87181344290682, 1.57168345691846, -0.243641912178878, 1.40420106898659, -1.80548964387857, 2.7516962865611, -1.94783316897006, 1.12464001607398, -2.47654960623606, 5.64173410591793, 11.6756774171499, 0.661303761131473, 0.876059078015201, 1.16903093480058},
    {-1.55786356263444, 4.82170501333315, -8.73903475689337, 4.24177061599273, -10.1895191200497, 6.05512770353508, 0.557854636812207, -0.1422899212526, 0.0490741259203074, -8.40019118146109, 1.08109900546648, -9.31767241462322, 7.59123551001619, 1.87980922966477, 13.4195352667914},
    {-2.67861056425382, 2.5858988813734, -0.651268689928746, 1.68917310834738, -0.607023969560508, 1.64070614583519, 2.18428371834352, -3.36779984110958, -5.74023809727685, 8.73951998715651, 14.1454346546192, -5.55047600140736, -2.79855173852566, 7.80243868626364, -4.94718727953222},
    {-1.53579245541866, -2.22412026893284, 0.0818936633630525, 3.43554184894719, -1.57537851812422, -1.98164305689158, 3.45106290486458, -2.1042028199045, 0.581643048704934, -7.9288197254247, 0.662609435200075, 8.60551638451415, 5.37330271487622, 12.2524838468668, 9.49874696764265},
    {-2.1868392335805, 3.93346505882185, -9.82701212307005, 6.40284363037112, -12.3654738524031, 5.61100772627943, -0.35241476219657, 0.258836926550208, 0.558216677126273, -12.0844904428293, -5.49221410575857, -12.6113679491032, 11.9246611939318, 7.45577778186406, 21.0800219839531}};
    
    static const double FE0_C1_D10[9][15] = \
    {{0.833958106518305, -0.248476303243519, 0.672534306807887, -11.0010930637093, 6.46321160026467, -1.80102704350557, 1.18562346013306, -1.27465460989387, 0.320868953193131, 1.45123527867797, 3.81654367282211, 1.47955601738169, 7.18546693660842, -14.3373441890113, -8.47707093387244},
    {0.939553962878538, -0.598810235338612, -0.842870927797272, -4.98632956780218, -0.456138552432833, -2.42915346537407, -0.804073553784224, -0.676404983364709, 0.900756588865491, 0.109735545027426, -2.27893701238928, -4.33520843283794, 11.8422691008775, -9.59434017356345, 7.21162196823798},
    {1.73507138753721, -3.8393987678556, 1.85675069489759, 0.342715451608516, -3.60574038373568, -6.56618991268318, 0.518203953231016, -1.16230528452246, 3.07361812920378, -3.78598191187036, -4.96029995637389, 4.79397587144443, 14.2507352472592, -3.57901595241975, 20.2576306156281},
    {-2.06270112434423, 0.452423144535827, -0.504741673486154, 1.90008992484216, -0.127200745531676, 0.66735287298823, -1.6781704018496, 2.79928060126272, -0.88927239598079, -3.31895764425959, -6.37896538917659, 0.68559512985722, -0.459933927459185, 17.2349620117369, -0.813055997510383},
    {-1.80643419655316, 1.95006368945172, -0.451364683624025, 2.04024038351328, -2.41767606337196, 0.21755849666391, -0.315371304845038, 1.67807693189375, -1.94242757533215, 0.384647361324375, 1.11160651955337, 0.565425182101362, 0.661303761131468, 9.93631425074433, 1.16903093480058},
    {0.379339402530058, -2.03513989521205, 2.48671860200814, 2.30456765082823, -3.33267421150453, -5.17062565536642, 1.68741925771504, -0.43654120662586, 1.17863874682315, -2.26075994619043, 0.495382154892647, 8.85102050436794, 7.59123551001619, 3.05124293081242, 13.4195352667914},
    {9.61893162221177, -5.57511985880107, 1.68220357177793, 0.22298093597509, 0.0108293597882292, -0.228488436076089, 4.42929233765608, -11.0692973905574, 6.87184285633362, 7.7699403794953, 12.5605360016663, -5.71540113359748, -8.10533479152681, -9.46275269319802, 6.85095893885168},
    {1.56777833661031, 1.67422960227506, 1.35249556653272, 2.94660964223357, -1.55450556234408, 1.45191645271839, 3.93960829338349, -3.49999585142648, -1.01933439024046, 7.31745981140079, 16.7334945346803, 3.11213545373482, -10.5196615786146, 5.00427970868346, -4.87356009863681},
    {-0.185089334123479, -0.596097906424005, 3.29929495104645, 3.47511660169434, -2.69439115541786, -3.95766983997743, 3.34359040733976, -0.684688819010631, -0.229384790416792, 0.125286470083018, 7.53249976270851, 12.6037177340785, 0.931735772773168, 6.51863082094593, 6.58143991795474}};
    
    
    // Number of operations to compute geometry constants: 24
    const double G0 = (Jinv_00*Jinv_11*det*(Jinv_00*Jinv_11-2*Jinv_01*Jinv_10) + Jinv_01*Jinv_01*Jinv_10*Jinv_10*det);
    const double G1 = (Jinv_00*Jinv_11*det*(2*Jinv_01*Jinv_10-Jinv_00*Jinv_11)-Jinv_01*Jinv_01*Jinv_10*Jinv_10*det);
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('simplify expressions', True), ('ignore zero tables', True), ('non zero columns', True), ('remove zero terms', True), ('ignore ones', True)
    // Total number of operations to compute element tensor: 24342
    
    // Loop quadrature points for integral
    // Number of operations to compute element tensor for following IP loop = 24318
    for (unsigned int ip = 0; ip < 9; ip++)
    {
      
      // Number of operations to compute ip constants: 2
      // Number of operations: 1
      const double Gip0 = G0*W9[ip];
      
      // Number of operations: 1
      const double Gip1 = G1*W9[ip];
      
      
      // Number of operations for primary indices: 2700
      for (unsigned int j = 0; j < 15; j++)
      {
        for (unsigned int k = 0; k < 15; k++)
        {
          // Number of operations to compute entry: 12
          A[j*15 + k] += (FE0_C0_D01[ip][j]*FE0_C0_D01[ip][k]*Gip0 + FE0_C0_D01[ip][j]*FE0_C1_D10[ip][k]*Gip1 + FE0_C0_D01[ip][k]*FE0_C1_D10[ip][j]*Gip1 + FE0_C1_D10[ip][j]*FE0_C1_D10[ip][k]*Gip0);
        }// end loop over 'k'
      }// end loop over 'j'
    }// end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class forms_0_cell_integral_0: public ufc::cell_integral
{
private:

  forms_0_cell_integral_0_quadrature integral_0_quadrature;

public:

  /// Constructor
  forms_0_cell_integral_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_0_cell_integral_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Reset values of the element tensor block
    for (unsigned int j = 0; j < 225; j++)
      A[j] = 0;
    
    // Add all contributions to element tensor
    integral_0_quadrature.tabulate_tensor(A, w, c);
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class forms_form_0: public ufc::form
{
public:

  /// Constructor
  forms_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(Sum(Indexed(SpatialDerivative(Argument(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2})), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), Product(IntValue(-1, (), (), {}), Indexed(SpatialDerivative(Argument(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2})))), Sum(Indexed(SpatialDerivative(Argument(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3), 1), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2})), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), Product(IntValue(-1, (), (), {}), Indexed(SpatialDerivative(Argument(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3), 1), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2}))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 0;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch ( i )
    {
    case 0:
      return new forms_0_finite_element_0();
      break;
    case 1:
      return new forms_0_finite_element_1();
      break;
    }
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch ( i )
    {
    case 0:
      return new forms_0_dof_map_0();
      break;
    case 1:
      return new forms_0_dof_map_1();
      break;
    }
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return new forms_0_cell_integral_0();
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a finite element.

class forms_1_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  forms_1_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_1_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Reset values
    values[0] = 0;
    values[1] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];
    
    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Compute number of derivatives
    unsigned int num_derivatives = 1;
    
    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;
    
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    static const double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    
    static const double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175274, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.30940107675851, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756887, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5.00000000000001, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};
    
    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];
    
    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;
    
    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;
    
    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];
    
      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;
    
        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }
    
      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }
    
    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }
    
    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    static const double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    static const double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    static const double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];
      
      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];
      
      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);
      
      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola 
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];
    
      // Note that we do not map the weights (yet).
    
      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];
    
    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new forms_1_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class forms_1_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  forms_1_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_1_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Reset values
    values[0] = 0;
    values[1] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];
    
    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    
    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;
    
    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;
    
    // Compute number of derivatives
    unsigned int num_derivatives = 1;
    
    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;
    
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;
    
    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;
    
    // Table(s) of coefficients
    static const double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126843, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.067763092717894, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399756, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399756, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217976, -0.0841793787126842, 0.349927106111883, 0, 0.033881546358947, -0.0729014804399755, 0.303045763365663},
    {0, 0, 0, 0.382536389368687, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543895, 0, -0.0903507902905252, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455696, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696627, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315784, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190477, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178939, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399755, 0}};
    
    static const double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199674, 0.260579710864614, -0.12987926104263, 0.0976879837895672, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450184, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521047, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495917, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087792, 0.120267558860591, 0.0790569415042094, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.0999811017668159, -0.0841793787126842, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.0841793787126841, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.0777615791359739, -0.320713490294909, 0.0903507902905252, -0.0641533027871785, 0.0505076272276105},
    {0, 0, 0, 0.213003216807564, -0.218866384652979, 0.194403947839935, 0.160356745147454, -0.158113883008419, 0.17787961227354, -0.126269068069026},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.28347335475692, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.52704627669473, 0.583211843519804, -0.168358757425369, 0.52077380612206, 0.342326598440728, -0.29041885655876, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285719},
    {0, 2, 0, 0.33881546358947, -0.262445329583911, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276108, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563421, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};
    
    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    static const double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    
    static const double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175274, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.30940107675851, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756887, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5.00000000000001, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};
    
    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];
    
    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;
    
    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;
    
    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];
    
      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;
    
        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }
    
      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }
    
    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }
    
    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    static const double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    static const double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    static const double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];
      
      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];
      
      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);
      
      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola 
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];
    
      // Note that we do not map the weights (yet).
    
      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];
    
    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new forms_1_finite_element_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class forms_1_dof_map_0: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  forms_1_dof_map_0() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~forms_1_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new forms_1_dof_map_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class forms_1_dof_map_1: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  forms_1_dof_map_1() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~forms_1_dof_map_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new forms_1_dof_map_1();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class forms_1_cell_integral_0_quadrature: public ufc::cell_integral
{
public:

  /// Constructor
  forms_1_cell_integral_0_quadrature() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_1_cell_integral_0_quadrature()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    
    // Array of quadrature weights
    static const double W16[16] = {0.0235683681933823, 0.0353880678980859, 0.0225840492823699, 0.00542322591052525, 0.0441850885223617, 0.0663442161070497, 0.0423397245217463, 0.0101672595644788, 0.0441850885223617, 0.0663442161070497, 0.0423397245217463, 0.0101672595644788, 0.0235683681933823, 0.0353880678980859, 0.0225840492823699, 0.00542322591052525};
    // Quadrature points on the UFC reference element: (0.0654669945550145, 0.0571041961145177), (0.0502101232113698, 0.276843013638124), (0.028912084224389, 0.583590432368917), (0.00970378512694614, 0.860240135656219), (0.311164552244357, 0.0571041961145177), (0.238648659731443, 0.276843013638124), (0.137419104134574, 0.583590432368917), (0.0461220799064521, 0.860240135656219), (0.631731251641125, 0.0571041961145177), (0.484508326630433, 0.276843013638124), (0.278990463496509, 0.583590432368917), (0.0936377844373285, 0.860240135656219), (0.877428809330468, 0.0571041961145177), (0.672946863150506, 0.276843013638124), (0.387497483406694, 0.583590432368917), (0.130056079216834, 0.860240135656219)
    
    // Value of basis functions at quadrature points.
    static const double FE0_C0[16][15] = \
    {{-0.0947355578034583, 0.0757652284864392, -0.19653700308162, 0.190793743145391, -0.267881599170305, 0.100478817739687, 1.44814774358093, -1.47756957914942, 0.480004751798262, 0.472219698998323, -1.42095239459973, -1.12441849116922, 0.27169357697502, 0.403836365235342, 0.480290926709665},
    {-0.251318648050396, 0.0591008516165154, -0.102175286343348, 0.324360765208511, -0.205185085932745, 0.0291331691852336, -0.360971558166523, -0.35015984984078, 0.263642354150745, 1.63072396101816, -3.87815209468777, -1.30459806610103, 0.206594305418901, 1.15161877561196, 0.365210585790574},
    {-0.272262929930601, 0.1091983031862, 0.526443243415804, -0.120516227945427, 0.676360012565855, -0.133664085539776, -0.201608322895941, -0.0731433787514616, 0.388332644487214, 1.76748082055498, -2.32629359926468, 3.29014235658413, -1.11094722417152, 0.804932677232354, -1.96389578938014},
    {-0.581127389392139, 1.4539293181027, -0.832506529264912, 0.17199002519577, -0.635654589709958, 1.24164389346128, 0.333100682709124, -0.153689430921272, 0.309440104080835, 0.779859645316394, -0.0884368517591991, 3.80237021531118, -1.15721521864017, 0.133657901538037, -2.04568682098185},
    {0.031122880991447, 0.0623951181653626, -0.131718028061538, 0.00680138449094171, -0.13824364913014, 0.0937937625791488, 0.137490910378168, 0.557828926600833, -0.244736920749224, 0.722970092307215, -0.373577624458576, -1.03867038333755, 0.107266021176464, -0.215406700858524, 0.189621327411944},
    {0.168379222473484, -0.100602231903662, 0.021880969154838, -0.139541819053466, 0.0429274250636276, -0.050718372574855, -0.554796074024474, 0.41550230998652, -0.308195289818603, 2.17385415396786, -0.996644606102851, -1.36400944613768, 0.0815644940404249, -0.614274548941971, 0.144187017100085},
    {0.155390653055558, -0.271032524934537, 0.47885073071091, -0.310461884166323, 0.581174987156066, -0.323779499600145, -0.0501452451267596, -0.0190402941721376, 0.182766482138708, 1.76724074671608, -0.544860967028945, 2.57710345520808, -0.438607676341473, -0.429351854716689, -0.775356155553824},
    {-0.406047746663264, 1.18265576828926, -0.94447758347834, 0.244518211587043, -0.859596698136813, 1.10600711855456, 0.333041481671324, -0.167890289374186, 0.323700163571549, 0.485469933837901, 0.0271157154134275, 3.16362920859973, -0.456874518457224, -0.07129325165455, -0.807647675381104},
    {-0.00680138449094175, 0.13824364913014, -0.0937937625791487, -0.0311228809914469, -0.0623951181653626, 0.131718028061538, -0.244736920749224, 0.557828926600833, 0.137490910378168, 0.830236113483678, 0.5889843253171, -0.849049055925601, -0.107266021176464, -0.215406700858524, -0.189621327411944},
    {0.139541819053467, -0.0429274250636278, 0.050718372574855, -0.168379222473484, 0.100602231903662, -0.021880969154838, -0.308195289818603, 0.41550230998652, -0.554796074024474, 2.25541864800828, 1.61091915504482, -1.2198224290376, -0.0815644940404249, -0.614274548941971, -0.144187017100085},
    {0.310461884166323, -0.581174987156067, 0.323779499600145, -0.155390653055558, 0.271032524934537, -0.47885073071091, 0.182766482138708, -0.0190402941721376, -0.0501452451267595, 1.32863307037461, 0.974212821745634, 1.80174729965426, 0.438607676341473, -0.429351854716689, 0.775356155553824},
    {-0.244518211587043, 0.859596698136814, -1.10600711855456, 0.406047746663264, -1.18265576828926, 0.94447758347834, 0.323700163571549, -0.167890289374186, 0.333041481671324, 0.0285954153806765, 0.0441775362411224, 2.35598153321862, 0.456874518457225, -0.0712932516545498, 0.807647675381106},
    {-0.190793743145391, 0.267881599170305, -0.100478817739687, 0.0947355578034583, -0.0757652284864388, 0.19653700308162, 0.480004751798263, -1.47756957914942, 1.44814774358093, 0.743913275973342, 1.01711602936439, -0.644127564459557, -0.27169357697502, 0.403836365235342, -0.480290926709665},
    {-0.324360765208511, 0.205185085932745, -0.0291331691852335, 0.251318648050396, -0.059100851616515, 0.102175286343348, 0.263642354150744, -0.350159849840779, -0.360971558166524, 1.83731826643706, 2.72653331907581, -0.939387480310457, -0.206594305418901, 1.15161877561196, -0.365210585790574},
    {0.120516227945427, -0.676360012565855, 0.133664085539776, 0.272262929930601, -0.1091983031862, -0.526443243415804, 0.388332644487214, -0.0731433787514617, -0.201608322895941, 0.656533596383462, 1.52136092203232, 1.32624656720399, 1.11094722417152, 0.804932677232354, 1.96389578938014},
    {-0.17199002519577, 0.635654589709958, -1.24164389346128, 0.58112738939214, -1.4539293181027, 0.832506529264912, 0.309440104080836, -0.153689430921272, 0.333100682709123, -0.377355573323778, -0.0452210497788379, 1.75668339432933, 1.15721521864017, 0.133657901538038, 2.04568682098185}};
    
    static const double FE0_C1[16][15] = \
    {{0.21838749183154, -0.0846709496980342, 0.113351419884797, 1.3877551709671, -1.50488370201432, 0.49993097358084, 0.221242999473855, -0.30045410887615, 0.110495912242482, 0.305163470241404, 0.710717751632809, 0.152083459778564, 0.523442293718342, -1.89970481499092, -0.797954823865316},
    {0.127706182847786, -0.0562359919768074, -0.0180770683046222, 0.327697985569081, 0.362280702320746, -0.181162369734278, 0.024154488113508, -0.140699104813068, 0.0854746264296551, 0.119448879693289, 0.112522004913235, -0.227421734702065, 0.619129346409986, -1.05397323719571, 0.080814050790488},
    {0.0591145505248741, -0.0695575021883966, -0.00755945651150395, -0.214306941383497, 0.821513356890112, 0.0952958554761957, -0.0205037277628576, -0.0436689596856892, 0.0720588217762275, -0.0366119279174011, -0.133762740431941, -0.102241150074232, 0.446184572947804, -0.320090820108564, 0.452649546670745},
    {0.0213653457004927, -0.0494144778111449, 0.027594587057919, 0.326049273954873, -1.11161602906793, 1.68116549873373, 0.0103963889420089, -0.0150180815793245, 0.0385635438164026, -0.048643850047799, -0.05496891973461, 0.0767730193415805, 0.148288496478725, -0.0330731485479141, 0.224278416164961},
    {0.00814885725477296, -0.0237768296038105, 0.223782463588591, -0.468410817830367, -0.215563474816632, 0.229828633686038, 0.25351139267125, -0.0832346877691293, -0.0215800718278862, 0.0840861094070493, 0.650262366896851, 0.828998166888748, 1.76209760798871, -2.67556205309049, -2.78219324236682},
    {0.0428249288916345, 0.0502626257834233, -0.170375948705165, -0.538173815496599, 0.520517837292469, -0.38752672016127, -0.135182331136817, -0.0201246093532722, 0.00763131132328684, 0.0995425825482584, -0.19659053394246, -0.692440968758912, 2.09653072469178, -1.7347140514979, 0.237359847616456},
    {0.113171804599643, -0.181429333598238, -0.01726792382938, -0.332568588171039, 0.519088780149764, -0.264955439353743, -0.0787720440838122, -0.0584210930893732, 0.174675924854076, -0.173959922011288, -0.47415507043167, -0.206219470109729, 1.64608900829636, -0.649655801530217, 1.75974316383408},
    {0.0846039134462793, -0.213603780457996, 0.138000253095434, 0.378678125093236, -1.24029622676754, 1.40598468374953, 0.0618376557016476, -0.0612785856704237, 0.160766510840065, -0.215420356359708, -0.202003264054897, 0.411746057300027, 0.631634491033446, -0.080748767363104, 0.987019498320209},
    {-0.475212202321309, -0.0773198256864916, 0.136034871106889, -0.0229740237366741, -0.0861719477691735, 0.355500491650128, -0.223156848921338, 0.641063614369962, -0.116020482293082, -1.01594760391208, -1.43631536087654, 1.10414601955247, 1.65483158681224, 2.46015535223197, -2.97181456977876},
    {-0.398631996443132, 0.477590412228841, -0.336808347586415, -0.12555429358185, 0.150864857687085, -0.192256917860003, -0.31582660114189, 0.435626919339791, -0.419613742887657, 0.0593453407682408, -0.320385430395538, -0.76474130789514, 2.01496623065136, 1.12043950255593, 0.0931728305163708},
    {-0.0221067040047164, -0.0620862070063024, 0.0588240602464017, -0.0422188484559149, 0.0896031913362993, -0.49611865454029, 0.00809055728463262, 0.0393807989172355, 0.0286267989570527, -0.143496015910459, -0.149598050216252, 0.248223605929902, 2.08469668463783, 0.220303946813528, 2.53509931938791},
    {0.134159913506193, -0.38069952863073, 0.299977565194968, 0.490651660109544, -1.39625954874725, 1.08247783657377, 0.162933652731484, -0.106611703703763, 0.271203825969676, -0.38761871929306, -0.238574495176878, 0.957215977598387, 1.08850900949067, 0.00945551570855429, 1.79466717370131},
    {1.1969614278217, -1.23700210284401, 0.399452155841153, 0.313123049634999, -0.160436178184473, 0.309888422966417, 0.36950883955578, -1.17711547027327, 1.22690474410708, -0.0846924879864045, -0.171871033993727, 0.00174379962719623, 0.251748716743323, 2.30354118022627, -1.27824575057498},
    {0.00333722036056898, 0.567465788253491, -0.210295538919512, 0.379024830898182, -0.115336843593322, 0.084098218038726, 0.178167727721089, -0.209460745027711, -0.385126046280032, 1.09874004033379, 1.78508208679333, -0.79277979639888, 0.412535040991085, 2.20559201280767, -0.284396535000086},
    {-0.0937907134380696, 0.145153344324257, 0.228959941015972, 0.331377480455475, -0.178755805374597, -0.534002699927308, 0.316273822710986, -0.0294744190657723, -0.181104595133084, 0.246960951353059, 1.06750736149182, 0.975838170607481, 1.55713179711933, 1.12502349734092, 2.41654533605088},
    {0.154059248759103, -0.475961439357972, 0.439521605272445, 0.602492735092633, -1.50334379591384, 0.860101116322831, 0.270876560264433, -0.138671349341948, 0.322704293767115, -0.477000219754702, -0.13326311806136, 1.45563195882279, 1.3055037151189, 0.166731050085951, 2.26996523714681}};
    
    
    // Number of operations to compute geometry constants: 12
    const double G0 = det*(Jinv_00*Jinv_00 + Jinv_01*Jinv_01);
    const double G1 = det*(Jinv_10*Jinv_10 + Jinv_11*Jinv_11);
    const double G2 = det*(Jinv_00*Jinv_10 + Jinv_01*Jinv_11);
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('simplify expressions', True), ('ignore zero tables', True), ('non zero columns', True), ('remove zero terms', True), ('ignore ones', True)
    // Total number of operations to compute element tensor: 43260
    
    // Loop quadrature points for integral
    // Number of operations to compute element tensor for following IP loop = 43248
    for (unsigned int ip = 0; ip < 16; ip++)
    {
      
      // Number of operations to compute ip constants: 3
      // Number of operations: 1
      const double Gip0 = G0*W16[ip];
      
      // Number of operations: 1
      const double Gip1 = G1*W16[ip];
      
      // Number of operations: 1
      const double Gip2 = G2*W16[ip];
      
      
      // Number of operations for primary indices: 2700
      for (unsigned int j = 0; j < 15; j++)
      {
        for (unsigned int k = 0; k < 15; k++)
        {
          // Number of operations to compute entry: 12
          A[j*15 + k] += (FE0_C0[ip][j]*FE0_C0[ip][k]*Gip0 + FE0_C0[ip][j]*FE0_C1[ip][k]*Gip2 + FE0_C0[ip][k]*FE0_C1[ip][j]*Gip2 + FE0_C1[ip][j]*FE0_C1[ip][k]*Gip1);
        }// end loop over 'k'
      }// end loop over 'j'
    }// end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class forms_1_cell_integral_0: public ufc::cell_integral
{
private:

  forms_1_cell_integral_0_quadrature integral_0_quadrature;

public:

  /// Constructor
  forms_1_cell_integral_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_1_cell_integral_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Reset values of the element tensor block
    for (unsigned int j = 0; j < 225; j++)
      A[j] = 0;
    
    // Add all contributions to element tensor
    integral_0_quadrature.tabulate_tensor(A, w, c);
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class forms_form_1: public ufc::form
{
public:

  /// Constructor
  forms_form_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~forms_form_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(IndexSum(Product(Indexed(Argument(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3), 0), MultiIndex((Index(0),), {Index(0): 2})), Indexed(Argument(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1, Space(2)), 3), 1), MultiIndex((Index(0),), {Index(0): 2}))), MultiIndex((Index(0),), {Index(0): 2})), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 0;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch ( i )
    {
    case 0:
      return new forms_1_finite_element_0();
      break;
    case 1:
      return new forms_1_finite_element_1();
      break;
    }
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch ( i )
    {
    case 0:
      return new forms_1_dof_map_0();
      break;
    case 1:
      return new forms_1_dof_map_1();
      break;
    }
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return new forms_1_cell_integral_0();
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>

namespace Forms
{

class Form_0_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh):
      dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_0()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_0()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_0()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_0()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_0()), *mesh)))
  {
      // Do nothing
  }


  ~Form_0_FunctionSpace_0()
  {
  }

};

class Form_0_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh):
      dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_1()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_1()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_1()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_1()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_0_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_0_dof_map_1()), *mesh)))
  {
      // Do nothing
  }


  ~Form_0_FunctionSpace_1()
  {
  }

};

class Form_0: public dolfin::Form
{
public:

  // Constructor
  Form_0(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new forms_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new forms_form_0());
  }

  // Destructor
  ~Form_0()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {

    dolfin::error("No coefficients.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {

    dolfin::error("No coefficients.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_0_FunctionSpace_0 TestSpace;
  typedef Form_0_FunctionSpace_1 TrialSpace;

  // Coefficients
};

class Form_1_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_1_FunctionSpace_0(const dolfin::Mesh& mesh):
      dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_0()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_0()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_0()), *mesh)))
  {
      // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_0()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_0()), *mesh)))
  {
      // Do nothing
  }


  ~Form_1_FunctionSpace_0()
  {
  }

};

class Form_1_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_1_FunctionSpace_1(const dolfin::Mesh& mesh):
      dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_1()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_1()), *mesh)))
  {
      // Do nothing
  }

  Form_1_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
      dolfin::FunctionSpace(mesh,
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new forms_1_dof_map_1()), *mesh)))
  {
      // Do nothing
  }


  ~Form_1_FunctionSpace_1()
  {
  }

};

class Form_1: public dolfin::Form
{
public:

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new forms_form_1());
  }

  // Constructor
  Form_1(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new forms_form_1());
  }

  // Destructor
  ~Form_1()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {

    dolfin::error("No coefficients.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {

    dolfin::error("No coefficients.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_1_FunctionSpace_0 TestSpace;
  typedef Form_1_FunctionSpace_1 TrialSpace;

  // Coefficients
};

// Class typedefs
typedef Form_0::TestSpace FunctionSpace;

} // namespace Forms

#endif
