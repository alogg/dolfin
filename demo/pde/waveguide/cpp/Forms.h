// This code conforms with the UFC specification version 1.0
// and was automatically generated by FFC version 0.6.2.
//
// Warning: This code was generated with the option '-l dolfin'
// and contains DOLFIN-specific wrappers that depend on DOLFIN.

#ifndef __FORMS_H
#define __FORMS_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class UFC_Forms_0_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  UFC_Forms_0_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_0_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Reset values
    values[0] = 0;
    values[1] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];

    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Compute number of derivatives
    unsigned int num_derivatives = 1;

    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;


    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }

    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }

    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};

    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }

    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }

    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    const static double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

    const static double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175275, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.3094010767585, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756888, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};

    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];

    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;

    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;

    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];

      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;

        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }

      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }

    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;

    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }

    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    const static double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    const static double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    const static double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};

    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];

      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];

      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);

      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];

      // Note that we do not map the weights (yet).

      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];

    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new UFC_Forms_0_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class UFC_Forms_0_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  UFC_Forms_0_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_0_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Reset values
    values[0] = 0;
    values[1] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];

    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Compute number of derivatives
    unsigned int num_derivatives = 1;

    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;


    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }

    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }

    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};

    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }

    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }

    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    const static double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

    const static double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175275, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.3094010767585, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756888, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};

    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];

    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;

    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;

    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];

      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;

        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }

      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }

    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;

    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }

    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    const static double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    const static double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    const static double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};

    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];

      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];

      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);

      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];

      // Note that we do not map the weights (yet).

      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];

    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new UFC_Forms_0_finite_element_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class UFC_Forms_0_dof_map_0: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  UFC_Forms_0_dof_map_0() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~UFC_Forms_0_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new UFC_Forms_0_dof_map_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class UFC_Forms_0_dof_map_1: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  UFC_Forms_0_dof_map_1() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~UFC_Forms_0_dof_map_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new UFC_Forms_0_dof_map_1();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class UFC_Forms_0_cell_integral_0_quadrature: public ufc::cell_integral
{
public:

  /// Constructor
  UFC_Forms_0_cell_integral_0_quadrature() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_0_cell_integral_0_quadrature()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Set scale factor
    const double det = std::abs(detJ);


    // Array of quadrature weights
    const static double W4[4] = {0.159020690871988, 0.0909793091280112, 0.159020690871988, 0.0909793091280112};


    const static double FE0_C0_D01[4][15] = \
    {{0.44043072275435, -0.591228761686959, 0.702785577374894, -0.562754996450812, 0.83587730907988, -0.580461303678432, -6.06068379873009, 2.70892558466261, -0.977527425828978, 6.90316273045466, -4.61131899272514, -1.7130514594198, -0.345985293737947, -1.24585712859747, -0.611621368482305},
    {-0.226751600926315, 2.08156197165487, -2.26231153630375, 0.263435228567675, -2.15492922693758, 2.22562790866239, 2.83801811898682, -0.82051616334139, 0.511783684251018, -4.15324373009635, 8.55029173845932, 7.59773021115155, 0.103756967454907, -2.17760569096656, 0.183418138206795},
    {-1.11952256905338, 0.259514505728382, 0.447408216222526, 0.827204022801617, 0.325122586775146, -0.155089669970763, 1.9826124668647, -3.28104804639465, -3.0308500603665, 5.53903016772326, 10.0760276697474, -0.72077494898152, -0.82680170528486, 4.64960210289766, -1.46159273125882},
    {-1.33415655277466, 0.330152284303711, -4.32788225729367, 4.31211574508152, -6.28607066891744, 1.34992306498681, 2.00005321287856, -0.927361374926574, 1.45659380194446, -11.1173762928278, -2.23705492401321, 1.23609619724975, 8.422940555908, 8.12693507753831, 14.8897959615343}};

    const static double FE0_C1_D10[4][15] = \
    {{-1.12557333034872, 0.732158012678233, -0.39345430575726, -5.50855494666715, 2.7794681863318, -0.777721701244231, -0.691940143192812, 1.32912968754934, -0.827087492913163, -0.844245438955299, -1.7628497643756, -0.0684869836538315, 6.07217778028149, -1.24585712859749, -3.90075032001425},
    {0.621560998552773, -1.53464512573788, 0.409057216231981, -0.308456274839967, -3.19134042721706, -4.00198282436825, -0.237905213522902, -0.240720266228116, 1.26852342830765, -1.8298860850104, -3.29817748989022, 0.757013312678957, 11.3219200414744, -2.17760569096655, 13.864851935152},
    {3.82627738116296, -1.68407637152354, 0.644668613788325, 2.39320807590469, -0.998264187590046, 0.941150213161392, 2.13305239978051, -4.66084394350792, 2.33789359517077, 4.20978507233274, 7.22755844139785, -2.36533942474748, -7.24496477930431, 4.64960210289767, 1.82753622027312},
    {-0.762265049367016, 1.36656348458319, 1.89972847573695, 3.46380314560244, -2.6698635715247, -1.32144568754891, 2.7567929569352, -0.347565477813302, -1.61932953056526, 2.42414442627764, 9.61141430433632, 8.07681309572234, -2.79522251811144, 8.12693507753831, 1.20836216458913}};

    // Number of operations to compute geometry constants: 22
    const double G0 = det*(Jinv_00*Jinv_11*(Jinv_00*Jinv_11 - 2*Jinv_01*Jinv_10) + Jinv_01*Jinv_01*Jinv_10*Jinv_10);
    const double G1 = det*(Jinv_00*Jinv_11*(2*Jinv_01*Jinv_10 - Jinv_00*Jinv_11) - Jinv_01*Jinv_01*Jinv_10*Jinv_10);

    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('simplify expressions', True), ('ignore zero tables', True), ('non zero columns', True), ('remove zero terms', True), ('ignore ones', True)
    // Total number of operations to compute element tensor: 10830

    // Loop quadrature points for integral
    // Number of operations to compute element tensor for following IP loop = 10808
    for (unsigned int ip = 0; ip < 4; ip++)
    {

      // Number of operations to compute ip constants: 2
      // Number of operations: 1
      const double Gip0 = W4[ip]*G0;

      // Number of operations: 1
      const double Gip1 = W4[ip]*G1;


      // Number of operations for primary indices = 2700
      for (unsigned int j = 0; j < 15; j++)
      {
        for (unsigned int k = 0; k < 15; k++)
        {
          // Number of operations to compute entry = 12
          A[j*15 + k] += (FE0_C0_D01[ip][j]*FE0_C0_D01[ip][k]*Gip0 + FE0_C0_D01[ip][j]*FE0_C1_D10[ip][k]*Gip1 + FE0_C0_D01[ip][k]*FE0_C1_D10[ip][j]*Gip1 + FE0_C1_D10[ip][j]*FE0_C1_D10[ip][k]*Gip0);
        }// end loop over 'k'
      }// end loop over 'j'
    }// end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class UFC_Forms_0_cell_integral_0: public ufc::cell_integral
{
private:

  UFC_Forms_0_cell_integral_0_quadrature integral_0_quadrature;

public:

  /// Constructor
  UFC_Forms_0_cell_integral_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_0_cell_integral_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Reset values of the element tensor block
    A[0] = 0;
    A[1] = 0;
    A[2] = 0;
    A[3] = 0;
    A[4] = 0;
    A[5] = 0;
    A[6] = 0;
    A[7] = 0;
    A[8] = 0;
    A[9] = 0;
    A[10] = 0;
    A[11] = 0;
    A[12] = 0;
    A[13] = 0;
    A[14] = 0;
    A[15] = 0;
    A[16] = 0;
    A[17] = 0;
    A[18] = 0;
    A[19] = 0;
    A[20] = 0;
    A[21] = 0;
    A[22] = 0;
    A[23] = 0;
    A[24] = 0;
    A[25] = 0;
    A[26] = 0;
    A[27] = 0;
    A[28] = 0;
    A[29] = 0;
    A[30] = 0;
    A[31] = 0;
    A[32] = 0;
    A[33] = 0;
    A[34] = 0;
    A[35] = 0;
    A[36] = 0;
    A[37] = 0;
    A[38] = 0;
    A[39] = 0;
    A[40] = 0;
    A[41] = 0;
    A[42] = 0;
    A[43] = 0;
    A[44] = 0;
    A[45] = 0;
    A[46] = 0;
    A[47] = 0;
    A[48] = 0;
    A[49] = 0;
    A[50] = 0;
    A[51] = 0;
    A[52] = 0;
    A[53] = 0;
    A[54] = 0;
    A[55] = 0;
    A[56] = 0;
    A[57] = 0;
    A[58] = 0;
    A[59] = 0;
    A[60] = 0;
    A[61] = 0;
    A[62] = 0;
    A[63] = 0;
    A[64] = 0;
    A[65] = 0;
    A[66] = 0;
    A[67] = 0;
    A[68] = 0;
    A[69] = 0;
    A[70] = 0;
    A[71] = 0;
    A[72] = 0;
    A[73] = 0;
    A[74] = 0;
    A[75] = 0;
    A[76] = 0;
    A[77] = 0;
    A[78] = 0;
    A[79] = 0;
    A[80] = 0;
    A[81] = 0;
    A[82] = 0;
    A[83] = 0;
    A[84] = 0;
    A[85] = 0;
    A[86] = 0;
    A[87] = 0;
    A[88] = 0;
    A[89] = 0;
    A[90] = 0;
    A[91] = 0;
    A[92] = 0;
    A[93] = 0;
    A[94] = 0;
    A[95] = 0;
    A[96] = 0;
    A[97] = 0;
    A[98] = 0;
    A[99] = 0;
    A[100] = 0;
    A[101] = 0;
    A[102] = 0;
    A[103] = 0;
    A[104] = 0;
    A[105] = 0;
    A[106] = 0;
    A[107] = 0;
    A[108] = 0;
    A[109] = 0;
    A[110] = 0;
    A[111] = 0;
    A[112] = 0;
    A[113] = 0;
    A[114] = 0;
    A[115] = 0;
    A[116] = 0;
    A[117] = 0;
    A[118] = 0;
    A[119] = 0;
    A[120] = 0;
    A[121] = 0;
    A[122] = 0;
    A[123] = 0;
    A[124] = 0;
    A[125] = 0;
    A[126] = 0;
    A[127] = 0;
    A[128] = 0;
    A[129] = 0;
    A[130] = 0;
    A[131] = 0;
    A[132] = 0;
    A[133] = 0;
    A[134] = 0;
    A[135] = 0;
    A[136] = 0;
    A[137] = 0;
    A[138] = 0;
    A[139] = 0;
    A[140] = 0;
    A[141] = 0;
    A[142] = 0;
    A[143] = 0;
    A[144] = 0;
    A[145] = 0;
    A[146] = 0;
    A[147] = 0;
    A[148] = 0;
    A[149] = 0;
    A[150] = 0;
    A[151] = 0;
    A[152] = 0;
    A[153] = 0;
    A[154] = 0;
    A[155] = 0;
    A[156] = 0;
    A[157] = 0;
    A[158] = 0;
    A[159] = 0;
    A[160] = 0;
    A[161] = 0;
    A[162] = 0;
    A[163] = 0;
    A[164] = 0;
    A[165] = 0;
    A[166] = 0;
    A[167] = 0;
    A[168] = 0;
    A[169] = 0;
    A[170] = 0;
    A[171] = 0;
    A[172] = 0;
    A[173] = 0;
    A[174] = 0;
    A[175] = 0;
    A[176] = 0;
    A[177] = 0;
    A[178] = 0;
    A[179] = 0;
    A[180] = 0;
    A[181] = 0;
    A[182] = 0;
    A[183] = 0;
    A[184] = 0;
    A[185] = 0;
    A[186] = 0;
    A[187] = 0;
    A[188] = 0;
    A[189] = 0;
    A[190] = 0;
    A[191] = 0;
    A[192] = 0;
    A[193] = 0;
    A[194] = 0;
    A[195] = 0;
    A[196] = 0;
    A[197] = 0;
    A[198] = 0;
    A[199] = 0;
    A[200] = 0;
    A[201] = 0;
    A[202] = 0;
    A[203] = 0;
    A[204] = 0;
    A[205] = 0;
    A[206] = 0;
    A[207] = 0;
    A[208] = 0;
    A[209] = 0;
    A[210] = 0;
    A[211] = 0;
    A[212] = 0;
    A[213] = 0;
    A[214] = 0;
    A[215] = 0;
    A[216] = 0;
    A[217] = 0;
    A[218] = 0;
    A[219] = 0;
    A[220] = 0;
    A[221] = 0;
    A[222] = 0;
    A[223] = 0;
    A[224] = 0;

    // Add all contributions to element tensor
    integral_0_quadrature.tabulate_tensor(A, w, c);
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class UFC_Forms_0: public ufc::form
{
public:

  /// Constructor
  UFC_Forms_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(Sum(Indexed(SpatialDerivative(BasisFunction(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1), 2), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2})), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), Product(IntValue(-1, (), (), {}), Indexed(SpatialDerivative(BasisFunction(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1), 2), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2})))), Sum(Indexed(SpatialDerivative(BasisFunction(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1), 2), 1), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2})), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), Product(IntValue(-1, (), (), {}), Indexed(SpatialDerivative(BasisFunction(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1), 2), 1), MultiIndex((FixedIndex(1),), {FixedIndex(1): 2})), MultiIndex((FixedIndex(0),), {FixedIndex(0): 2}))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 0;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      return new UFC_Forms_0_finite_element_0();
      break;
    case 1:
      return new UFC_Forms_0_finite_element_1();
      break;
    }
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      return new UFC_Forms_0_dof_map_0();
      break;
    case 1:
      return new UFC_Forms_0_dof_map_1();
      break;
    }
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return new UFC_Forms_0_cell_integral_0();
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a finite element.

class UFC_Forms_1_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  UFC_Forms_1_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_1_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Reset values
    values[0] = 0;
    values[1] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];

    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Compute number of derivatives
    unsigned int num_derivatives = 1;

    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;


    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }

    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }

    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};

    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }

    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }

    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    const static double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

    const static double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175275, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.3094010767585, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756888, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};

    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];

    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;

    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;

    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];

      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;

        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }

      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }

    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;

    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }

    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    const static double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    const static double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    const static double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};

    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];

      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];

      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);

      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];

      // Note that we do not map the weights (yet).

      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];

    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new UFC_Forms_1_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class UFC_Forms_1_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  UFC_Forms_1_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_1_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 2;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Reset values
    values[0] = 0;
    values[1] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Extract relevant coefficients
    const double coeff0_0 = coefficients0[dof][0];
    const double coeff0_1 = coefficients0[dof][1];
    const double coeff0_2 = coefficients0[dof][2];
    const double coeff0_3 = coefficients0[dof][3];
    const double coeff0_4 = coefficients0[dof][4];
    const double coeff0_5 = coefficients0[dof][5];
    const double coeff0_6 = coefficients0[dof][6];
    const double coeff0_7 = coefficients0[dof][7];
    const double coeff0_8 = coefficients0[dof][8];
    const double coeff0_9 = coefficients0[dof][9];
    const double coeff1_0 = coefficients1[dof][0];
    const double coeff1_1 = coefficients1[dof][1];
    const double coeff1_2 = coefficients1[dof][2];
    const double coeff1_3 = coefficients1[dof][3];
    const double coeff1_4 = coefficients1[dof][4];
    const double coeff1_5 = coefficients1[dof][5];
    const double coeff1_6 = coefficients1[dof][6];
    const double coeff1_7 = coefficients1[dof][7];
    const double coeff1_8 = coefficients1[dof][8];
    const double coeff1_9 = coefficients1[dof][9];

    // Compute value(s)
    const double tmp0_0 = coeff0_0*basisvalue0 + coeff0_1*basisvalue1 + coeff0_2*basisvalue2 + coeff0_3*basisvalue3 + coeff0_4*basisvalue4 + coeff0_5*basisvalue5 + coeff0_6*basisvalue6 + coeff0_7*basisvalue7 + coeff0_8*basisvalue8 + coeff0_9*basisvalue9;
    const double tmp0_1 = coeff1_0*basisvalue0 + coeff1_1*basisvalue1 + coeff1_2*basisvalue2 + coeff1_3*basisvalue3 + coeff1_4*basisvalue4 + coeff1_5*basisvalue5 + coeff1_6*basisvalue6 + coeff1_7*basisvalue7 + coeff1_8*basisvalue8 + coeff1_9*basisvalue9;
    // Using covariant Piola transform to map values back to the physical element
    values[0] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
    values[1] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis() is not yet implemented.");
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];

    // Compute determinant of Jacobian
    const double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Get coordinates and map to the reference (UFC) element
    double x = (element_coordinates[0][1]*element_coordinates[2][0] -\
                element_coordinates[0][0]*element_coordinates[2][1] +\
                J_11*coordinates[0] - J_01*coordinates[1]) / detJ;
    double y = (element_coordinates[1][1]*element_coordinates[0][0] -\
                element_coordinates[1][0]*element_coordinates[0][1] -\
                J_10*coordinates[0] + J_00*coordinates[1]) / detJ;

    // Map coordinates to the reference square
    if (std::abs(y - 1.0) < 1e-14)
      x = -1.0;
    else
      x = 2.0 *x/(1.0 - y) - 1.0;
    y = 2.0*y - 1.0;

    // Compute number of derivatives
    unsigned int num_derivatives = 1;

    for (unsigned int j = 0; j < n; j++)
      num_derivatives *= 2;


    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      combinations[j] = new unsigned int [n];
      for (unsigned int k = 0; k < n; k++)
        combinations[j][k] = 0;
    }

    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }

    // Compute inverse of Jacobian
    const double Jinv[2][2] =  {{J_11 / detJ, -J_01 / detJ}, {-J_10 / detJ, J_00 / detJ}};

    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];

    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }

    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }

    // Reset values
    for (unsigned int j = 0; j < 2*num_derivatives; j++)
      values[j] = 0;

    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;

    // Generate scalings
    const double scalings_y_0 = 1;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5*y);
    const double scalings_y_2 = scalings_y_1*(0.5 - 0.5*y);
    const double scalings_y_3 = scalings_y_2*(0.5 - 0.5*y);

    // Compute psitilde_a
    const double psitilde_a_0 = 1;
    const double psitilde_a_1 = x;
    const double psitilde_a_2 = 1.5*x*psitilde_a_1 - 0.5*psitilde_a_0;
    const double psitilde_a_3 = 1.66666666666667*x*psitilde_a_2 - 0.666666666666667*psitilde_a_1;

    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1;
    const double psitilde_bs_0_1 = 1.5*y + 0.5;
    const double psitilde_bs_0_2 = 0.111111111111111*psitilde_bs_0_1 + 1.66666666666667*y*psitilde_bs_0_1 - 0.555555555555556*psitilde_bs_0_0;
    const double psitilde_bs_0_3 = 0.05*psitilde_bs_0_2 + 1.75*y*psitilde_bs_0_2 - 0.7*psitilde_bs_0_1;
    const double psitilde_bs_1_0 = 1;
    const double psitilde_bs_1_1 = 2.5*y + 1.5;
    const double psitilde_bs_1_2 = 0.54*psitilde_bs_1_1 + 2.1*y*psitilde_bs_1_1 - 0.56*psitilde_bs_1_0;
    const double psitilde_bs_2_0 = 1;
    const double psitilde_bs_2_1 = 3.5*y + 2.5;
    const double psitilde_bs_3_0 = 1;

    // Compute basisvalues
    const double basisvalue0 = 0.707106781186548*psitilde_a_0*scalings_y_0*psitilde_bs_0_0;
    const double basisvalue1 = 1.73205080756888*psitilde_a_1*scalings_y_1*psitilde_bs_1_0;
    const double basisvalue2 = psitilde_a_0*scalings_y_0*psitilde_bs_0_1;
    const double basisvalue3 = 2.73861278752583*psitilde_a_2*scalings_y_2*psitilde_bs_2_0;
    const double basisvalue4 = 2.12132034355964*psitilde_a_1*scalings_y_1*psitilde_bs_1_1;
    const double basisvalue5 = 1.22474487139159*psitilde_a_0*scalings_y_0*psitilde_bs_0_2;
    const double basisvalue6 = 3.74165738677394*psitilde_a_3*scalings_y_3*psitilde_bs_3_0;
    const double basisvalue7 = 3.16227766016838*psitilde_a_2*scalings_y_2*psitilde_bs_2_1;
    const double basisvalue8 = 2.44948974278318*psitilde_a_1*scalings_y_1*psitilde_bs_1_2;
    const double basisvalue9 = 1.4142135623731*psitilde_a_0*scalings_y_0*psitilde_bs_0_3;

    // Table(s) of coefficients
    const static double coefficients0[15][10] = \
    {{0, 0, 0, -0.169533172561123, 0.0841793787126844, -0.116642368703961, 0, -0.146820034222103, 0.0729014804399756, -0.101015254455221},
    {0, 0, 0, 0.0782460796435953, -0.168358757425368, 0.349927106111883, 0, 0.0677630927178939, -0.145802960879951, 0.303045763365663},
    {0, 0, 0, -0.0391230398217976, -0.0841793787126844, -0.349927106111883, 0, -0.0338815463589469, -0.0729014804399755, -0.303045763365663},
    {0, 0, 0, 0.169533172561123, 0.0841793787126842, 0.116642368703961, 0, 0.146820034222103, 0.0729014804399755, 0.101015254455221},
    {0, 0, 0, -0.0782460796435951, -0.168358757425369, -0.349927106111883, 0, -0.0677630927178938, -0.145802960879951, -0.303045763365663},
    {0, 0, 0, 0.0391230398217975, -0.0841793787126843, 0.349927106111883, 0, 0.0338815463589469, -0.0729014804399756, 0.303045763365663},
    {0, 0, 0, 0.382536389368688, 0.303045763365663, 0.311046316543896, 0, -0.0903507902905252, -0.145802960879951, -0.202030508910442},
    {0, 0, 0, -0.765072778737375, 0, -0.155523158271948, 0, 0.18070158058105, 0, 0.101015254455221},
    {0, 0, 0, 0.382536389368687, -0.303045763365663, 0.311046316543896, 0, -0.0903507902905253, 0.145802960879951, -0.202030508910442},
    {2, 0, 0, -0.184427778390829, -0.238095238095238, -0.824786098842322, 0, -0.159719141249985, -0.206196524710581, 0.285714285714286},
    {0, 2, 0, -0.338815463589469, 0.903978357455697, 0, 0, -0.293422798663482, -0.631345340345132, 0},
    {0, 0, 2, 0.0652050663696625, -0.420896893563422, 0.466569474815843, 0, 0.0564692439315782, -0.364507402199878, -1.01015254455221},
    {0, 0, 0, 0, 0.476190476190476, 0, 0, 0, 0.412393049421162, 0},
    {0, 0, 0, 0.677630927178938, 0, 0, 0, 0.586845597326964, 0, 0},
    {0, 0, 0, 0, 0.841793787126843, 0, 0, 0, 0.729014804399756, 0}};

    const static double coefficients1[15][10] = \
    {{0, 0, 0, 0.321678327423669, -0.134687005940295, 0.0972019739199673, 0.260579710864614, -0.12987926104263, 0.0976879837895673, -0.0631345340345132},
    {0, 0, 0, -0.165186168136479, 0.235702260395516, -0.272165526975909, -0.120267558860591, 0.146820034222103, -0.224536559755125, 0.176776695296637},
    {0, 0, 0, 0.0608580619450185, 0, 0.213844342623928, 0.0601337794302954, 0.0395284707521046, 0.112268279877562, -0.138895974875929},
    {0, 0, 0, 0.491211499984792, 0.218866384652979, 0.213844342623928, -0.260579710864614, 0.0169407731794735, -0.0247865033495916, 0.0378807204207078},
    {0, 0, 0, -0.243432247780074, -0.404061017820884, -0.622092633087791, 0.120267558860591, 0.0790569415042093, 0.0787335988751735, -0.126269068069026},
    {0, 0, 0, 0.099981101766816, -0.0841793787126844, 0.563771448735811, -0.0601337794302954, 0.0734100171110518, -0.185169760317538, 0.164149788489734},
    {0, 0, 0, 0.169533172561123, 0.084179378712684, 0.116642368703961, 0.160356745147455, 0.0677630927178938, 0.0320766513935892, -0.0757614408414157},
    {0, 0, 0, -0.382536389368687, 0.0673435029701475, -0.077761579135974, -0.320713490294909, 0.0903507902905252, -0.0641533027871786, 0.0505076272276106},
    {0, 0, 0, 0.213003216807565, -0.218866384652979, 0.194403947839935, 0.160356745147455, -0.158113883008419, 0.17787961227354, -0.126269068069027},
    {0, 0, 0, 0.307379630651382, 0.238095238095238, -0.274928699614108, 0.283473354756921, 0.0798595706249925, -0.226816177181639, 0.178571428571429},
    {0, 0, 0, 0.527046276694729, 0.583211843519804, -0.168358757425368, 0.52077380612206, 0.342326598440729, -0.290418856558761, 0.109352220659964},
    {0, 0, 0, -0.173880176985767, 0.168358757425368, 0.680413817439771, -0.100222965717159, 0.31058084162368, 0.298896069803899, -0.441941738241592},
    {2, 0, 0, -0.799187039693594, 0.238095238095238, -0.274928699614107, 0, -0.31943828249997, 0.206196524710581, -0.0714285714285717},
    {0, 2, 0, 0.338815463589469, -0.262445329583912, 0, -1.04154761224412, 0.293422798663482, -0.0505076272276109, 0},
    {0, 0, 2, 0.412965420341197, 0.420896893563422, -0.8942581600637, 0, -0.564692439315782, 0.364507402199878, -0.126269068069027}};

    // Interesting (new) part
    // Tables of derivatives of the polynomial base (transpose)
    const static double dmats0[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.89897948556636, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 9.48683298050514, 0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 7.07106781186547, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {5.29150262212918, 0, -2.99332590941915, 13.6626010212795, 0, 0.61101009266078, 0, 0, 0, 0},
    {0, 4.38178046004133, 0, 0, 12.5219806739988, 0, 0, 0, 0, 0},
    {3.46410161513775, 0, 7.83836717690617, 0, 0, 8.4, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

    const static double dmats1[10][10] = \
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.44948974278318, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {4.24264068711929, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2.58198889747161, 4.74341649025257, -0.912870929175275, 0, 0, 0, 0, 0, 0, 0},
    {2, 6.12372435695795, 3.53553390593274, 0, 0, 0, 0, 0, 0, 0},
    {-2.3094010767585, 0, 8.16496580927726, 0, 0, 0, 0, 0, 0, 0},
    {2.64575131106459, 5.18459255872629, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330391, 0, 0, 0, 0},
    {2.23606797749979, 2.19089023002067, 2.5298221281347, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0, 0, 0, 0},
    {1.73205080756888, -5.09116882454314, 3.91918358845308, 0, 9.69948452238571, 4.2, 0, 0, 0, 0},
    {5, 0, -2.82842712474619, 0, 0, 12.1243556529821, 0, 0, 0, 0}};

    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [2*num_derivatives];

    // Declare coefficients
    double coeff0_0 = 0;
    double coeff0_1 = 0;
    double coeff0_2 = 0;
    double coeff0_3 = 0;
    double coeff0_4 = 0;
    double coeff0_5 = 0;
    double coeff0_6 = 0;
    double coeff0_7 = 0;
    double coeff0_8 = 0;
    double coeff0_9 = 0;
    double coeff1_0 = 0;
    double coeff1_1 = 0;
    double coeff1_2 = 0;
    double coeff1_3 = 0;
    double coeff1_4 = 0;
    double coeff1_5 = 0;
    double coeff1_6 = 0;
    double coeff1_7 = 0;
    double coeff1_8 = 0;
    double coeff1_9 = 0;

    // Declare new coefficients
    double new_coeff0_0 = 0;
    double new_coeff0_1 = 0;
    double new_coeff0_2 = 0;
    double new_coeff0_3 = 0;
    double new_coeff0_4 = 0;
    double new_coeff0_5 = 0;
    double new_coeff0_6 = 0;
    double new_coeff0_7 = 0;
    double new_coeff0_8 = 0;
    double new_coeff0_9 = 0;
    double new_coeff1_0 = 0;
    double new_coeff1_1 = 0;
    double new_coeff1_2 = 0;
    double new_coeff1_3 = 0;
    double new_coeff1_4 = 0;
    double new_coeff1_5 = 0;
    double new_coeff1_6 = 0;
    double new_coeff1_7 = 0;
    double new_coeff1_8 = 0;
    double new_coeff1_9 = 0;

    // Loop possible derivatives
    for (unsigned int deriv_num = 0; deriv_num < num_derivatives; deriv_num++)
    {
      // Get values from coefficients array
      new_coeff0_0 = coefficients0[dof][0];
      new_coeff0_1 = coefficients0[dof][1];
      new_coeff0_2 = coefficients0[dof][2];
      new_coeff0_3 = coefficients0[dof][3];
      new_coeff0_4 = coefficients0[dof][4];
      new_coeff0_5 = coefficients0[dof][5];
      new_coeff0_6 = coefficients0[dof][6];
      new_coeff0_7 = coefficients0[dof][7];
      new_coeff0_8 = coefficients0[dof][8];
      new_coeff0_9 = coefficients0[dof][9];
      new_coeff1_0 = coefficients1[dof][0];
      new_coeff1_1 = coefficients1[dof][1];
      new_coeff1_2 = coefficients1[dof][2];
      new_coeff1_3 = coefficients1[dof][3];
      new_coeff1_4 = coefficients1[dof][4];
      new_coeff1_5 = coefficients1[dof][5];
      new_coeff1_6 = coefficients1[dof][6];
      new_coeff1_7 = coefficients1[dof][7];
      new_coeff1_8 = coefficients1[dof][8];
      new_coeff1_9 = coefficients1[dof][9];

      // Loop derivative order
      for (unsigned int j = 0; j < n; j++)
      {
        // Update old coefficients
        coeff0_0 = new_coeff0_0;
        coeff0_1 = new_coeff0_1;
        coeff0_2 = new_coeff0_2;
        coeff0_3 = new_coeff0_3;
        coeff0_4 = new_coeff0_4;
        coeff0_5 = new_coeff0_5;
        coeff0_6 = new_coeff0_6;
        coeff0_7 = new_coeff0_7;
        coeff0_8 = new_coeff0_8;
        coeff0_9 = new_coeff0_9;
        coeff1_0 = new_coeff1_0;
        coeff1_1 = new_coeff1_1;
        coeff1_2 = new_coeff1_2;
        coeff1_3 = new_coeff1_3;
        coeff1_4 = new_coeff1_4;
        coeff1_5 = new_coeff1_5;
        coeff1_6 = new_coeff1_6;
        coeff1_7 = new_coeff1_7;
        coeff1_8 = new_coeff1_8;
        coeff1_9 = new_coeff1_9;

        if(combinations[deriv_num][j] == 0)
        {
          new_coeff0_0 = coeff0_0*dmats0[0][0] + coeff0_1*dmats0[1][0] + coeff0_2*dmats0[2][0] + coeff0_3*dmats0[3][0] + coeff0_4*dmats0[4][0] + coeff0_5*dmats0[5][0] + coeff0_6*dmats0[6][0] + coeff0_7*dmats0[7][0] + coeff0_8*dmats0[8][0] + coeff0_9*dmats0[9][0];
          new_coeff0_1 = coeff0_0*dmats0[0][1] + coeff0_1*dmats0[1][1] + coeff0_2*dmats0[2][1] + coeff0_3*dmats0[3][1] + coeff0_4*dmats0[4][1] + coeff0_5*dmats0[5][1] + coeff0_6*dmats0[6][1] + coeff0_7*dmats0[7][1] + coeff0_8*dmats0[8][1] + coeff0_9*dmats0[9][1];
          new_coeff0_2 = coeff0_0*dmats0[0][2] + coeff0_1*dmats0[1][2] + coeff0_2*dmats0[2][2] + coeff0_3*dmats0[3][2] + coeff0_4*dmats0[4][2] + coeff0_5*dmats0[5][2] + coeff0_6*dmats0[6][2] + coeff0_7*dmats0[7][2] + coeff0_8*dmats0[8][2] + coeff0_9*dmats0[9][2];
          new_coeff0_3 = coeff0_0*dmats0[0][3] + coeff0_1*dmats0[1][3] + coeff0_2*dmats0[2][3] + coeff0_3*dmats0[3][3] + coeff0_4*dmats0[4][3] + coeff0_5*dmats0[5][3] + coeff0_6*dmats0[6][3] + coeff0_7*dmats0[7][3] + coeff0_8*dmats0[8][3] + coeff0_9*dmats0[9][3];
          new_coeff0_4 = coeff0_0*dmats0[0][4] + coeff0_1*dmats0[1][4] + coeff0_2*dmats0[2][4] + coeff0_3*dmats0[3][4] + coeff0_4*dmats0[4][4] + coeff0_5*dmats0[5][4] + coeff0_6*dmats0[6][4] + coeff0_7*dmats0[7][4] + coeff0_8*dmats0[8][4] + coeff0_9*dmats0[9][4];
          new_coeff0_5 = coeff0_0*dmats0[0][5] + coeff0_1*dmats0[1][5] + coeff0_2*dmats0[2][5] + coeff0_3*dmats0[3][5] + coeff0_4*dmats0[4][5] + coeff0_5*dmats0[5][5] + coeff0_6*dmats0[6][5] + coeff0_7*dmats0[7][5] + coeff0_8*dmats0[8][5] + coeff0_9*dmats0[9][5];
          new_coeff0_6 = coeff0_0*dmats0[0][6] + coeff0_1*dmats0[1][6] + coeff0_2*dmats0[2][6] + coeff0_3*dmats0[3][6] + coeff0_4*dmats0[4][6] + coeff0_5*dmats0[5][6] + coeff0_6*dmats0[6][6] + coeff0_7*dmats0[7][6] + coeff0_8*dmats0[8][6] + coeff0_9*dmats0[9][6];
          new_coeff0_7 = coeff0_0*dmats0[0][7] + coeff0_1*dmats0[1][7] + coeff0_2*dmats0[2][7] + coeff0_3*dmats0[3][7] + coeff0_4*dmats0[4][7] + coeff0_5*dmats0[5][7] + coeff0_6*dmats0[6][7] + coeff0_7*dmats0[7][7] + coeff0_8*dmats0[8][7] + coeff0_9*dmats0[9][7];
          new_coeff0_8 = coeff0_0*dmats0[0][8] + coeff0_1*dmats0[1][8] + coeff0_2*dmats0[2][8] + coeff0_3*dmats0[3][8] + coeff0_4*dmats0[4][8] + coeff0_5*dmats0[5][8] + coeff0_6*dmats0[6][8] + coeff0_7*dmats0[7][8] + coeff0_8*dmats0[8][8] + coeff0_9*dmats0[9][8];
          new_coeff0_9 = coeff0_0*dmats0[0][9] + coeff0_1*dmats0[1][9] + coeff0_2*dmats0[2][9] + coeff0_3*dmats0[3][9] + coeff0_4*dmats0[4][9] + coeff0_5*dmats0[5][9] + coeff0_6*dmats0[6][9] + coeff0_7*dmats0[7][9] + coeff0_8*dmats0[8][9] + coeff0_9*dmats0[9][9];
          new_coeff1_0 = coeff1_0*dmats0[0][0] + coeff1_1*dmats0[1][0] + coeff1_2*dmats0[2][0] + coeff1_3*dmats0[3][0] + coeff1_4*dmats0[4][0] + coeff1_5*dmats0[5][0] + coeff1_6*dmats0[6][0] + coeff1_7*dmats0[7][0] + coeff1_8*dmats0[8][0] + coeff1_9*dmats0[9][0];
          new_coeff1_1 = coeff1_0*dmats0[0][1] + coeff1_1*dmats0[1][1] + coeff1_2*dmats0[2][1] + coeff1_3*dmats0[3][1] + coeff1_4*dmats0[4][1] + coeff1_5*dmats0[5][1] + coeff1_6*dmats0[6][1] + coeff1_7*dmats0[7][1] + coeff1_8*dmats0[8][1] + coeff1_9*dmats0[9][1];
          new_coeff1_2 = coeff1_0*dmats0[0][2] + coeff1_1*dmats0[1][2] + coeff1_2*dmats0[2][2] + coeff1_3*dmats0[3][2] + coeff1_4*dmats0[4][2] + coeff1_5*dmats0[5][2] + coeff1_6*dmats0[6][2] + coeff1_7*dmats0[7][2] + coeff1_8*dmats0[8][2] + coeff1_9*dmats0[9][2];
          new_coeff1_3 = coeff1_0*dmats0[0][3] + coeff1_1*dmats0[1][3] + coeff1_2*dmats0[2][3] + coeff1_3*dmats0[3][3] + coeff1_4*dmats0[4][3] + coeff1_5*dmats0[5][3] + coeff1_6*dmats0[6][3] + coeff1_7*dmats0[7][3] + coeff1_8*dmats0[8][3] + coeff1_9*dmats0[9][3];
          new_coeff1_4 = coeff1_0*dmats0[0][4] + coeff1_1*dmats0[1][4] + coeff1_2*dmats0[2][4] + coeff1_3*dmats0[3][4] + coeff1_4*dmats0[4][4] + coeff1_5*dmats0[5][4] + coeff1_6*dmats0[6][4] + coeff1_7*dmats0[7][4] + coeff1_8*dmats0[8][4] + coeff1_9*dmats0[9][4];
          new_coeff1_5 = coeff1_0*dmats0[0][5] + coeff1_1*dmats0[1][5] + coeff1_2*dmats0[2][5] + coeff1_3*dmats0[3][5] + coeff1_4*dmats0[4][5] + coeff1_5*dmats0[5][5] + coeff1_6*dmats0[6][5] + coeff1_7*dmats0[7][5] + coeff1_8*dmats0[8][5] + coeff1_9*dmats0[9][5];
          new_coeff1_6 = coeff1_0*dmats0[0][6] + coeff1_1*dmats0[1][6] + coeff1_2*dmats0[2][6] + coeff1_3*dmats0[3][6] + coeff1_4*dmats0[4][6] + coeff1_5*dmats0[5][6] + coeff1_6*dmats0[6][6] + coeff1_7*dmats0[7][6] + coeff1_8*dmats0[8][6] + coeff1_9*dmats0[9][6];
          new_coeff1_7 = coeff1_0*dmats0[0][7] + coeff1_1*dmats0[1][7] + coeff1_2*dmats0[2][7] + coeff1_3*dmats0[3][7] + coeff1_4*dmats0[4][7] + coeff1_5*dmats0[5][7] + coeff1_6*dmats0[6][7] + coeff1_7*dmats0[7][7] + coeff1_8*dmats0[8][7] + coeff1_9*dmats0[9][7];
          new_coeff1_8 = coeff1_0*dmats0[0][8] + coeff1_1*dmats0[1][8] + coeff1_2*dmats0[2][8] + coeff1_3*dmats0[3][8] + coeff1_4*dmats0[4][8] + coeff1_5*dmats0[5][8] + coeff1_6*dmats0[6][8] + coeff1_7*dmats0[7][8] + coeff1_8*dmats0[8][8] + coeff1_9*dmats0[9][8];
          new_coeff1_9 = coeff1_0*dmats0[0][9] + coeff1_1*dmats0[1][9] + coeff1_2*dmats0[2][9] + coeff1_3*dmats0[3][9] + coeff1_4*dmats0[4][9] + coeff1_5*dmats0[5][9] + coeff1_6*dmats0[6][9] + coeff1_7*dmats0[7][9] + coeff1_8*dmats0[8][9] + coeff1_9*dmats0[9][9];
        }
        if(combinations[deriv_num][j] == 1)
        {
          new_coeff0_0 = coeff0_0*dmats1[0][0] + coeff0_1*dmats1[1][0] + coeff0_2*dmats1[2][0] + coeff0_3*dmats1[3][0] + coeff0_4*dmats1[4][0] + coeff0_5*dmats1[5][0] + coeff0_6*dmats1[6][0] + coeff0_7*dmats1[7][0] + coeff0_8*dmats1[8][0] + coeff0_9*dmats1[9][0];
          new_coeff0_1 = coeff0_0*dmats1[0][1] + coeff0_1*dmats1[1][1] + coeff0_2*dmats1[2][1] + coeff0_3*dmats1[3][1] + coeff0_4*dmats1[4][1] + coeff0_5*dmats1[5][1] + coeff0_6*dmats1[6][1] + coeff0_7*dmats1[7][1] + coeff0_8*dmats1[8][1] + coeff0_9*dmats1[9][1];
          new_coeff0_2 = coeff0_0*dmats1[0][2] + coeff0_1*dmats1[1][2] + coeff0_2*dmats1[2][2] + coeff0_3*dmats1[3][2] + coeff0_4*dmats1[4][2] + coeff0_5*dmats1[5][2] + coeff0_6*dmats1[6][2] + coeff0_7*dmats1[7][2] + coeff0_8*dmats1[8][2] + coeff0_9*dmats1[9][2];
          new_coeff0_3 = coeff0_0*dmats1[0][3] + coeff0_1*dmats1[1][3] + coeff0_2*dmats1[2][3] + coeff0_3*dmats1[3][3] + coeff0_4*dmats1[4][3] + coeff0_5*dmats1[5][3] + coeff0_6*dmats1[6][3] + coeff0_7*dmats1[7][3] + coeff0_8*dmats1[8][3] + coeff0_9*dmats1[9][3];
          new_coeff0_4 = coeff0_0*dmats1[0][4] + coeff0_1*dmats1[1][4] + coeff0_2*dmats1[2][4] + coeff0_3*dmats1[3][4] + coeff0_4*dmats1[4][4] + coeff0_5*dmats1[5][4] + coeff0_6*dmats1[6][4] + coeff0_7*dmats1[7][4] + coeff0_8*dmats1[8][4] + coeff0_9*dmats1[9][4];
          new_coeff0_5 = coeff0_0*dmats1[0][5] + coeff0_1*dmats1[1][5] + coeff0_2*dmats1[2][5] + coeff0_3*dmats1[3][5] + coeff0_4*dmats1[4][5] + coeff0_5*dmats1[5][5] + coeff0_6*dmats1[6][5] + coeff0_7*dmats1[7][5] + coeff0_8*dmats1[8][5] + coeff0_9*dmats1[9][5];
          new_coeff0_6 = coeff0_0*dmats1[0][6] + coeff0_1*dmats1[1][6] + coeff0_2*dmats1[2][6] + coeff0_3*dmats1[3][6] + coeff0_4*dmats1[4][6] + coeff0_5*dmats1[5][6] + coeff0_6*dmats1[6][6] + coeff0_7*dmats1[7][6] + coeff0_8*dmats1[8][6] + coeff0_9*dmats1[9][6];
          new_coeff0_7 = coeff0_0*dmats1[0][7] + coeff0_1*dmats1[1][7] + coeff0_2*dmats1[2][7] + coeff0_3*dmats1[3][7] + coeff0_4*dmats1[4][7] + coeff0_5*dmats1[5][7] + coeff0_6*dmats1[6][7] + coeff0_7*dmats1[7][7] + coeff0_8*dmats1[8][7] + coeff0_9*dmats1[9][7];
          new_coeff0_8 = coeff0_0*dmats1[0][8] + coeff0_1*dmats1[1][8] + coeff0_2*dmats1[2][8] + coeff0_3*dmats1[3][8] + coeff0_4*dmats1[4][8] + coeff0_5*dmats1[5][8] + coeff0_6*dmats1[6][8] + coeff0_7*dmats1[7][8] + coeff0_8*dmats1[8][8] + coeff0_9*dmats1[9][8];
          new_coeff0_9 = coeff0_0*dmats1[0][9] + coeff0_1*dmats1[1][9] + coeff0_2*dmats1[2][9] + coeff0_3*dmats1[3][9] + coeff0_4*dmats1[4][9] + coeff0_5*dmats1[5][9] + coeff0_6*dmats1[6][9] + coeff0_7*dmats1[7][9] + coeff0_8*dmats1[8][9] + coeff0_9*dmats1[9][9];
          new_coeff1_0 = coeff1_0*dmats1[0][0] + coeff1_1*dmats1[1][0] + coeff1_2*dmats1[2][0] + coeff1_3*dmats1[3][0] + coeff1_4*dmats1[4][0] + coeff1_5*dmats1[5][0] + coeff1_6*dmats1[6][0] + coeff1_7*dmats1[7][0] + coeff1_8*dmats1[8][0] + coeff1_9*dmats1[9][0];
          new_coeff1_1 = coeff1_0*dmats1[0][1] + coeff1_1*dmats1[1][1] + coeff1_2*dmats1[2][1] + coeff1_3*dmats1[3][1] + coeff1_4*dmats1[4][1] + coeff1_5*dmats1[5][1] + coeff1_6*dmats1[6][1] + coeff1_7*dmats1[7][1] + coeff1_8*dmats1[8][1] + coeff1_9*dmats1[9][1];
          new_coeff1_2 = coeff1_0*dmats1[0][2] + coeff1_1*dmats1[1][2] + coeff1_2*dmats1[2][2] + coeff1_3*dmats1[3][2] + coeff1_4*dmats1[4][2] + coeff1_5*dmats1[5][2] + coeff1_6*dmats1[6][2] + coeff1_7*dmats1[7][2] + coeff1_8*dmats1[8][2] + coeff1_9*dmats1[9][2];
          new_coeff1_3 = coeff1_0*dmats1[0][3] + coeff1_1*dmats1[1][3] + coeff1_2*dmats1[2][3] + coeff1_3*dmats1[3][3] + coeff1_4*dmats1[4][3] + coeff1_5*dmats1[5][3] + coeff1_6*dmats1[6][3] + coeff1_7*dmats1[7][3] + coeff1_8*dmats1[8][3] + coeff1_9*dmats1[9][3];
          new_coeff1_4 = coeff1_0*dmats1[0][4] + coeff1_1*dmats1[1][4] + coeff1_2*dmats1[2][4] + coeff1_3*dmats1[3][4] + coeff1_4*dmats1[4][4] + coeff1_5*dmats1[5][4] + coeff1_6*dmats1[6][4] + coeff1_7*dmats1[7][4] + coeff1_8*dmats1[8][4] + coeff1_9*dmats1[9][4];
          new_coeff1_5 = coeff1_0*dmats1[0][5] + coeff1_1*dmats1[1][5] + coeff1_2*dmats1[2][5] + coeff1_3*dmats1[3][5] + coeff1_4*dmats1[4][5] + coeff1_5*dmats1[5][5] + coeff1_6*dmats1[6][5] + coeff1_7*dmats1[7][5] + coeff1_8*dmats1[8][5] + coeff1_9*dmats1[9][5];
          new_coeff1_6 = coeff1_0*dmats1[0][6] + coeff1_1*dmats1[1][6] + coeff1_2*dmats1[2][6] + coeff1_3*dmats1[3][6] + coeff1_4*dmats1[4][6] + coeff1_5*dmats1[5][6] + coeff1_6*dmats1[6][6] + coeff1_7*dmats1[7][6] + coeff1_8*dmats1[8][6] + coeff1_9*dmats1[9][6];
          new_coeff1_7 = coeff1_0*dmats1[0][7] + coeff1_1*dmats1[1][7] + coeff1_2*dmats1[2][7] + coeff1_3*dmats1[3][7] + coeff1_4*dmats1[4][7] + coeff1_5*dmats1[5][7] + coeff1_6*dmats1[6][7] + coeff1_7*dmats1[7][7] + coeff1_8*dmats1[8][7] + coeff1_9*dmats1[9][7];
          new_coeff1_8 = coeff1_0*dmats1[0][8] + coeff1_1*dmats1[1][8] + coeff1_2*dmats1[2][8] + coeff1_3*dmats1[3][8] + coeff1_4*dmats1[4][8] + coeff1_5*dmats1[5][8] + coeff1_6*dmats1[6][8] + coeff1_7*dmats1[7][8] + coeff1_8*dmats1[8][8] + coeff1_9*dmats1[9][8];
          new_coeff1_9 = coeff1_0*dmats1[0][9] + coeff1_1*dmats1[1][9] + coeff1_2*dmats1[2][9] + coeff1_3*dmats1[3][9] + coeff1_4*dmats1[4][9] + coeff1_5*dmats1[5][9] + coeff1_6*dmats1[6][9] + coeff1_7*dmats1[7][9] + coeff1_8*dmats1[8][9] + coeff1_9*dmats1[9][9];
        }

      }
      // Compute derivatives on reference element as dot product of coefficients and basisvalues
      // Correct values by the covariant Piola transform
      const double tmp0_0 = new_coeff0_0*basisvalue0 + new_coeff0_1*basisvalue1 + new_coeff0_2*basisvalue2 + new_coeff0_3*basisvalue3 + new_coeff0_4*basisvalue4 + new_coeff0_5*basisvalue5 + new_coeff0_6*basisvalue6 + new_coeff0_7*basisvalue7 + new_coeff0_8*basisvalue8 + new_coeff0_9*basisvalue9;
      const double tmp0_1 = new_coeff1_0*basisvalue0 + new_coeff1_1*basisvalue1 + new_coeff1_2*basisvalue2 + new_coeff1_3*basisvalue3 + new_coeff1_4*basisvalue4 + new_coeff1_5*basisvalue5 + new_coeff1_6*basisvalue6 + new_coeff1_7*basisvalue7 + new_coeff1_8*basisvalue8 + new_coeff1_9*basisvalue9;
      derivatives[deriv_num] = (Jinv_00*tmp0_0 + Jinv_10*tmp0_1);
      derivatives[num_derivatives + deriv_num] = (Jinv_01*tmp0_0 + Jinv_11*tmp0_1);
    }

    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
        values[num_derivatives + row] += transform[row][col]*derivatives[num_derivatives + col];
      }
    }
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;

    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      delete [] combinations[row];
      delete [] transform[row];
    }

    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    throw std::runtime_error("The vectorised version of evaluate_basis_derivatives() is not yet implemented.");
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // The reference points, direction and weights:
    const static double X[15][16][2] = {{{0.75, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.25}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0.75}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.25, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.75, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}, {{0.0654669945550145, 0.0571041961145177}, {0.0502101232113698, 0.276843013638124}, {0.028912084224389, 0.583590432368917}, {0.00970378512694614, 0.860240135656219}, {0.311164552244357, 0.0571041961145177}, {0.238648659731443, 0.276843013638124}, {0.137419104134574, 0.583590432368917}, {0.0461220799064521, 0.860240135656219}, {0.631731251641125, 0.0571041961145177}, {0.484508326630433, 0.276843013638124}, {0.278990463496509, 0.583590432368917}, {0.0936377844373285, 0.860240135656219}, {0.877428809330468, 0.0571041961145177}, {0.672946863150506, 0.276843013638124}, {0.387497483406694, 0.583590432368917}, {0.130056079216834, 0.860240135656219}}};
    const static double W[15][16] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}, {0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.176740354089447, 0.265376864428199, 0.169358898086985, 0.0406690382579151, 0.0942734727735292, 0.141552271592344, 0.0903361971294796, 0.021692903642101}};
    const static double D[15][16][2] = {{{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}, {0.353553390593274, 0}}, {{-0.703179558498458, 0}, {-0.539305836657196, 0}, {-0.31054406511806, 0}, {-0.104228144085579, 0}, {-0.277618905284931, 0}, {-0.212920717300506, 0}, {-0.122604393655731, 0}, {-0.0411498072024544, 0}, {0.277618905284931, 0}, {0.212920717300506, 0}, {0.122604393655731, 0}, {0.0411498072024544, 0}, {0.703179558498457, 0}, {0.539305836657195, 0}, {0.31054406511806, 0}, {0.104228144085579, 0}}, {{-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}, {-0.414343705828224, 0}, {-0.0847354795428142, 0}, {0.375385648553375, 0}, {0.790360203484329, 0}}, {{0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}, {0, 0.353553390593274}}, {{0, -0.703179558498458}, {0, -0.539305836657196}, {0, -0.31054406511806}, {0, -0.104228144085579}, {0, -0.277618905284931}, {0, -0.212920717300506}, {0, -0.122604393655731}, {0, -0.0411498072024544}, {0, 0.277618905284931}, {0, 0.212920717300506}, {0, 0.122604393655731}, {0, 0.0411498072024544}, {0, 0.703179558498457}, {0, 0.539305836657195}, {0, 0.31054406511806}, {0, 0.104228144085579}}, {{0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}, {0, -0.414343705828224}, {0, -0.0847354795428142}, {0, 0.375385648553375}, {0, 0.790360203484329}}};

    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    double copyofvalues[2];
    double result = 0.0;
    // Iterate over the points:
    static const unsigned int ns[15] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 16, 16, 16, 16};
    for (unsigned int j = 0; j < ns[i]; j++) {
      // Evaluate basis functions for affine mapping
      const double w0 = 1.0 - X[i][j][0] - X[i][j][1];
      const double w1 = X[i][j][0];
      const double w2 = X[i][j][1];

      // Compute affine mapping y = F(X)
      double y[2];
      y[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0];
      y[1] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1];

      // Evaluate function at physical points
      double values[2];
      f.evaluate(values, y, c);

      // Map function values using appropriate mapping
      // Copy old values:
      copyofvalues[0] = values[0];
      copyofvalues[1] = values[1];
      // Do the inverse of curl piola
      values[0] = J_00*copyofvalues[0]+J_10*copyofvalues[1];
      values[1] = J_01*copyofvalues[0]+J_11*copyofvalues[1];

      // Note that we do not map the weights (yet).

      // Take directional components
      for(int k = 0; k < 2; k++)
        result += values[k]*D[i][j][k];
      // Multiply by weights
      result *= W[i][j];

    } // End for
    return result;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;
    // Evaluate at vertices and use Piola mapping
    vertex_values[0] = (dof_values[3]*3*Jinv_10 + dof_values[4]*(-3*Jinv_10) + dof_values[5]*Jinv_10 + dof_values[6]*3*Jinv_00 + dof_values[7]*(-3*Jinv_00) + dof_values[8]*Jinv_00);
    vertex_values[2] = (dof_values[0]*3*Jinv_10 + dof_values[1]*(-3*Jinv_10) + dof_values[2]*Jinv_10 + dof_values[6]*(Jinv_00 + Jinv_10) + dof_values[7]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[8]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[4] = (dof_values[0]*Jinv_00 + dof_values[1]*3*Jinv_00 + dof_values[2]*(-3*Jinv_00) + dof_values[3]*(Jinv_00 + Jinv_10) + dof_values[4]*(-3*Jinv_00 - 3*Jinv_10) + dof_values[5]*(3*Jinv_00 + 3*Jinv_10));
    vertex_values[1] = (dof_values[3]*3*Jinv_11 + dof_values[4]*(-3*Jinv_11) + dof_values[5]*Jinv_11 + dof_values[6]*3*Jinv_01 + dof_values[7]*(-3*Jinv_01) + dof_values[8]*Jinv_01);
    vertex_values[3] = (dof_values[0]*3*Jinv_11 + dof_values[1]*(-3*Jinv_11) + dof_values[2]*Jinv_11 + dof_values[6]*(Jinv_01 + Jinv_11) + dof_values[7]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[8]*(3*Jinv_01 + 3*Jinv_11));
    vertex_values[5] = (dof_values[0]*Jinv_01 + dof_values[1]*3*Jinv_01 + dof_values[2]*(-3*Jinv_01) + dof_values[3]*(Jinv_01 + Jinv_11) + dof_values[4]*(-3*Jinv_01 - 3*Jinv_11) + dof_values[5]*(3*Jinv_01 + 3*Jinv_11));
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new UFC_Forms_1_finite_element_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class UFC_Forms_1_dof_map_0: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  UFC_Forms_1_dof_map_0() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~UFC_Forms_1_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new UFC_Forms_1_dof_map_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class UFC_Forms_1_dof_map_1: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  UFC_Forms_1_dof_map_1() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~UFC_Forms_1_dof_map_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for FiniteElement('Nedelec', 'triangle', 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      return false;
      break;
    case 1:
      return true;
      break;
    case 2:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 3*m.num_entities[1] + 6*m.num_entities[2];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 15;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[1][0];
    dofs[1] = 3*c.entity_indices[1][0] + 1;
    dofs[2] = 3*c.entity_indices[1][0] + 2;
    dofs[3] = 3*c.entity_indices[1][1];
    dofs[4] = 3*c.entity_indices[1][1] + 1;
    dofs[5] = 3*c.entity_indices[1][1] + 2;
    dofs[6] = 3*c.entity_indices[1][2];
    dofs[7] = 3*c.entity_indices[1][2] + 1;
    dofs[8] = 3*c.entity_indices[1][2] + 2;
    unsigned int offset = 3*m.num_entities[1];
    dofs[9] = offset + 6*c.entity_indices[2][0];
    dofs[10] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[12] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[13] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[14] = offset + 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      break;
    case 1:
      dofs[0] = 3;
      dofs[1] = 4;
      dofs[2] = 5;
      break;
    case 2:
      dofs[0] = 6;
      dofs[1] = 7;
      dofs[2] = 8;
      break;
    }
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    throw std::runtime_error("Not implemented (introduced in UFC v1.1).");
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    coordinates[0][0] = 0.75*x[1][0] + 0.25*x[2][0];
    coordinates[0][1] = 0.75*x[1][1] + 0.25*x[2][1];
    coordinates[1][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[1][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[2][0] = 0.25*x[1][0] + 0.75*x[2][0];
    coordinates[2][1] = 0.25*x[1][1] + 0.75*x[2][1];
    coordinates[3][0] = 0.75*x[0][0] + 0.25*x[2][0];
    coordinates[3][1] = 0.75*x[0][1] + 0.25*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.25*x[0][0] + 0.75*x[2][0];
    coordinates[5][1] = 0.25*x[0][1] + 0.75*x[2][1];
    coordinates[6][0] = 0.75*x[0][0] + 0.25*x[1][0];
    coordinates[6][1] = 0.75*x[0][1] + 0.25*x[1][1];
    coordinates[7][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[7][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[8][0] = 0.25*x[0][0] + 0.75*x[1][0];
    coordinates[8][1] = 0.25*x[0][1] + 0.75*x[1][1];
    coordinates[9][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[9][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[10][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[10][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[11][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[11][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[12][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[12][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[13][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[13][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
    coordinates[14][0] = 0.877428809330468*x[0][0] + 0.0654669945550145*x[1][0] + 0.0571041961145176*x[2][0];
    coordinates[14][1] = 0.877428809330468*x[0][1] + 0.0654669945550145*x[1][1] + 0.0571041961145176*x[2][1];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 1;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return new UFC_Forms_1_dof_map_1();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class UFC_Forms_1_cell_integral_0_quadrature: public ufc::cell_integral
{
public:

  /// Constructor
  UFC_Forms_1_cell_integral_0_quadrature() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_1_cell_integral_0_quadrature()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;

    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];

    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;

    // Compute inverse of Jacobian
    const double Jinv_00 =  J_11 / detJ;
    const double Jinv_01 = -J_01 / detJ;
    const double Jinv_10 = -J_10 / detJ;
    const double Jinv_11 =  J_00 / detJ;

    // Set scale factor
    const double det = std::abs(detJ);


    // Array of quadrature weights
    const static double W9[9] = {0.0558144204830443, 0.063678085099885, 0.0193963833059595, 0.0893030727728709, 0.101884936159816, 0.0310342132895351, 0.0558144204830443, 0.063678085099885, 0.0193963833059595};


    const static double FE0_C1[9][15] = \
    {{0.259023866937095, -0.0960305636781282, 0.116692005963408, 0.724015946718076, -0.885744716773463, 0.279351001235802, 0.244627742842204, -0.351902037435719, 0.131088130058299, 0.361856908412377, 0.804348551088313, 0.113815188691413, 0.852335850302373, -2.46444848726039, -0.985284573642624},
    {0.124502553734718, -0.0808647165039715, -0.0517228071606004, -0.188646394988283, 0.873826172861248, -0.310960388148289, -0.0364738651885727, -0.111362600448026, 0.109253611762691, 0.0431305210973629, -0.113795333508158, -0.349588719020649, 0.896421300247654, -0.969084720026754, 0.538475797932574},
    {0.0478876429125125, -0.0989226076312369, 0.0426202402577571, 0.0863904947524046, -0.410448523101372, 1.07492747043846, 0.00934233408501125, -0.0323667952857454, 0.0811655490852584, -0.0941241324737536, -0.134414483330479, 0.0999663473259482, 0.364224031254948, -0.115310537645325, 0.508597693389607},
    {-0.386672749090734, 0.137886692621508, 0.0473455170334457, -0.453427542853825, 0.0346025154907121, 0.178225017656975, -0.106199694056532, 0.444977114801463, -0.233127538000757, -0.434291439921772, -0.504930618570297, 0.660886625238839, 2.03935330208845, -0.238982511703568, -2.62493793373433},
    {-0.0912778190067012, 0.1274967305193, -0.226645322886458, -0.408902906136359, 0.491350341036593, -0.536951510597235, -0.236272273605301, 0.146750631956986, -0.0816508682878581, -0.0272291285417706, -0.480408652343291, -0.735822687065841, 2.32628300397659, -0.463734284576293, 1.49685583622622},
    {0.129408294044957, -0.337978175327396, 0.219970359788872, 0.200668641410009, -0.698256063524389, 0.593566143086032, 0.0966993729096462, -0.0914362015689451, 0.252679280924183, -0.348663002983434, -0.328847967190785, 0.663128481652074, 1.26235644215442, -0.11533635481681, 1.89338821995709},
    {0.518127355724342, -0.568317652041819, 0.156199779838856, 0.350112734903822, -0.183858182355758, 0.354642950387362, 0.115461556587762, -0.486841205539632, 0.558865578975436, -0.11522509565736, -0.270946008465746, -0.0619100202597189, 0.527633199779436, 2.8468205059861, -1.55928318877766},
    {-0.235216808228257, 0.59579448940502, -0.150513959010439, 0.278021762017085, -0.0167306231325305, -0.319118031340845, 0.106398985071943, 0.0819686012402573, -0.492129752310639, 0.72665953974101, 1.32716840336024, -0.270406336003824, 1.19891817310448, 1.71105957534882, 1.07321977314454},
    {0.131972765012883, -0.443670611357443, 0.456637276554166, 0.4437497714657, -0.948589317002497, 0.219466035328385, 0.300235083336346, -0.130866224921804, 0.288374958230702, -0.442372205667075, -0.00958291829179892, 1.54742383081202, 1.6128173429268, 0.29984870535222, 2.71581968745794}};

    const static double FE0_C0[9][15] = \
    {{-0.0910888679667272, 0.0878276186776296, -0.237950944423953, 0.205888590993734, -0.317427064731644, 0.123151221396946, 0.80349332181764, -0.838743242975351, 0.246549686646061, 0.774265012534454, -1.77152594643204, -1.50737802034597, 0.324702650522937, 0.382372018725709, 0.573998615135036},
    {-0.153519208282366, -0.0641340933714411, 0.267395224180244, 0.0465704132399732, 0.278031683456228, -0.160446429137851, -0.528603617499211, -0.0293939992077694, 0.215652596834634, 1.96870823394285, -3.15202331221722, 0.453224718120067, -0.302496872856826, 0.74197485532207, -0.534743975211966},
    {-0.395862128553188, 0.84966670937126, -0.176845795070627, -0.045582270260478, 0.0332220882560721, 0.618290193884293, 0.297717292315714, -0.16323302020755, 0.381400632421605, 1.07632100478597, -0.424680270390902, 4.36320986559591, -1.24859331167185, 0.184538167706896, -2.20722199406833},
    {0.0667547937630913, 0.103284177130796, -0.130879500623529, -0.0667547937630914, -0.103284177130796, 0.130879500623529, -0.339327232057288, 0.889954229602926, -0.339327232057288, 1.1707704222449, 0.238982511703568, -1.30316468325665, 0, -0.477965023407136, 0},
    {0.317625087129658, -0.363853610517293, 0.310306187710777, -0.317625087129658, 0.363853610517293, -0.310306187710777, -0.31792314189316, 0.293501263913972, -0.317923141893159, 2.27182474689305, 0.463734284576293, 0.0252104620945346, 0, -0.927468569152587, 0},
    {-0.0712603473650515, 0.360277888196993, -0.37359578329716, 0.0712603473650516, -0.360277888196993, 0.37359578329716, 0.349378653833829, -0.18287240313789, 0.349378653833829, 0.565030436187554, 0.11533635481681, 3.21964518326124, 0, -0.23067270963362, 0},
    {-0.205888590993734, 0.317427064731644, -0.123151221396946, 0.0910888679667274, -0.0878276186776293, 0.237950944423953, 0.246549686646061, -0.838743242975351, 0.80349332181764, 1.09896766305739, 1.38915392770633, -0.93337940521093, -0.324702650522937, 0.382372018725709, -0.573998615135036},
    {-0.0465704132399731, -0.278031683456227, 0.160446429137851, 0.153519208282366, 0.0641340933714411, -0.267395224180244, 0.215652596834634, -0.0293939992077694, -0.528603617499212, 1.66621136108603, 2.41004845689515, -0.0815192570919004, 0.302496872856826, 0.74197485532207, 0.534743975211966},
    {0.0455822702604784, -0.0332220882560718, -0.618290193884293, 0.395862128553187, -0.849666709371259, 0.176845795070627, 0.381400632421605, -0.16323302020755, 0.297717292315714, -0.172272306885879, 0.240142102684006, 2.15598787152757, 1.24859331167185, 0.184538167706895, 2.20722199406833}};

    // Number of operations to compute geometry constants: 12
    const double G0 = det*(Jinv_10*Jinv_10 + Jinv_11*Jinv_11);
    const double G1 = det*(Jinv_00*Jinv_10 + Jinv_01*Jinv_11);
    const double G2 = det*(Jinv_00*Jinv_00 + Jinv_01*Jinv_01);

    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('simplify expressions', True), ('ignore zero tables', True), ('non zero columns', True), ('remove zero terms', True), ('ignore ones', True)
    // Total number of operations to compute element tensor: 24339

    // Loop quadrature points for integral
    // Number of operations to compute element tensor for following IP loop = 24327
    for (unsigned int ip = 0; ip < 9; ip++)
    {

      // Number of operations to compute ip constants: 3
      // Number of operations: 1
      const double Gip0 = W9[ip]*G0;

      // Number of operations: 1
      const double Gip1 = W9[ip]*G1;

      // Number of operations: 1
      const double Gip2 = W9[ip]*G2;


      // Number of operations for primary indices = 2700
      for (unsigned int j = 0; j < 15; j++)
      {
        for (unsigned int k = 0; k < 15; k++)
        {
          // Number of operations to compute entry = 12
          A[j*15 + k] += (FE0_C0[ip][j]*FE0_C0[ip][k]*Gip2 + FE0_C0[ip][j]*FE0_C1[ip][k]*Gip1 + FE0_C0[ip][k]*FE0_C1[ip][j]*Gip1 + FE0_C1[ip][j]*FE0_C1[ip][k]*Gip0);
        }// end loop over 'k'
      }// end loop over 'j'
    }// end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class UFC_Forms_1_cell_integral_0: public ufc::cell_integral
{
private:

  UFC_Forms_1_cell_integral_0_quadrature integral_0_quadrature;

public:

  /// Constructor
  UFC_Forms_1_cell_integral_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_1_cell_integral_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Reset values of the element tensor block
    A[0] = 0;
    A[1] = 0;
    A[2] = 0;
    A[3] = 0;
    A[4] = 0;
    A[5] = 0;
    A[6] = 0;
    A[7] = 0;
    A[8] = 0;
    A[9] = 0;
    A[10] = 0;
    A[11] = 0;
    A[12] = 0;
    A[13] = 0;
    A[14] = 0;
    A[15] = 0;
    A[16] = 0;
    A[17] = 0;
    A[18] = 0;
    A[19] = 0;
    A[20] = 0;
    A[21] = 0;
    A[22] = 0;
    A[23] = 0;
    A[24] = 0;
    A[25] = 0;
    A[26] = 0;
    A[27] = 0;
    A[28] = 0;
    A[29] = 0;
    A[30] = 0;
    A[31] = 0;
    A[32] = 0;
    A[33] = 0;
    A[34] = 0;
    A[35] = 0;
    A[36] = 0;
    A[37] = 0;
    A[38] = 0;
    A[39] = 0;
    A[40] = 0;
    A[41] = 0;
    A[42] = 0;
    A[43] = 0;
    A[44] = 0;
    A[45] = 0;
    A[46] = 0;
    A[47] = 0;
    A[48] = 0;
    A[49] = 0;
    A[50] = 0;
    A[51] = 0;
    A[52] = 0;
    A[53] = 0;
    A[54] = 0;
    A[55] = 0;
    A[56] = 0;
    A[57] = 0;
    A[58] = 0;
    A[59] = 0;
    A[60] = 0;
    A[61] = 0;
    A[62] = 0;
    A[63] = 0;
    A[64] = 0;
    A[65] = 0;
    A[66] = 0;
    A[67] = 0;
    A[68] = 0;
    A[69] = 0;
    A[70] = 0;
    A[71] = 0;
    A[72] = 0;
    A[73] = 0;
    A[74] = 0;
    A[75] = 0;
    A[76] = 0;
    A[77] = 0;
    A[78] = 0;
    A[79] = 0;
    A[80] = 0;
    A[81] = 0;
    A[82] = 0;
    A[83] = 0;
    A[84] = 0;
    A[85] = 0;
    A[86] = 0;
    A[87] = 0;
    A[88] = 0;
    A[89] = 0;
    A[90] = 0;
    A[91] = 0;
    A[92] = 0;
    A[93] = 0;
    A[94] = 0;
    A[95] = 0;
    A[96] = 0;
    A[97] = 0;
    A[98] = 0;
    A[99] = 0;
    A[100] = 0;
    A[101] = 0;
    A[102] = 0;
    A[103] = 0;
    A[104] = 0;
    A[105] = 0;
    A[106] = 0;
    A[107] = 0;
    A[108] = 0;
    A[109] = 0;
    A[110] = 0;
    A[111] = 0;
    A[112] = 0;
    A[113] = 0;
    A[114] = 0;
    A[115] = 0;
    A[116] = 0;
    A[117] = 0;
    A[118] = 0;
    A[119] = 0;
    A[120] = 0;
    A[121] = 0;
    A[122] = 0;
    A[123] = 0;
    A[124] = 0;
    A[125] = 0;
    A[126] = 0;
    A[127] = 0;
    A[128] = 0;
    A[129] = 0;
    A[130] = 0;
    A[131] = 0;
    A[132] = 0;
    A[133] = 0;
    A[134] = 0;
    A[135] = 0;
    A[136] = 0;
    A[137] = 0;
    A[138] = 0;
    A[139] = 0;
    A[140] = 0;
    A[141] = 0;
    A[142] = 0;
    A[143] = 0;
    A[144] = 0;
    A[145] = 0;
    A[146] = 0;
    A[147] = 0;
    A[148] = 0;
    A[149] = 0;
    A[150] = 0;
    A[151] = 0;
    A[152] = 0;
    A[153] = 0;
    A[154] = 0;
    A[155] = 0;
    A[156] = 0;
    A[157] = 0;
    A[158] = 0;
    A[159] = 0;
    A[160] = 0;
    A[161] = 0;
    A[162] = 0;
    A[163] = 0;
    A[164] = 0;
    A[165] = 0;
    A[166] = 0;
    A[167] = 0;
    A[168] = 0;
    A[169] = 0;
    A[170] = 0;
    A[171] = 0;
    A[172] = 0;
    A[173] = 0;
    A[174] = 0;
    A[175] = 0;
    A[176] = 0;
    A[177] = 0;
    A[178] = 0;
    A[179] = 0;
    A[180] = 0;
    A[181] = 0;
    A[182] = 0;
    A[183] = 0;
    A[184] = 0;
    A[185] = 0;
    A[186] = 0;
    A[187] = 0;
    A[188] = 0;
    A[189] = 0;
    A[190] = 0;
    A[191] = 0;
    A[192] = 0;
    A[193] = 0;
    A[194] = 0;
    A[195] = 0;
    A[196] = 0;
    A[197] = 0;
    A[198] = 0;
    A[199] = 0;
    A[200] = 0;
    A[201] = 0;
    A[202] = 0;
    A[203] = 0;
    A[204] = 0;
    A[205] = 0;
    A[206] = 0;
    A[207] = 0;
    A[208] = 0;
    A[209] = 0;
    A[210] = 0;
    A[211] = 0;
    A[212] = 0;
    A[213] = 0;
    A[214] = 0;
    A[215] = 0;
    A[216] = 0;
    A[217] = 0;
    A[218] = 0;
    A[219] = 0;
    A[220] = 0;
    A[221] = 0;
    A[222] = 0;
    A[223] = 0;
    A[224] = 0;

    // Add all contributions to element tensor
    integral_0_quadrature.tabulate_tensor(A, w, c);
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class UFC_Forms_1: public ufc::form
{
public:

  /// Constructor
  UFC_Forms_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~UFC_Forms_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(IndexSum(Product(Indexed(BasisFunction(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1), 2), 0), MultiIndex((Index(0),), {Index(0): 2})), Indexed(BasisFunction(FiniteElement('Nedelec 1st kind H(curl)', Cell('triangle', 1), 2), 1), MultiIndex((Index(0),), {Index(0): 2}))), MultiIndex((Index(0),), {Index(0): 2})), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 0;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      return new UFC_Forms_1_finite_element_0();
      break;
    case 1:
      return new UFC_Forms_1_finite_element_1();
      break;
    }
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      return new UFC_Forms_1_dof_map_0();
      break;
    case 1:
      return new UFC_Forms_1_dof_map_1();
      break;
    }
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return new UFC_Forms_1_cell_integral_0();
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

// DOLFIN wrappers

#include <dolfin/fem/Form.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/function/Coefficient.h>
#include <dolfin/function/Function.h>
#include <dolfin/function/FunctionSpace.h>

class Forms_0FunctionSpace0 : public dolfin::FunctionSpace
{
public:

  Forms_0FunctionSpace0(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class Forms_0FunctionSpace1 : public dolfin::FunctionSpace
{
public:

  Forms_0FunctionSpace1(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class Forms_1FunctionSpace0 : public dolfin::FunctionSpace
{
public:

  Forms_1FunctionSpace0(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class Forms_1FunctionSpace1 : public dolfin::FunctionSpace
{
public:

  Forms_1FunctionSpace1(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class FormsTestSpace : public dolfin::FunctionSpace
{
public:

  FormsTestSpace(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class FormsTrialSpace : public dolfin::FunctionSpace
{
public:

  FormsTrialSpace(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class FormsFunctionSpace : public dolfin::FunctionSpace
{
public:

  FormsFunctionSpace(const dolfin::Mesh& mesh)
    : dolfin::FunctionSpace(boost::shared_ptr<const dolfin::Mesh>(&mesh, dolfin::NoDeleter<const dolfin::Mesh>()),
                            boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new UFC_Forms_1_finite_element_1()))),
                            boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new UFC_Forms_1_dof_map_1()), mesh)))
  {
    // Do nothing
  }

};

class Forms_0 : public dolfin::Form
{
public:

  // Create form on given function space(s)
  Forms_0(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1) : dolfin::Form()
  {
    boost::shared_ptr<const dolfin::FunctionSpace> _V0(&V0, dolfin::NoDeleter<const dolfin::FunctionSpace>());
    _function_spaces.push_back(_V0);
    boost::shared_ptr<const dolfin::FunctionSpace> _V1(&V1, dolfin::NoDeleter<const dolfin::FunctionSpace>());
    _function_spaces.push_back(_V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new UFC_Forms_0());
  }

  // Create form on given function space(s) (shared data)
  Forms_0(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1) : dolfin::Form()
  {
    _function_spaces.push_back(V0);
    _function_spaces.push_back(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new UFC_Forms_0());
  }

  // Destructor
  ~Forms_0() {}

};

class Forms_1 : public dolfin::Form
{
public:

  // Create form on given function space(s)
  Forms_1(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1) : dolfin::Form()
  {
    boost::shared_ptr<const dolfin::FunctionSpace> _V0(&V0, dolfin::NoDeleter<const dolfin::FunctionSpace>());
    _function_spaces.push_back(_V0);
    boost::shared_ptr<const dolfin::FunctionSpace> _V1(&V1, dolfin::NoDeleter<const dolfin::FunctionSpace>());
    _function_spaces.push_back(_V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new UFC_Forms_1());
  }

  // Create form on given function space(s) (shared data)
  Forms_1(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1) : dolfin::Form()
  {
    _function_spaces.push_back(V0);
    _function_spaces.push_back(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new UFC_Forms_1());
  }

  // Destructor
  ~Forms_1() {}

};

#endif
