// This code conforms with the UFC specification version 1.2
// and was automatically generated by FFC version 0.9.0-beta.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.

#ifndef __HYPERELASTICITY_H
#define __HYPERELASTICITY_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class hyperelasticity_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  hyperelasticity_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('tetrahedron', 1, Space(3)), 0)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute sub determinants
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    
    // Reset values
    *values = 0.000000000000000;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues
    double basisvalues[1] = {0.000000000000000};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.000000000000000;
    
    // Table(s) of coefficients
    static const double coefficients0[1][1] = \
    {{1.000000000000000}};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[dof][r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, coordinates, c);
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    const double K_00 = d_00 / detJ;
    const double K_01 = d_10 / detJ;
    const double K_02 = d_20 / detJ;
    const double K_10 = d_01 / detJ;
    const double K_11 = d_11 / detJ;
    const double K_12 = d_21 / detJ;
    const double K_20 = d_02 / detJ;
    const double K_21 = d_12 / detJ;
    const double K_22 = d_22 / detJ;
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    
    // Compute number of derivatives.
    unsigned int  num_derivatives = 1;
    
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K_00, K_01, K_02}, {K_10, K_11, K_12}, {K_20, K_21, K_22}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues
    double basisvalues[1] = {0.000000000000000};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.000000000000000;
    
    // Table(s) of coefficients
    static const double coefficients0[1][1] = \
    {{1.000000000000000}};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[1][1] = \
    {{0.000000000000000}};
    
    static const double dmats1[1][1] = \
    {{0.000000000000000}};
    
    static const double dmats2[1][1] = \
    {{0.000000000000000}};
    
    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[1][1] = \
    {{1.000000000000000}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[1][1] = \
    {{1.000000000000000}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 1; t++)
      {
        for (unsigned int u = 0; u < 1; u++)
        {
          dmats[t][u] = 0.000000000000000;
          if (t == u)
          {
          dmats[t][u] = 1.000000000000000;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.000000000000000;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 2)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 1; s++)
      {
        for (unsigned int t = 0; t < 1; t++)
        {
          derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
      }
    }
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
      delete [] transform[r];
    }// end loop over 'r'
    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, coordinates, c);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = 0.25*x[0][0] + 0.25*x[1][0] + 0.25*x[2][0] + 0.25*x[3][0];
      y[1] = 0.25*x[0][1] + 0.25*x[1][1] + 0.25*x[2][1] + 0.25*x[3][1];
      y[2] = 0.25*x[0][2] + 0.25*x[1][2] + 0.25*x[2][2] + 0.25*x[3][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    
    const double * const * x = c.coordinates;
    y[0] = 0.25*x[0][0] + 0.25*x[1][0] + 0.25*x[2][0] + 0.25*x[3][0];
    y[1] = 0.25*x[0][1] + 0.25*x[1][1] + 0.25*x[2][1] + 0.25*x[3][1];
    y[2] = 0.25*x[0][2] + 0.25*x[1][2] + 0.25*x[2][2] + 0.25*x[3][2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
    vertex_values[3] = dof_values[0];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a finite element.

class hyperelasticity_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  hyperelasticity_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 4;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[3][0] + x[2][0] + x[1][0] - x[0][0];
    const double C1 = x[3][1] + x[2][1] + x[1][1] - x[0][1];
    const double C2 = x[3][2] + x[2][2] + x[1][2] - x[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*coordinates[0] - C0) + d_10*(2.0*coordinates[1] - C1) + d_20*(2.0*coordinates[2] - C2)) / detJ;
    double Y = (d_01*(2.0*coordinates[0] - C0) + d_11*(2.0*coordinates[1] - C1) + d_21*(2.0*coordinates[2] - C2)) / detJ;
    double Z = (d_02*(2.0*coordinates[0] - C0) + d_12*(2.0*coordinates[1] - C1) + d_22*(2.0*coordinates[2] - C2)) / detJ;
    
    
    // Reset values
    *values = 0.000000000000000;
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues
    double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables
    unsigned int rr = 0;
    unsigned int ss = 0;
    double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
    
    // Compute basisvalues
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 0; r < 1; r++)
    {
      rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
      ss = r*(r + 1)*(r + 2)/6;
      basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
    }// end loop over 'r'
    for (unsigned int r = 0; r < 1; r++)
    {
      for (unsigned int s = 0; s < 1 - r; s++)
      {
        rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
        ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      for (unsigned int s = 0; s < 2 - r; s++)
      {
        for (unsigned int t = 0; t < 2 - r - s; t++)
        {
          rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients
    static const double coefficients0[4][4] = \
    {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
    {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
    {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
    {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 4; r++)
    {
      *values += coefficients0[dof][r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 4; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    const double K_00 = d_00 / detJ;
    const double K_01 = d_10 / detJ;
    const double K_02 = d_20 / detJ;
    const double K_10 = d_01 / detJ;
    const double K_11 = d_11 / detJ;
    const double K_12 = d_21 / detJ;
    const double K_20 = d_02 / detJ;
    const double K_21 = d_12 / detJ;
    const double K_22 = d_22 / detJ;
    
    // Compute constants
    const double C0 = x[3][0] + x[2][0] + x[1][0] - x[0][0];
    const double C1 = x[3][1] + x[2][1] + x[1][1] - x[0][1];
    const double C2 = x[3][2] + x[2][2] + x[1][2] - x[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*coordinates[0] - C0) + d_10*(2.0*coordinates[1] - C1) + d_20*(2.0*coordinates[2] - C2)) / detJ;
    double Y = (d_01*(2.0*coordinates[0] - C0) + d_11*(2.0*coordinates[1] - C1) + d_21*(2.0*coordinates[2] - C2)) / detJ;
    double Z = (d_02*(2.0*coordinates[0] - C0) + d_12*(2.0*coordinates[1] - C1) + d_22*(2.0*coordinates[2] - C2)) / detJ;
    
    
    // Compute number of derivatives.
    unsigned int  num_derivatives = 1;
    
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K_00, K_01, K_02}, {K_10, K_11, K_12}, {K_20, K_21, K_22}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Map degree of freedom to element degree of freedom
    const unsigned int dof = i;
    
    // Array of basisvalues
    double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables
    unsigned int rr = 0;
    unsigned int ss = 0;
    double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
    
    // Compute basisvalues
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 0; r < 1; r++)
    {
      rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
      ss = r*(r + 1)*(r + 2)/6;
      basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
    }// end loop over 'r'
    for (unsigned int r = 0; r < 1; r++)
    {
      for (unsigned int s = 0; s < 1 - r; s++)
      {
        rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
        ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      for (unsigned int s = 0; s < 2 - r; s++)
      {
        for (unsigned int t = 0; t < 2 - r - s; t++)
        {
          rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients
    static const double coefficients0[4][4] = \
    {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
    {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
    {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
    {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[4][4] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {6.324555320336760, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    static const double dmats1[4][4] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {5.477225575051662, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    static const double dmats2[4][4] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {1.825741858350554, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {5.163977794943223, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    // Compute reference derivatives
    // Declare pointer to array of derivatives on FIAT element
    double *derivatives = new double [num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[4][4] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[4][4] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 4; t++)
      {
        for (unsigned int u = 0; u < 4; u++)
        {
          dmats[t][u] = 0.000000000000000;
          if (t == u)
          {
          dmats[t][u] = 1.000000000000000;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.000000000000000;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            for (unsigned int tu = 0; tu < 4; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            for (unsigned int tu = 0; tu < 4; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 2)
        {
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            for (unsigned int tu = 0; tu < 4; tu++)
            {
              dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 4; s++)
      {
        for (unsigned int t = 0; t < 4; t++)
        {
          derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        values[row] += transform[row][col]*derivatives[col];
      }
    }
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
      delete [] transform[r];
    }// end loop over 'r'
    delete [] combinations;
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int  num_derivatives = 1;
    
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double [num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 4; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      y[2] = x[0][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      y[2] = x[1][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      y[2] = x[2][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = x[3][0];
      y[1] = x[3][1];
      y[2] = x[3][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    y[2] = x[0][2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    y[2] = x[1][2];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    y[2] = x[2][2];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = x[3][0];
    y[1] = x[3][1];
    y[2] = x[3][2];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a finite element.

class hyperelasticity_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  hyperelasticity_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[3][0] + x[2][0] + x[1][0] - x[0][0];
    const double C1 = x[3][1] + x[2][1] + x[1][1] - x[0][1];
    const double C2 = x[3][2] + x[2][2] + x[1][2] - x[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*coordinates[0] - C0) + d_10*(2.0*coordinates[1] - C1) + d_20*(2.0*coordinates[2] - C2)) / detJ;
    double Y = (d_01*(2.0*coordinates[0] - C0) + d_11*(2.0*coordinates[1] - C1) + d_21*(2.0*coordinates[2] - C2)) / detJ;
    double Z = (d_02*(2.0*coordinates[0] - C0) + d_12*(2.0*coordinates[1] - C1) + d_22*(2.0*coordinates[2] - C2)) / detJ;
    
    
    // Reset values
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    values[2] = 0.000000000000000;
    if (0 <= i && i <= 3)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i;
      
      // Array of basisvalues
      double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
        ss = r*(r + 1)*(r + 2)/6;
        basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 0; s < 1 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
          ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
          basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          for (unsigned int t = 0; t < 2 - r - s; t++)
          {
            rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
            basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients
      static const double coefficients0[4][4] = \
      {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
    if (4 <= i && i <= 7)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 4;
      
      // Array of basisvalues
      double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
        ss = r*(r + 1)*(r + 2)/6;
        basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 0; s < 1 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
          ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
          basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          for (unsigned int t = 0; t < 2 - r - s; t++)
          {
            rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
            basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients
      static const double coefficients0[4][4] = \
      {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
    if (8 <= i && i <= 11)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 8;
      
      // Array of basisvalues
      double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
        ss = r*(r + 1)*(r + 2)/6;
        basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 0; s < 1 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
          ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
          basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          for (unsigned int t = 0; t < 2 - r - s; t++)
          {
            rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
            basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients
      static const double coefficients0[4][4] = \
      {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[dof][r]*basisvalues[r];
      }// end loop over 'r'
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    const double K_00 = d_00 / detJ;
    const double K_01 = d_10 / detJ;
    const double K_02 = d_20 / detJ;
    const double K_10 = d_01 / detJ;
    const double K_11 = d_11 / detJ;
    const double K_12 = d_21 / detJ;
    const double K_20 = d_02 / detJ;
    const double K_21 = d_12 / detJ;
    const double K_22 = d_22 / detJ;
    
    // Compute constants
    const double C0 = x[3][0] + x[2][0] + x[1][0] - x[0][0];
    const double C1 = x[3][1] + x[2][1] + x[1][1] - x[0][1];
    const double C2 = x[3][2] + x[2][2] + x[1][2] - x[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*coordinates[0] - C0) + d_10*(2.0*coordinates[1] - C1) + d_20*(2.0*coordinates[2] - C2)) / detJ;
    double Y = (d_01*(2.0*coordinates[0] - C0) + d_11*(2.0*coordinates[1] - C1) + d_21*(2.0*coordinates[2] - C2)) / detJ;
    double Z = (d_02*(2.0*coordinates[0] - C0) + d_12*(2.0*coordinates[1] - C1) + d_22*(2.0*coordinates[2] - C2)) / detJ;
    
    
    // Compute number of derivatives.
    unsigned int  num_derivatives = 1;
    
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K_00, K_01, K_02}, {K_10, K_11, K_12}, {K_20, K_21, K_22}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    if (0 <= i && i <= 3)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i;
      
      // Array of basisvalues
      double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
        ss = r*(r + 1)*(r + 2)/6;
        basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 0; s < 1 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
          ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
          basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          for (unsigned int t = 0; t < 2 - r - s; t++)
          {
            rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
            basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients
      static const double coefficients0[4][4] = \
      {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {6.324555320336760, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.477225575051662, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats2[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.825741858350554, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.163977794943223, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives
      // Declare pointer to array of derivatives on FIAT element
      double *derivatives = new double [num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int row = 0; row < num_derivatives; row++)
      {
        for (unsigned int col = 0; col < num_derivatives; col++)
        {
          values[row] += transform[row][col]*derivatives[col];
        }
      }
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
        delete [] transform[r];
      }// end loop over 'r'
      delete [] combinations;
      delete [] transform;
    }
    
    if (4 <= i && i <= 7)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 4;
      
      // Array of basisvalues
      double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
        ss = r*(r + 1)*(r + 2)/6;
        basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 0; s < 1 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
          ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
          basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          for (unsigned int t = 0; t < 2 - r - s; t++)
          {
            rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
            basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients
      static const double coefficients0[4][4] = \
      {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {6.324555320336760, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.477225575051662, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats2[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.825741858350554, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.163977794943223, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives
      // Declare pointer to array of derivatives on FIAT element
      double *derivatives = new double [num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int row = 0; row < num_derivatives; row++)
      {
        for (unsigned int col = 0; col < num_derivatives; col++)
        {
          values[num_derivatives + row] += transform[row][col]*derivatives[col];
        }
      }
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
        delete [] transform[r];
      }// end loop over 'r'
      delete [] combinations;
      delete [] transform;
    }
    
    if (8 <= i && i <= 11)
    {
      // Map degree of freedom to element degree of freedom
      const unsigned int dof = i - 8;
      
      // Array of basisvalues
      double basisvalues[4] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = 0.500000000000000*(2.000000000000000 + Y + Z + 2.000000000000000*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)*(r + 1 + 2)/6 + 1*(1 + 1)/2;
        ss = r*(r + 1)*(r + 2)/6;
        basisvalues[rr] = basisvalues[ss]*(r*(1.000000000000000 + Y) + (2.000000000000000 + Z + 3.000000000000000*Y)/2.000000000000000);
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 0; s < 1 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)*(r + s + 1 + 2)/6 + (s + 1)*(s + 1 + 1)/2 + 1;
          ss = (r + s)*(r + s + 1)*(r + s + 2)/6 + s*(s + 1)/2;
          basisvalues[rr] = basisvalues[ss]*(1.000000000000000 + r + s + Z*(2.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          for (unsigned int t = 0; t < 2 - r - s; t++)
          {
            rr = (r + s + t)*(r + s + t + 1)*(r + s + t + 2)/6 + (s + t)*(s + t + 1)/2 + t;
            basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s)*(1.500000000000000 + r + s + t));
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients
      static const double coefficients0[4][4] = \
      {{0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.210818510677892, -0.074535599249993},
      {0.288675134594813, 0.000000000000000, 0.000000000000000, 0.223606797749979}};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {6.324555320336760, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.477225575051662, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats2[4][4] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.162277660168380, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.825741858350554, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.163977794943223, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives
      // Declare pointer to array of derivatives on FIAT element
      double *derivatives = new double [num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[dof][s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int row = 0; row < num_derivatives; row++)
      {
        for (unsigned int col = 0; col < num_derivatives; col++)
        {
          values[2*num_derivatives + row] += transform[row][col]*derivatives[col];
        }
      }
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
        delete [] transform[r];
      }// end loop over 'r'
      delete [] combinations;
      delete [] transform;
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int  num_derivatives = 1;
    
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double [3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      y[2] = x[0][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      y[2] = x[1][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      y[2] = x[2][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = x[3][0];
      y[1] = x[3][1];
      y[2] = x[3][2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      y[2] = x[0][2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 5:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      y[2] = x[1][2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 6:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      y[2] = x[2][2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[3][0];
      y[1] = x[3][1];
      y[2] = x[3][2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      y[2] = x[0][2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 9:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      y[2] = x[1][2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 10:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      y[2] = x[2][2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 11:
      {
        y[0] = x[3][0];
      y[1] = x[3][1];
      y[2] = x[3][2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    y[2] = x[0][2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    y[2] = x[1][2];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    y[2] = x[2][2];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = x[3][0];
    y[1] = x[3][1];
    y[2] = x[3][2];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    y[2] = x[0][2];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    y[2] = x[1][2];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    y[2] = x[2][2];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[3][0];
    y[1] = x[3][1];
    y[2] = x[3][2];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    y[2] = x[0][2];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    y[2] = x[1][2];
    f.evaluate(vals, y, c);
    values[9] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    y[2] = x[2][2];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = x[3][0];
    y[1] = x[3][1];
    y[2] = x[3][2];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[4] = dof_values[5];
    vertex_values[7] = dof_values[6];
    vertex_values[10] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[8];
    vertex_values[5] = dof_values[9];
    vertex_values[8] = dof_values[10];
    vertex_values[11] = dof_values[11];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 3;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_finite_element_1();
        break;
      }
    case 1:
      {
        return new hyperelasticity_finite_element_1();
        break;
      }
    case 2:
      {
        return new hyperelasticity_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class hyperelasticity_dof_map_0: public ufc::dof_map
{
private:

  unsigned int _global_dimension;

public:

  /// Constructor
  hyperelasticity_dof_map_0() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~hyperelasticity_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('tetrahedron', 1, Space(3)), 0)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[3];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 1;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 1;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[3][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 0.250000000000000*x[0][0] + 0.250000000000000*x[1][0] + 0.250000000000000*x[2][0] + 0.250000000000000*x[3][0];
    coordinates[0][1] = 0.250000000000000*x[0][1] + 0.250000000000000*x[1][1] + 0.250000000000000*x[2][1] + 0.250000000000000*x[3][1];
    coordinates[0][2] = 0.250000000000000*x[0][2] + 0.250000000000000*x[1][2] + 0.250000000000000*x[2][2] + 0.250000000000000*x[3][2];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class hyperelasticity_dof_map_1: public ufc::dof_map
{
private:

  unsigned int _global_dimension;

public:

  /// Constructor
  hyperelasticity_dof_map_1() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~hyperelasticity_dof_map_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 4;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 4;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
    dofs[3] = c.entity_indices[0][3];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 3;
        break;
      }
    case 3:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 3)
      {
      throw std::runtime_error("i is larger than number of entities (3)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      case 3:
        {
          dofs[0] = 3;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 1.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[0][1] = 1.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[0][2] = 1.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[1][0] = 0.000000000000000*x[0][0] + 1.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[1][1] = 0.000000000000000*x[0][1] + 1.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[1][2] = 0.000000000000000*x[0][2] + 1.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[2][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 1.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[2][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 1.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[2][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 1.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[3][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 1.000000000000000*x[3][0];
    coordinates[3][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 1.000000000000000*x[3][1];
    coordinates[3][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 1.000000000000000*x[3][2];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class hyperelasticity_dof_map_2: public ufc::dof_map
{
private:

  unsigned int _global_dimension;

public:

  /// Constructor
  hyperelasticity_dof_map_2() : ufc::dof_map()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~hyperelasticity_dof_map_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3*m.num_entities[0];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  // Return the geometric dimension of the coordinates this dof map provides
  virtual unsigned int geometric_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 9;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    dofs[3] = offset + c.entity_indices[0][3];
    offset += m.num_entities[0];
    dofs[4] = offset + c.entity_indices[0][0];
    dofs[5] = offset + c.entity_indices[0][1];
    dofs[6] = offset + c.entity_indices[0][2];
    dofs[7] = offset + c.entity_indices[0][3];
    offset += m.num_entities[0];
    dofs[8] = offset + c.entity_indices[0][0];
    dofs[9] = offset + c.entity_indices[0][1];
    dofs[10] = offset + c.entity_indices[0][2];
    dofs[11] = offset + c.entity_indices[0][3];
    offset += m.num_entities[0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 5;
      dofs[4] = 6;
      dofs[5] = 7;
      dofs[6] = 9;
      dofs[7] = 10;
      dofs[8] = 11;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 6;
      dofs[5] = 7;
      dofs[6] = 8;
      dofs[7] = 10;
      dofs[8] = 11;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 7;
      dofs[6] = 8;
      dofs[7] = 9;
      dofs[8] = 11;
        break;
      }
    case 3:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 6;
      dofs[6] = 8;
      dofs[7] = 9;
      dofs[8] = 10;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 3)
      {
      throw std::runtime_error("i is larger than number of entities (3)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 4;
        dofs[2] = 8;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 5;
        dofs[2] = 9;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 6;
        dofs[2] = 10;
          break;
        }
      case 3:
        {
          dofs[0] = 3;
        dofs[1] = 7;
        dofs[2] = 11;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 1.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[0][1] = 1.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[0][2] = 1.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[1][0] = 0.000000000000000*x[0][0] + 1.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[1][1] = 0.000000000000000*x[0][1] + 1.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[1][2] = 0.000000000000000*x[0][2] + 1.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[2][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 1.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[2][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 1.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[2][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 1.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[3][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 1.000000000000000*x[3][0];
    coordinates[3][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 1.000000000000000*x[3][1];
    coordinates[3][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 1.000000000000000*x[3][2];
    coordinates[4][0] = 1.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[4][1] = 1.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[4][2] = 1.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[5][0] = 0.000000000000000*x[0][0] + 1.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[5][1] = 0.000000000000000*x[0][1] + 1.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[5][2] = 0.000000000000000*x[0][2] + 1.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[6][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 1.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[6][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 1.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[6][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 1.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[7][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 1.000000000000000*x[3][0];
    coordinates[7][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 1.000000000000000*x[3][1];
    coordinates[7][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 1.000000000000000*x[3][2];
    coordinates[8][0] = 1.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[8][1] = 1.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[8][2] = 1.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[9][0] = 0.000000000000000*x[0][0] + 1.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[9][1] = 0.000000000000000*x[0][1] + 1.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[9][2] = 0.000000000000000*x[0][2] + 1.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[10][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 1.000000000000000*x[2][0] + 0.000000000000000*x[3][0];
    coordinates[10][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 1.000000000000000*x[2][1] + 0.000000000000000*x[3][1];
    coordinates[10][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 1.000000000000000*x[2][2] + 0.000000000000000*x[3][2];
    coordinates[11][0] = 0.000000000000000*x[0][0] + 0.000000000000000*x[1][0] + 0.000000000000000*x[2][0] + 1.000000000000000*x[3][0];
    coordinates[11][1] = 0.000000000000000*x[0][1] + 0.000000000000000*x[1][1] + 0.000000000000000*x[2][1] + 1.000000000000000*x[3][1];
    coordinates[11][2] = 0.000000000000000*x[0][2] + 0.000000000000000*x[1][2] + 0.000000000000000*x[2][2] + 1.000000000000000*x[3][2];
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    return 3;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_dof_map_1();
        break;
      }
    case 1:
      {
        return new hyperelasticity_dof_map_1();
        break;
      }
    case 2:
      {
        return new hyperelasticity_dof_map_1();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class hyperelasticity_cell_integral_0_0: public ufc::cell_integral
{
public:

  /// Constructor
  hyperelasticity_cell_integral_0_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_cell_integral_0_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    const double K_00 = d_00 / detJ;
    const double K_01 = d_10 / detJ;
    const double K_02 = d_20 / detJ;
    const double K_10 = d_01 / detJ;
    const double K_11 = d_11 / detJ;
    const double K_12 = d_21 / detJ;
    const double K_20 = d_02 / detJ;
    const double K_21 = d_12 / detJ;
    const double K_22 = d_22 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Array of quadrature weights
    static const double W1 = 0.166666666666666;
    // Quadrature points on the UFC reference element: (0.250000000000000, 0.250000000000000, 0.250000000000000)
    
    // Value of basis functions at quadrature points.
    static const double FE1_C0_D001[1][2] = \
    {{-1.000000000000000, 1.000000000000000}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    for (unsigned int r = 0; r < 144; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    const double G0 = K_12*W1*det*(2.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G1 = W1*det*(K_11*(w[1][0]*(2.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22) + w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_21*w[1][0]*(K_10*K_10 + K_12*K_12));
    const double G2 = W1*det*(K_10*K_10*K_10*K_10*(w[2][0] + 2.000000000000000*w[1][0]) + K_11*K_11*(K_10*K_10*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_11*K_11*(w[2][0] + 2.000000000000000*w[1][0])) + K_12*K_12*(2.000000000000000*w[2][0]*(K_10*K_10 + K_11*K_11) + 4.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11) + K_12*K_12*(w[2][0] + 2.000000000000000*w[1][0])));
    const double G3 = W1*det*(K_02*w[1][0]*(K_10*K_10 + K_11*K_11) + K_12*(w[1][0]*(2.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11) + w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G4 = W1*det*(w[1][0]*(2.000000000000000*(K_00*K_10*(K_00*K_10 + K_01*K_11) + K_01*K_01*K_11*K_11 + K_02*K_12*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_00*K_00*K_11*K_11 + K_01*K_01*K_10*K_10 + K_02*K_02*(K_10*K_10 + K_11*K_11) + K_12*K_12*(K_00*K_00 + K_01*K_01)) + w[2][0]*(K_00*K_10*(2.000000000000000*K_02*K_12 + K_00*K_10) + K_01*K_11*(2.000000000000000*(K_00*K_10 + K_02*K_12) + K_01*K_11) + K_02*K_02*K_12*K_12));
    const double G5 = W1*det*(K_01*w[1][0]*(K_10*K_10 + K_12*K_12) + K_11*(w[1][0]*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G6 = W1*det*(2.000000000000000*w[1][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + w[2][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G7 = W1*det*(2.000000000000000*w[1][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + w[2][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G8 = W1*det*(w[1][0]*(K_10*(K_10*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_11*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22) + K_12*(K_01*K_22 + K_02*K_21)) + K_12*K_12*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21)) + w[2][0]*(K_02*K_12*K_12*K_22 + K_10*(K_00*K_10*K_20 + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G9 = K_11*K_12*W1*det*(w[1][0] + w[2][0]);
    const double G10 = W1*det*(K_12*(w[1][0]*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_22*w[1][0]*(K_10*K_10 + K_11*K_11));
    const double G11 = W1*det*(w[1][0]*(2.000000000000000*(K_10*K_20*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_11*K_11*K_21*K_21 + K_12*K_22*(K_11*K_21 + K_12*K_22)) + K_20*K_20*(K_11*K_11 + K_12*K_12) + K_21*K_21*(K_10*K_10 + K_12*K_12) + K_22*K_22*(K_10*K_10 + K_11*K_11)) + w[2][0]*(K_10*K_20*(2.000000000000000*K_11*K_21 + K_10*K_20) + K_11*K_11*K_21*K_21 + K_12*K_22*(2.000000000000000*(K_10*K_20 + K_11*K_21) + K_12*K_22)));
    const double G12 = K_11*W1*det*(2.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G13 = W1*det*(2.000000000000000*w[1][0]*(K_01*K_11*K_21*K_21 + K_20*(K_00*K_10*K_20 + K_21*(K_00*K_11 + K_01*K_10)) + K_22*(K_02*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*(K_00*K_20 + K_01*K_21))) + w[2][0]*(K_00*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)));
    const double G14 = W1*det*(w[1][0]*(K_20*(K_20*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12) + K_21*(K_00*K_11 + K_01*K_10)) + K_21*K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + K_22*(K_00*(K_10*K_22 + K_12*K_20) + K_01*(K_11*K_22 + K_12*K_21) + K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21))) + w[2][0]*(K_01*K_11*K_21*K_21 + K_20*(K_00*K_10*K_20 + K_21*(K_00*K_11 + K_01*K_10)) + K_22*(K_02*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*(K_00*K_20 + K_01*K_21))));
    const double G15 = W1*det*(K_00*(w[1][0]*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_20*w[1][0]*(K_01*K_01 + K_02*K_02));
    const double G16 = W1*det*(w[1][0]*(K_00*(K_00*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22) + K_02*(K_10*K_22 + K_12*K_20)) + K_01*(K_01*(K_10*K_20 + K_12*K_22) + K_11*(K_00*K_20 + K_02*K_22) + K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12)) + K_02*K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)) + w[2][0]*(K_00*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_01*(K_02*K_11*K_22 + K_21*(K_01*K_11 + K_02*K_12)) + K_02*K_02*K_12*K_22));
    const double G17 = W1*det*(w[1][0]*(2.000000000000000*K_00*K_00*K_20*K_20 + K_01*K_21*(2.000000000000000*K_01*K_21 + 4.000000000000000*K_00*K_20) + K_02*K_22*(2.000000000000000*K_02*K_22 + 4.000000000000000*(K_00*K_20 + K_01*K_21))) + w[2][0]*(K_00*K_00*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_01*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_02*(K_20*K_20 + K_21*K_21 + K_22*K_22)));
    const double G18 = W1*det*(2.000000000000000*w[1][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + w[2][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G19 = W1*det*(K_00*K_22*w[2][0] + K_02*K_20*w[1][0]);
    const double G20 = W1*det*(2.000000000000000*K_02*w[1][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_22*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G21 = W1*det*(w[1][0]*(2.000000000000000*(K_00*K_20*(K_00*K_20 + K_01*K_21) + K_01*K_01*K_21*K_21 + K_02*K_22*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_00*K_00*(K_21*K_21 + K_22*K_22) + K_01*K_01*K_22*K_22 + K_02*K_02*K_21*K_21 + K_20*K_20*(K_01*K_01 + K_02*K_02)) + w[2][0]*(K_00*K_20*(2.000000000000000*K_01*K_21 + K_00*K_20) + K_01*K_01*K_21*K_21 + K_02*K_22*(2.000000000000000*(K_00*K_20 + K_01*K_21) + K_02*K_22)));
    const double G22 = W1*det*(K_02*w[1][0]*(K_20*K_20 + K_21*K_21) + K_22*(w[1][0]*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21) + w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G23 = W1*det*(2.000000000000000*w[1][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + w[2][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G24 = W1*det*(2.000000000000000*K_20*w[1][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_00*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G25 = W1*det*(K_22*w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + w[1][0]*(K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + K_12*(K_00*K_20 + K_01*K_21)));
    const double G26 = W1*det*(2.000000000000000*w[1][0]*(K_00*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_01*(K_02*K_11*K_22 + K_21*(K_01*K_11 + K_02*K_12)) + K_02*K_02*K_12*K_22) + w[2][0]*(K_10*K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*K_21*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_12*K_22*(K_00*K_00 + K_01*K_01 + K_02*K_02)));
    const double G27 = W1*det*(K_00*w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + w[1][0]*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G28 = W1*det*(2.000000000000000*w[1][0]*(K_02*K_12*K_12*K_22 + K_10*(K_00*K_10*K_20 + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + w[2][0]*(K_00*K_20*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_21*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_22*(K_10*K_10 + K_11*K_11 + K_12*K_12)));
    const double G29 = W1*det*(K_00*(w[1][0]*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12) + w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_10*w[1][0]*(K_01*K_01 + K_02*K_02));
    const double G30 = W1*det*(K_00*K_12*w[2][0] + K_02*K_10*w[1][0]);
    const double G31 = W1*det*(2.000000000000000*K_02*w[1][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_12*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G32 = W1*det*(K_12*w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + w[1][0]*(K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + K_22*(K_00*K_10 + K_01*K_11)));
    const double G33 = W1*det*(2.000000000000000*w[1][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + w[2][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G34 = W1*det*(w[1][0]*(2.000000000000000*K_02*K_02*K_12*K_12 + K_00*K_10*(2.000000000000000*K_00*K_10 + 4.000000000000000*K_02*K_12) + K_01*K_11*(2.000000000000000*K_01*K_11 + 4.000000000000000*(K_00*K_10 + K_02*K_12))) + w[2][0]*(K_00*K_00*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_01*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_02*(K_10*K_10 + K_11*K_11 + K_12*K_12)));
    const double G35 = W1*det*(2.000000000000000*K_10*w[1][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_00*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G36 = W1*det*(K_00*K_00*(K_00*K_00*(w[2][0] + 2.000000000000000*w[1][0]) + K_01*K_01*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_02*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_01*K_01*K_01*K_01*(w[2][0] + 2.000000000000000*w[1][0]) + K_02*K_02*(K_01*K_01*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_02*(w[2][0] + 2.000000000000000*w[1][0])));
    const double G37 = W1*det*(K_01*(w[1][0]*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22) + w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*w[1][0]*(K_00*K_00 + K_02*K_02));
    const double G38 = K_01*W1*det*(2.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G39 = K_00*W1*det*(2.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G40 = K_00*K_01*W1*det*(w[1][0] + w[2][0]);
    const double G41 = W1*det*(K_01*(w[1][0]*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_11*w[1][0]*(K_00*K_00 + K_02*K_02));
    const double G42 = W1*det*(K_11*w[1][0]*(K_20*K_20 + K_22*K_22) + K_21*(w[1][0]*(2.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22) + w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G43 = W1*det*(K_21*w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + w[1][0]*(K_01*(K_10*K_20 + K_12*K_22) + K_11*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22)));
    const double G44 = W1*det*(w[1][0]*(2.000000000000000*K_12*K_12*K_22*K_22 + K_10*K_20*(2.000000000000000*K_10*K_20 + 4.000000000000000*(K_11*K_21 + K_12*K_22)) + K_11*K_21*(2.000000000000000*K_11*K_21 + 4.000000000000000*K_12*K_22)) + w[2][0]*(K_10*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_11*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_12*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)));
    const double G45 = W1*det*(K_11*K_22*w[1][0] + K_12*K_21*w[2][0]);
    const double G46 = W1*det*(2.000000000000000*K_22*w[1][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G47 = W1*det*(2.000000000000000*w[1][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + w[2][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G48 = W1*det*(2.000000000000000*K_11*w[1][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G49 = W1*det*(3.000000000000000*w[2][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + 6.000000000000000*w[1][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G50 = W1*det*(w[1][0]*(4.000000000000000*K_00*K_02*K_10*K_12 + K_10*K_10*(3.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*(4.000000000000000*K_01*(K_00*K_10 + K_02*K_12) + K_11*(3.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02)) + K_12*K_12*(3.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01)) + w[2][0]*(0.500000000000000*(K_00*K_00*K_11*K_11 + K_01*K_01*K_10*K_10 + K_02*K_02*(K_10*K_10 + K_11*K_11) + K_12*K_12*(K_00*K_00 + K_01*K_01)) + 1.500000000000000*K_01*K_01*K_11*K_11 + K_00*K_10*(1.500000000000000*K_00*K_10 + 2.000000000000000*K_01*K_11) + K_02*K_12*(1.500000000000000*K_02*K_12 + 2.000000000000000*(K_00*K_10 + K_01*K_11))));
    const double G51 = W1*det*(K_00*K_00*(K_00*K_00*(w[1][0] + 0.500000000000000*w[2][0]) + K_01*K_01*(w[2][0] + 2.000000000000000*w[1][0]) + K_02*K_02*(w[2][0] + 2.000000000000000*w[1][0])) + K_01*K_01*K_01*K_01*(w[1][0] + 0.500000000000000*w[2][0]) + K_02*K_02*(K_01*K_01*(w[2][0] + 2.000000000000000*w[1][0]) + K_02*K_02*(w[1][0] + 0.500000000000000*w[2][0])));
    const double G52 = W1*det*(2.000000000000000*K_01*w[1][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_11*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G53 = W1*det*(0.500000000000000*w[2][0]*(K_00*K_00*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_01*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_02*(K_10*K_10 + K_11*K_11 + K_12*K_12)) + w[1][0]*(K_00*K_10*(2.000000000000000*K_02*K_12 + K_00*K_10) + K_01*K_11*(2.000000000000000*(K_00*K_10 + K_02*K_12) + K_01*K_11) + K_02*K_02*K_12*K_12));
    const double G54 = W1*det*(w[1][0]*(K_00*(4.000000000000000*K_02*(K_10*K_22 + K_12*K_20) + K_00*(2.000000000000000*(K_11*K_21 + K_12*K_22) + 6.000000000000000*K_10*K_20)) + K_01*(4.000000000000000*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_01*(2.000000000000000*(K_10*K_20 + K_12*K_22) + 6.000000000000000*K_11*K_21)) + K_02*K_02*(2.000000000000000*(K_10*K_20 + K_11*K_21) + 6.000000000000000*K_12*K_22)) + w[2][0]*(K_00*(2.000000000000000*K_02*(K_10*K_22 + K_12*K_20) + K_00*(3.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_01*(2.000000000000000*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_01*(3.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22)) + K_02*K_02*(3.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)));
    const double G55 = W1*det*(w[1][0]*(4.000000000000000*K_01*K_02*K_21*K_22 + K_20*(4.000000000000000*K_00*(K_01*K_21 + K_02*K_22) + K_20*(3.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_21*K_21*(3.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02) + K_22*K_22*(3.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01)) + w[2][0]*(0.500000000000000*(K_00*K_00*(K_21*K_21 + K_22*K_22) + K_01*K_01*K_22*K_22 + K_02*K_02*K_21*K_21 + K_20*K_20*(K_01*K_01 + K_02*K_02)) + 1.500000000000000*K_00*K_00*K_20*K_20 + K_01*K_21*(1.500000000000000*K_01*K_21 + 2.000000000000000*K_00*K_20) + K_02*K_22*(1.500000000000000*K_02*K_22 + 2.000000000000000*(K_00*K_20 + K_01*K_21))));
    const double G56 = K_00*W1*det*(3.000000000000000*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + 6.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G57 = W1*det*(K_00*(K_01*K_21*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_22*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_20*(K_00*K_00*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_01*K_01*(w[2][0] + 2.000000000000000*w[1][0]) + K_02*K_02*(w[2][0] + 2.000000000000000*w[1][0])));
    const double G58 = W1*det*(K_00*(K_00*K_10*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_01*K_11*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_12*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_10*(2.000000000000000*w[1][0]*(K_01*K_01 + K_02*K_02) + w[2][0]*(K_01*K_01 + K_02*K_02)));
    const double G59 = W1*det*(3.000000000000000*w[2][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + 6.000000000000000*w[1][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G60 = W1*det*(0.500000000000000*w[2][0]*(K_00*K_00*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_01*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_02*(K_20*K_20 + K_21*K_21 + K_22*K_22)) + w[1][0]*(K_00*K_20*(2.000000000000000*K_01*K_21 + K_00*K_20) + K_01*K_01*K_21*K_21 + K_02*K_22*(2.000000000000000*(K_00*K_20 + K_01*K_21) + K_02*K_22)));
    const double G61 = W1*det*(K_00*K_00*(K_00*K_00*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0]) + K_01*K_01*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_02*K_02*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0])) + K_01*K_01*K_01*K_01*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0]) + K_02*K_02*(K_01*K_01*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_02*K_02*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0])));
    const double G62 = K_02*W1*det*(2.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G63 = W1*det*(2.000000000000000*K_01*w[1][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_21*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G64 = W1*det*(K_00*K_00*w[2][0] + w[1][0]*(2.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G65 = W1*det*(K_01*(K_00*K_20*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_01*K_21*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_02*K_22*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_21*(2.000000000000000*w[1][0]*(K_00*K_00 + K_02*K_02) + w[2][0]*(K_00*K_00 + K_02*K_02)));
    const double G66 = W1*det*(0.500000000000000*w[2][0]*(K_00*K_20*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_21*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_22*(K_10*K_10 + K_11*K_11 + K_12*K_12)) + w[1][0]*(K_02*K_12*K_12*K_22 + K_10*(K_00*K_10*K_20 + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G67 = W1*det*(1.500000000000000*w[2][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + 3.000000000000000*w[1][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G68 = W1*det*(w[1][0]*(2.000000000000000*(K_10*(K_00*K_21 + K_01*K_20) + K_11*(K_00*K_20 + K_02*K_22) + K_12*(K_01*K_22 + K_02*K_21)) + 6.000000000000000*K_01*K_11*K_21) + w[2][0]*(K_01*(3.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22) + K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)));
    const double G69 = W1*det*(w[1][0]*(K_10*(2.000000000000000*(K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_10*(3.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_11*(2.000000000000000*K_12*(K_01*K_22 + K_02*K_21) + K_11*(3.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22)) + K_12*K_12*(3.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21)) + w[2][0]*(K_10*(K_10*(0.500000000000000*(K_01*K_21 + K_02*K_22) + 1.500000000000000*K_00*K_20) + K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_11*(0.500000000000000*(K_00*K_20 + K_02*K_22) + 1.500000000000000*K_01*K_21) + K_12*(K_01*K_22 + K_02*K_21)) + K_12*K_12*(0.500000000000000*(K_00*K_20 + K_01*K_21) + 1.500000000000000*K_02*K_22)));
    const double G70 = W1*det*(0.500000000000000*w[2][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + w[1][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G71 = W1*det*(w[1][0]*(2.000000000000000*(K_00*K_00*(K_21*K_21 + K_22*K_22) + K_01*K_01*K_22*K_22 + K_02*K_02*K_21*K_21 + K_20*K_20*(K_01*K_01 + K_02*K_02)) + 6.000000000000000*K_00*K_00*K_20*K_20 + K_01*K_21*(6.000000000000000*K_01*K_21 + 8.000000000000000*K_00*K_20) + K_02*K_22*(6.000000000000000*K_02*K_22 + 8.000000000000000*(K_00*K_20 + K_01*K_21))) + w[2][0]*(4.000000000000000*K_01*K_02*K_21*K_22 + K_20*(4.000000000000000*K_00*(K_01*K_21 + K_02*K_22) + K_20*(3.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_21*K_21*(3.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02) + K_22*K_22*(3.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01)));
    const double G72 = W1*det*(K_00*w[1][0]*(K_21*K_21 + K_22*K_22) + K_20*(w[1][0]*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G73 = W1*det*(K_10*w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + w[1][0]*(K_00*(K_11*K_21 + K_12*K_22) + K_20*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G74 = W1*det*(w[1][0]*(K_20*(4.000000000000000*K_21*(K_00*K_11 + K_01*K_10) + K_20*(2.000000000000000*(K_01*K_11 + K_02*K_12) + 6.000000000000000*K_00*K_10)) + K_21*K_21*(2.000000000000000*(K_00*K_10 + K_02*K_12) + 6.000000000000000*K_01*K_11) + K_22*(4.000000000000000*(K_20*(K_00*K_12 + K_02*K_10) + K_21*(K_01*K_12 + K_02*K_11)) + K_22*(2.000000000000000*(K_00*K_10 + K_01*K_11) + 6.000000000000000*K_02*K_12))) + w[2][0]*(K_20*(2.000000000000000*K_21*(K_00*K_11 + K_01*K_10) + K_20*(3.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_21*K_21*(3.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + K_22*(2.000000000000000*(K_20*(K_00*K_12 + K_02*K_10) + K_21*(K_01*K_12 + K_02*K_11)) + K_22*(3.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11))));
    const double G75 = W1*det*(0.500000000000000*w[2][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + w[1][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G76 = W1*det*(K_02*(w[1][0]*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21) + w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_22*w[1][0]*(K_00*K_00 + K_01*K_01));
    const double G77 = W1*det*(K_01*(K_20*K_20*(w[2][0] + 2.000000000000000*w[1][0]) + K_21*K_21*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_22*K_22*(w[2][0] + 2.000000000000000*w[1][0])) + K_21*(2.000000000000000*w[2][0]*(K_00*K_20 + K_02*K_22) + 4.000000000000000*w[1][0]*(K_00*K_20 + K_02*K_22)));
    const double G78 = W1*det*(1.500000000000000*w[2][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + 3.000000000000000*w[1][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G79 = W1*det*(K_01*K_21*(w[2][0] + 2.000000000000000*w[1][0]) + w[1][0]*(K_00*K_20 + K_02*K_22));
    const double G80 = W1*det*(K_00*w[1][0]*(K_11*K_11 + K_12*K_12) + K_10*(w[1][0]*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12) + w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G81 = K_10*K_12*W1*det*(w[1][0] + w[2][0]);
    const double G82 = W1*det*(K_10*(w[1][0]*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22) + w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_20*w[1][0]*(K_11*K_11 + K_12*K_12));
    const double G83 = K_10*W1*det*(2.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G84 = W1*det*(K_11*w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + w[1][0]*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12)));
    const double G85 = W1*det*(K_00*K_11*w[2][0] + K_01*K_10*w[1][0]);
    const double G86 = W1*det*(K_01*w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + w[1][0]*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12)));
    const double G87 = W1*det*(0.500000000000000*w[2][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + w[1][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G88 = W1*det*(0.500000000000000*w[2][0]*(K_10*K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*K_21*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_12*K_22*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + w[1][0]*(K_00*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_01*(K_02*K_11*K_22 + K_21*(K_01*K_11 + K_02*K_12)) + K_02*K_02*K_12*K_22));
    const double G89 = W1*det*(w[1][0]*(K_10*(4.000000000000000*(K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_10*(2.000000000000000*(K_01*K_21 + K_02*K_22) + 6.000000000000000*K_00*K_20)) + K_11*(4.000000000000000*K_12*(K_01*K_22 + K_02*K_21) + K_11*(2.000000000000000*(K_00*K_20 + K_02*K_22) + 6.000000000000000*K_01*K_21)) + K_12*K_12*(2.000000000000000*(K_00*K_20 + K_01*K_21) + 6.000000000000000*K_02*K_22)) + w[2][0]*(K_10*(2.000000000000000*(K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_10*(3.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_11*(2.000000000000000*K_12*(K_01*K_22 + K_02*K_21) + K_11*(3.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22)) + K_12*K_12*(3.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21)));
    const double G90 = W1*det*(0.500000000000000*w[2][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + w[1][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G91 = W1*det*(K_10*w[1][0]*(K_21*K_21 + K_22*K_22) + K_20*(w[1][0]*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22) + w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G92 = W1*det*(1.500000000000000*w[2][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + 3.000000000000000*w[1][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G93 = W1*det*(K_12*(K_20*K_20*(w[2][0] + 2.000000000000000*w[1][0]) + K_21*K_21*(w[2][0] + 2.000000000000000*w[1][0]) + K_22*K_22*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0])) + K_22*(2.000000000000000*w[2][0]*(K_10*K_20 + K_11*K_21) + 4.000000000000000*w[1][0]*(K_10*K_20 + K_11*K_21)));
    const double G94 = W1*det*(w[1][0]*(K_00*(2.000000000000000*K_02*(K_10*K_22 + K_12*K_20) + K_00*(3.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_01*(2.000000000000000*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_01*(3.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22)) + K_02*K_02*(3.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)) + w[2][0]*(K_00*(K_00*(0.500000000000000*(K_11*K_21 + K_12*K_22) + 1.500000000000000*K_10*K_20) + K_02*(K_10*K_22 + K_12*K_20)) + K_01*(K_01*(0.500000000000000*(K_10*K_20 + K_12*K_22) + 1.500000000000000*K_11*K_21) + K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_02*K_02*(0.500000000000000*(K_10*K_20 + K_11*K_21) + 1.500000000000000*K_12*K_22)));
    const double G95 = W1*det*(1.500000000000000*w[2][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + 3.000000000000000*w[1][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G96 = W1*det*(w[1][0]*(2.000000000000000*(K_10*(K_00*K_22 + K_02*K_20) + K_11*(K_01*K_22 + K_02*K_21) + K_12*(K_00*K_20 + K_01*K_21)) + 6.000000000000000*K_02*K_12*K_22) + w[2][0]*(K_00*(K_10*K_22 + K_12*K_20) + K_01*(K_11*K_22 + K_12*K_21) + K_02*(3.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)));
    const double G97 = W1*det*(K_12*K_22*w[2][0] + w[1][0]*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21));
    const double G98 = W1*det*(w[1][0]*(2.000000000000000*(K_20*K_20*(K_11*K_11 + K_12*K_12) + K_21*K_21*(K_10*K_10 + K_12*K_12) + K_22*K_22*(K_10*K_10 + K_11*K_11)) + 6.000000000000000*K_12*K_12*K_22*K_22 + K_10*K_20*(6.000000000000000*K_10*K_20 + 8.000000000000000*(K_11*K_21 + K_12*K_22)) + K_11*K_21*(6.000000000000000*K_11*K_21 + 8.000000000000000*K_12*K_22)) + w[2][0]*(4.000000000000000*K_10*K_12*K_20*K_22 + K_10*K_10*(3.000000000000000*K_20*K_20 + K_21*K_21 + K_22*K_22) + K_11*(K_11*(K_20*K_20 + K_22*K_22) + K_21*(3.000000000000000*K_11*K_21 + 4.000000000000000*(K_10*K_20 + K_12*K_22))) + K_12*K_12*(3.000000000000000*K_22*K_22 + K_20*K_20 + K_21*K_21)));
    const double G99 = W1*det*(K_12*(w[1][0]*(4.000000000000000*(K_10*K_20 + K_11*K_21) + 6.000000000000000*K_12*K_22) + w[2][0]*(2.000000000000000*(K_10*K_20 + K_11*K_21) + 3.000000000000000*K_12*K_22)) + K_22*(2.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11) + w[2][0]*(K_10*K_10 + K_11*K_11)));
    const double G100 = W1*det*(K_20*K_20*(K_20*K_20*(w[2][0] + 2.000000000000000*w[1][0]) + K_21*K_21*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_21*K_21*K_21*K_21*(w[2][0] + 2.000000000000000*w[1][0]) + K_22*K_22*(K_20*K_20*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_21*K_21*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_22*K_22*(w[2][0] + 2.000000000000000*w[1][0])));
    const double G101 = K_20*K_22*W1*det*(w[1][0] + w[2][0]);
    const double G102 = K_22*W1*det*(2.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G103 = K_20*W1*det*(2.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G104 = W1*det*(K_12*w[1][0]*(K_20*K_20 + K_21*K_21) + K_22*(w[1][0]*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G105 = W1*det*(2.000000000000000*K_21*w[1][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_01*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G106 = W1*det*(0.500000000000000*w[2][0]*(K_10*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_11*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_12*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)) + w[1][0]*(K_10*K_20*(2.000000000000000*K_11*K_21 + K_10*K_20) + K_11*K_11*K_21*K_21 + K_12*K_22*(2.000000000000000*(K_10*K_20 + K_11*K_21) + K_12*K_22)));
    const double G107 = W1*det*(2.000000000000000*K_21*w[1][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_11*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G108 = W1*det*(K_20*K_20*(K_20*K_20*(w[1][0] + 0.500000000000000*w[2][0]) + K_21*K_21*(w[2][0] + 2.000000000000000*w[1][0])) + K_21*K_21*K_21*K_21*(w[1][0] + 0.500000000000000*w[2][0]) + K_22*K_22*(K_20*K_20*(w[2][0] + 2.000000000000000*w[1][0]) + K_21*K_21*(w[2][0] + 2.000000000000000*w[1][0]) + K_22*K_22*(w[1][0] + 0.500000000000000*w[2][0])));
    const double G109 = W1*det*(2.000000000000000*K_20*w[1][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_10*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G110 = W1*det*(3.000000000000000*w[2][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + 6.000000000000000*w[1][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G111 = W1*det*(w[1][0]*(4.000000000000000*K_10*K_12*K_20*K_22 + K_10*K_10*(3.000000000000000*K_20*K_20 + K_21*K_21 + K_22*K_22) + K_11*(K_11*(K_20*K_20 + K_22*K_22) + K_21*(3.000000000000000*K_11*K_21 + 4.000000000000000*(K_10*K_20 + K_12*K_22))) + K_12*K_12*(3.000000000000000*K_22*K_22 + K_20*K_20 + K_21*K_21)) + w[2][0]*(0.500000000000000*(K_20*K_20*(K_11*K_11 + K_12*K_12) + K_21*K_21*(K_10*K_10 + K_12*K_12) + K_22*K_22*(K_10*K_10 + K_11*K_11)) + 1.500000000000000*K_12*K_12*K_22*K_22 + K_10*K_20*(1.500000000000000*K_10*K_20 + 2.000000000000000*(K_11*K_21 + K_12*K_22)) + K_11*K_21*(1.500000000000000*K_11*K_21 + 2.000000000000000*K_12*K_22)));
    const double G112 = K_22*W1*det*(3.000000000000000*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + 6.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G113 = W1*det*(K_20*K_20*(K_20*K_20*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0]) + K_21*K_21*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0])) + K_21*K_21*K_21*K_21*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0]) + K_22*K_22*(K_20*K_20*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_21*K_21*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_22*K_22*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0])));
    const double G114 = W1*det*(K_02*(2.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21) + w[2][0]*(K_20*K_20 + K_21*K_21)) + K_22*(K_00*K_20*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_01*K_21*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_22*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0])));
    const double G115 = K_21*W1*det*(2.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G116 = W1*det*(K_22*K_22*w[2][0] + w[1][0]*(2.000000000000000*K_22*K_22 + K_20*K_20 + K_21*K_21));
    const double G117 = W1*det*(3.000000000000000*w[2][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + 6.000000000000000*w[1][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G118 = K_10*K_11*W1*det*(w[1][0] + w[2][0]);
    const double G119 = W1*det*(K_20*w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + w[1][0]*(K_00*(K_11*K_21 + K_12*K_22) + K_10*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G120 = W1*det*(K_10*K_22*w[1][0] + K_12*K_20*w[2][0]);
    const double G121 = W1*det*(2.000000000000000*K_10*w[1][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_20*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G122 = W1*det*(K_02*(K_00*K_20*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_01*K_21*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_22*(2.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01) + K_02*K_02*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + w[2][0]*(K_00*K_00 + K_01*K_01)));
    const double G123 = W1*det*(K_01*w[1][0]*(K_20*K_20 + K_22*K_22) + K_21*(w[1][0]*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22) + w[2][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G124 = W1*det*(K_02*K_22*w[2][0] + w[1][0]*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21));
    const double G125 = W1*det*(w[1][0]*(2.000000000000000*(K_00*K_00*K_11*K_11 + K_01*K_01*K_10*K_10 + K_02*K_02*(K_10*K_10 + K_11*K_11) + K_12*K_12*(K_00*K_00 + K_01*K_01)) + 6.000000000000000*K_02*K_02*K_12*K_12 + K_00*K_10*(6.000000000000000*K_00*K_10 + 8.000000000000000*K_02*K_12) + K_01*K_11*(6.000000000000000*K_01*K_11 + 8.000000000000000*(K_00*K_10 + K_02*K_12))) + w[2][0]*(4.000000000000000*K_00*K_02*K_10*K_12 + K_10*K_10*(3.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*(4.000000000000000*K_01*(K_00*K_10 + K_02*K_12) + K_11*(3.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02)) + K_12*K_12*(3.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01)));
    const double G126 = W1*det*(0.500000000000000*w[2][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + w[1][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G127 = W1*det*(w[1][0]*(K_20*(2.000000000000000*K_21*(K_00*K_11 + K_01*K_10) + K_20*(3.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_21*K_21*(3.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + K_22*(2.000000000000000*(K_20*(K_00*K_12 + K_02*K_10) + K_21*(K_01*K_12 + K_02*K_11)) + K_22*(3.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11))) + w[2][0]*(K_20*(0.500000000000000*K_20*(K_01*K_11 + K_02*K_12) + K_00*(K_11*K_21 + K_12*K_22) + K_10*(1.500000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*K_21*(0.500000000000000*(K_00*K_10 + K_02*K_12) + 1.500000000000000*K_01*K_11) + K_22*(K_21*(K_01*K_12 + K_02*K_11) + K_22*(0.500000000000000*(K_00*K_10 + K_01*K_11) + 1.500000000000000*K_02*K_12))));
    const double G128 = W1*det*(0.500000000000000*w[2][0]*(K_00*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)) + w[1][0]*(K_01*K_11*K_21*K_21 + K_20*(K_00*K_10*K_20 + K_21*(K_00*K_11 + K_01*K_10)) + K_22*(K_02*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*(K_00*K_20 + K_01*K_21))));
    const double G129 = W1*det*(w[1][0]*(2.000000000000000*(K_00*K_12*K_22 + K_01*K_10*K_21 + K_02*(K_10*K_22 + K_12*K_20) + K_11*(K_00*K_21 + K_01*K_20)) + 6.000000000000000*K_00*K_10*K_20) + w[2][0]*(K_10*(3.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)));
    const double G130 = W1*det*(K_00*(K_10*K_10*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_11*K_11*(w[2][0] + 2.000000000000000*w[1][0]) + K_12*K_12*(w[2][0] + 2.000000000000000*w[1][0])) + K_10*(K_01*K_11*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_12*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])));
    const double G131 = W1*det*(1.500000000000000*w[2][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + 3.000000000000000*w[1][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G132 = W1*det*(0.500000000000000*w[2][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + w[1][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G133 = W1*det*(1.500000000000000*w[2][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + 3.000000000000000*w[1][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G134 = W1*det*(K_02*(w[1][0]*(2.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11) + w[2][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_12*w[1][0]*(K_00*K_00 + K_01*K_01));
    const double G135 = W1*det*(K_00*K_10*(w[2][0] + 2.000000000000000*w[1][0]) + w[1][0]*(K_01*K_11 + K_02*K_12));
    const double G136 = K_21*K_22*W1*det*(w[1][0] + w[2][0]);
    const double G137 = W1*det*(2.000000000000000*K_00*w[1][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_20*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G138 = W1*det*(2.000000000000000*K_00*w[1][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_10*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G139 = K_02*W1*det*(3.000000000000000*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + 6.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G140 = W1*det*(K_02*K_02*w[2][0] + w[1][0]*(2.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01));
    const double G141 = W1*det*(K_02*(2.000000000000000*w[2][0]*(K_00*K_10 + K_01*K_11) + 4.000000000000000*w[1][0]*(K_00*K_10 + K_01*K_11)) + K_12*(2.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01) + K_02*K_02*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + w[2][0]*(K_00*K_00 + K_01*K_01)));
    const double G142 = W1*det*(K_00*K_21*w[1][0] + K_01*K_20*w[2][0]);
    const double G143 = W1*det*(K_02*w[2][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + w[1][0]*(K_12*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21) + K_22*(K_00*K_10 + K_01*K_11)));
    const double G144 = W1*det*(K_01*K_22*w[1][0] + K_02*K_21*w[2][0]);
    const double G145 = W1*det*(2.000000000000000*K_22*w[1][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_02*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G146 = W1*det*(2.000000000000000*K_12*w[1][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_22*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G147 = W1*det*(K_11*K_22*w[2][0] + K_12*K_21*w[1][0]);
    const double G148 = W1*det*(K_10*(2.000000000000000*w[1][0]*(K_21*K_21 + K_22*K_22) + w[2][0]*(K_21*K_21 + K_22*K_22)) + K_20*(w[1][0]*(4.000000000000000*(K_11*K_21 + K_12*K_22) + 6.000000000000000*K_10*K_20) + w[2][0]*(2.000000000000000*(K_11*K_21 + K_12*K_22) + 3.000000000000000*K_10*K_20)));
    const double G149 = W1*det*(K_10*(K_11*K_21*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_12*K_22*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_20*(K_10*K_10*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_11*K_11*(w[2][0] + 2.000000000000000*w[1][0]) + K_12*K_12*(w[2][0] + 2.000000000000000*w[1][0])));
    const double G150 = W1*det*(K_10*K_20*w[2][0] + w[1][0]*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G151 = W1*det*(K_01*K_22*w[2][0] + K_02*K_21*w[1][0]);
    const double G152 = W1*det*(2.000000000000000*K_12*w[1][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_02*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G153 = W1*det*(K_01*K_12*w[1][0] + K_02*K_11*w[2][0]);
    const double G154 = W1*det*(2.000000000000000*K_11*w[1][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_01*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G155 = W1*det*(K_10*K_10*K_10*K_10*(w[1][0] + 0.500000000000000*w[2][0]) + K_11*K_11*(K_10*K_10*(w[2][0] + 2.000000000000000*w[1][0]) + K_11*K_11*(w[1][0] + 0.500000000000000*w[2][0])) + K_12*K_12*(2.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11) + K_12*K_12*(w[1][0] + 0.500000000000000*w[2][0]) + w[2][0]*(K_10*K_10 + K_11*K_11)));
    const double G156 = W1*det*(3.000000000000000*w[2][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + 6.000000000000000*w[1][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G157 = W1*det*(K_10*K_10*K_10*K_10*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0]) + K_11*K_11*(K_10*K_10*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_11*K_11*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0])) + K_12*K_12*(3.000000000000000*w[2][0]*(K_10*K_10 + K_11*K_11) + 6.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11) + K_12*K_12*(1.500000000000000*w[2][0] + 3.000000000000000*w[1][0])));
    const double G158 = W1*det*(K_02*(2.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11) + w[2][0]*(K_10*K_10 + K_11*K_11)) + K_12*(K_00*K_10*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_01*K_11*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_12*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0])));
    const double G159 = W1*det*(K_12*K_12*(w[2][0] + 2.000000000000000*w[1][0]) + w[1][0]*(K_10*K_10 + K_11*K_11));
    const double G160 = W1*det*(3.000000000000000*w[2][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + 6.000000000000000*w[1][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G161 = K_12*W1*det*(3.000000000000000*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + 6.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G162 = W1*det*(K_01*(K_00*K_10*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_01*K_11*(3.000000000000000*w[2][0] + 6.000000000000000*w[1][0]) + K_02*K_12*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])) + K_11*(2.000000000000000*w[1][0]*(K_00*K_00 + K_02*K_02) + w[2][0]*(K_00*K_00 + K_02*K_02)));
    const double G163 = W1*det*(K_01*(w[1][0]*(2.000000000000000*(K_10*K_10 + K_12*K_12) + 6.000000000000000*K_11*K_11) + w[2][0]*(3.000000000000000*K_11*K_11 + K_10*K_10 + K_12*K_12)) + K_11*(K_00*K_10*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0]) + K_02*K_12*(2.000000000000000*w[2][0] + 4.000000000000000*w[1][0])));
    const double G164 = W1*det*(K_01*K_11*(w[2][0] + 2.000000000000000*w[1][0]) + w[1][0]*(K_00*K_10 + K_02*K_12));
    const double G165 = W1*det*(K_10*K_21*w[2][0] + K_11*K_20*w[1][0]);
    const double G166 = W1*det*(K_00*(2.000000000000000*w[1][0]*(K_21*K_21 + K_22*K_22) + w[2][0]*(K_21*K_21 + K_22*K_22)) + K_20*(w[1][0]*(4.000000000000000*(K_01*K_21 + K_02*K_22) + 6.000000000000000*K_00*K_20) + w[2][0]*(2.000000000000000*(K_01*K_21 + K_02*K_22) + 3.000000000000000*K_00*K_20)));
    const double G167 = K_20*W1*det*(3.000000000000000*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + 6.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G168 = W1*det*(K_20*K_20*w[2][0] + w[1][0]*(2.000000000000000*K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G169 = W1*det*(K_00*K_12*w[1][0] + K_02*K_10*w[2][0]);
    const double G170 = K_20*K_21*W1*det*(w[1][0] + w[2][0]);
    const double G171 = W1*det*(K_00*K_11*w[1][0] + K_01*K_10*w[2][0]);
    const double G172 = W1*det*(K_00*K_22*w[1][0] + K_02*K_20*w[2][0]);
    const double G173 = W1*det*(K_00*K_20*w[2][0] + w[1][0]*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G174 = W1*det*(K_01*K_12*w[2][0] + K_02*K_11*w[1][0]);
    const double G175 = W1*det*(K_00*K_21*w[2][0] + K_01*K_20*w[1][0]);
    const double G176 = K_01*W1*det*(3.000000000000000*w[2][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + 6.000000000000000*w[1][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G177 = W1*det*(K_01*K_01*w[2][0] + w[1][0]*(2.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02));
    const double G178 = K_01*K_02*W1*det*(w[1][0] + w[2][0]);
    const double G179 = K_11*W1*det*(3.000000000000000*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + 6.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G180 = W1*det*(K_11*(2.000000000000000*w[2][0]*(K_10*K_20 + K_12*K_22) + 4.000000000000000*w[1][0]*(K_10*K_20 + K_12*K_22)) + K_21*(w[1][0]*(2.000000000000000*(K_10*K_10 + K_12*K_12) + 6.000000000000000*K_11*K_11) + w[2][0]*(3.000000000000000*K_11*K_11 + K_10*K_10 + K_12*K_12)));
    const double G181 = W1*det*(K_11*K_11*w[2][0] + w[1][0]*(2.000000000000000*K_11*K_11 + K_10*K_10 + K_12*K_12));
    const double G182 = W1*det*(K_02*K_12*(w[2][0] + 2.000000000000000*w[1][0]) + w[1][0]*(K_00*K_10 + K_01*K_11));
    const double G183 = W1*det*(K_10*K_22*w[2][0] + K_12*K_20*w[1][0]);
    const double G184 = K_10*W1*det*(3.000000000000000*w[2][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + 6.000000000000000*w[1][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G185 = W1*det*(K_10*K_10*w[2][0] + w[1][0]*(2.000000000000000*K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G186 = W1*det*(K_11*(2.000000000000000*w[1][0]*(K_20*K_20 + K_22*K_22) + w[2][0]*(K_20*K_20 + K_22*K_22)) + K_21*(w[1][0]*(4.000000000000000*(K_10*K_20 + K_12*K_22) + 6.000000000000000*K_11*K_21) + w[2][0]*(2.000000000000000*(K_10*K_20 + K_12*K_22) + 3.000000000000000*K_11*K_21)));
    const double G187 = K_21*W1*det*(3.000000000000000*w[2][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + 6.000000000000000*w[1][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G188 = W1*det*(K_21*K_21*w[2][0] + w[1][0]*(2.000000000000000*K_21*K_21 + K_20*K_20 + K_22*K_22));
    const double G189 = W1*det*(K_10*K_21*w[1][0] + K_11*K_20*w[2][0]);
    const double G190 = W1*det*(K_11*K_21*w[2][0] + w[1][0]*(2.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22));
    const double G191 = K_00*K_02*W1*det*(w[1][0] + w[2][0]);
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('simplify expressions', True), ('ignore zero tables', True), ('non zero columns', True), ('remove zero terms', True), ('ignore ones', True)
    
    // Loop quadrature points for integral
    // Number of operations to compute element tensor for following IP loop = 2792
    // Only 1 integration point, omitting IP loop.
    
    // Coefficient declarations
    double F0 = 0.000000000000000;
    double F1 = 0.000000000000000;
    double F2 = 0.000000000000000;
    double F3 = 0.000000000000000;
    double F4 = 0.000000000000000;
    double F5 = 0.000000000000000;
    double F6 = 0.000000000000000;
    double F7 = 0.000000000000000;
    double F8 = 0.000000000000000;
    
    // Total number of operations to compute function values = 36
    for (unsigned int r = 0; r < 2; r++)
    {
      F0 += FE1_C0_D001[0][r]*w[0][nzc3[r]];
      F1 += FE1_C0_D001[0][r]*w[0][nzc2[r]];
      F2 += FE1_C0_D001[0][r]*w[0][nzc1[r]];
      F3 += FE1_C0_D001[0][r]*w[0][nzc7[r]];
      F4 += FE1_C0_D001[0][r]*w[0][nzc6[r]];
      F5 += FE1_C0_D001[0][r]*w[0][nzc5[r]];
      F6 += FE1_C0_D001[0][r]*w[0][nzc11[r]];
      F7 += FE1_C0_D001[0][r]*w[0][nzc10[r]];
      F8 += FE1_C0_D001[0][r]*w[0][nzc9[r]];
    }// end loop over 'r'
    
    // Number of operations to compute ip constants: 1784
    // Number of operations: 30
    const double Gip0 = (G9 + F3*(G3 + F6*G4 + F7*G7 + F8*G8) + F4*(G0 + F6*G7 + F7*G2 + F8*G6) + F5*(G10 + F6*G8 + F7*G6 + F8*G11) + F6*G5 + F7*G12 + F8*G1);
    
    // Number of operations: 30
    const double Gip1 = (G19 + F0*G20 + F1*G25 + F2*G22 + F6*(G15 + F0*G23 + F1*G16 + F2*G21) + F7*(G27 + F0*G26 + F1*G8 + F2*G14) + F8*(G24 + F0*G17 + F1*G13 + F2*G18));
    
    // Number of operations: 30
    const double Gip2 = (G30 + F0*G31 + F1*G3 + F2*G32 + F6*(G29 + F0*G33 + F1*G4 + F2*G16) + F7*(G35 + F0*G34 + F1*G7 + F2*G28) + F8*(G27 + F0*G26 + F1*G8 + F2*G14));
    
    // Number of operations: 30
    const double Gip3 = (G40 + F0*G38 + F1*G41 + F2*G37 + F3*(G39 + F0*G36 + F1*G33 + F2*G23) + F4*(G29 + F0*G33 + F1*G4 + F2*G16) + F5*(G15 + F0*G23 + F1*G16 + F2*G21));
    
    // Number of operations: 30
    const double Gip4 = (G45 + F3*(G32 + F6*G16 + F7*G28 + F8*G14) + F4*(G10 + F6*G8 + F7*G6 + F8*G11) + F5*(G46 + F6*G13 + F7*G44 + F8*G47) + F6*G43 + F7*G48 + F8*G42);
    
    // Number of operations: 54
    const double Gip5 = (G64 + F0*(G56 + F0*G61 + F1*G49 + F2*G59) + F1*(G58 + F1*G50 + F2*G54) + F2*(G57 + F2*G55) + F3*(G38 + F3*G51 + F4*G33) + F4*(G52 + F4*G53) + F5*(G63 + F3*G23 + F4*G26 + F5*G60) + F6*(G62 + F6*G51 + F7*G33) + F7*(G31 + F7*G53) + F8*(G20 + F6*G23 + F7*G26 + F8*G60));
    
    // Number of operations: 54
    const double Gip6 = (G79 + F0*(G15 + F0*G75 + F1*G16 + F2*G21) + F1*(G73 + F1*G66 + F2*G14) + F2*(G72 + F2*G70) + F3*(G65 + F3*G67 + F4*G54) + F4*(G68 + F4*G69) + F5*(G77 + F3*G71 + F4*G74 + F5*G78) + F6*(G76 + F6*G75 + F7*G16) + F7*(G32 + F7*G66) + F8*(G22 + F6*G21 + F7*G14 + F8*G70));
    
    // Number of operations: 30
    const double Gip7 = (G81 + F0*G3 + F1*G0 + F2*G10 + F6*(G80 + F0*G4 + F1*G7 + F2*G8) + F7*(G83 + F0*G7 + F1*G2 + F2*G6) + F8*(G82 + F0*G8 + F1*G6 + F2*G11));
    
    // Number of operations: 30
    const double Gip8 = (G85 + F0*G52 + F1*G5 + F2*G84 + F3*(G29 + F0*G33 + F1*G4 + F2*G16) + F4*(G35 + F0*G34 + F1*G7 + F2*G28) + F5*(G27 + F0*G26 + F1*G8 + F2*G14));
    
    // Number of operations: 54
    const double Gip9 = (G97 + F0*(G27 + F0*G88 + F1*G8 + F2*G14) + F1*(G82 + F1*G87 + F2*G11) + F2*(G91 + F2*G90) + F3*(G86 + F3*G88 + F4*G8) + F4*(G1 + F4*G87) + F5*(G42 + F3*G14 + F4*G11 + F5*G90) + F6*(G96 + F6*G94 + F7*G89) + F7*(G99 + F7*G92) + F8*(G93 + F6*G74 + F7*G98 + F8*G95));
    
    // Number of operations: 30
    const double Gip10 = (G101 + F0*G22 + F1*G104 + F2*G102 + F6*(G72 + F0*G21 + F1*G14 + F2*G18) + F7*(G91 + F0*G14 + F1*G11 + F2*G47) + F8*(G103 + F0*G18 + F1*G47 + F2*G100));
    
    // Number of operations: 54
    const double Gip11 = (G116 + F0*(G24 + F0*G60 + F1*G13 + F2*G18) + F1*(G109 + F1*G106 + F2*G47) + F2*(G103 + F2*G108) + F3*(G105 + F3*G60 + F4*G13) + F4*(G107 + F4*G106) + F5*(G115 + F3*G18 + F4*G47 + F5*G108) + F6*(G114 + F6*G55 + F8*G110) + F7*(G93 + F6*G74 + F7*G111 + F8*G117) + F8*(G112 + F8*G113));
    
    // Number of operations: 30
    const double Gip12 = (G118 + F0*G5 + F1*G12 + F2*G1 + F3*(G80 + F0*G4 + F1*G7 + F2*G8) + F4*(G83 + F0*G7 + F1*G2 + F2*G6) + F5*(G82 + F0*G8 + F1*G6 + F2*G11));
    
    // Number of operations: 30
    const double Gip13 = (G120 + F0*G32 + F1*G10 + F2*G46 + F6*(G119 + F0*G16 + F1*G8 + F2*G13) + F7*(G121 + F0*G28 + F1*G6 + F2*G44) + F8*(G91 + F0*G14 + F1*G11 + F2*G47));
    
    // Number of operations: 54
    const double Gip14 = (G124 + F0*(G15 + F0*G75 + F1*G16 + F2*G21) + F1*(G73 + F1*G66 + F2*G14) + F2*(G72 + F2*G70) + F3*(G37 + F3*G75 + F4*G16) + F4*(G84 + F4*G66) + F5*(G123 + F3*G21 + F4*G14 + F5*G70) + F6*(G122 + F6*G67 + F7*G54) + F7*(G96 + F7*G69) + F8*(G114 + F6*G71 + F7*G74 + F8*G78));
    
    // Number of operations: 55
    const double Gip15 = (G135 + F0*(G58 + F0*G133 + F1*G125 + F2*G54) + F1*(G130 + F1*G131 + F2*G89) + F2*(G129 + F2*G127) + F3*(G41 + F3*G132 + F4*G4) + F4*G5 + F5*(G43 + F3*G16 + F4*G8 + F5*G128) + F6*(G134 + F6*G132 + F7*G4) + F7*G3 + F8*(G25 + F6*G16 + F7*G8 + F8*G128) + G126*(F4*F4 + F7*F7));
    
    // Number of operations: 30
    const double Gip16 = (G136 + F3*(G22 + F6*G21 + F7*G14 + F8*G18) + F4*(G104 + F6*G14 + F7*G11 + F8*G47) + F5*(G102 + F6*G18 + F7*G47 + F8*G100) + F6*G123 + F7*G42 + F8*G115);
    
    // Number of operations: 54
    const double Gip17 = (G140 + F0*(G39 + F0*G51) + F1*(G138 + F0*G33 + F1*G53) + F2*(G137 + F0*G23 + F1*G26 + F2*G60) + F3*(G38 + F3*G51 + F4*G33) + F4*(G52 + F4*G53) + F5*(G63 + F3*G23 + F4*G26 + F5*G60) + F6*(G139 + F6*G61 + F7*G49) + F7*(G141 + F7*G50) + F8*(G122 + F6*G59 + F7*G54 + F8*G55));
    
    // Number of operations: 30
    const double Gip18 = (G142 + F0*G37 + F1*G86 + F2*G105 + F3*(G137 + F0*G23 + F1*G26 + F2*G17) + F4*(G119 + F0*G16 + F1*G8 + F2*G13) + F5*(G72 + F0*G21 + F1*G14 + F2*G18));
    
    // Number of operations: 30
    const double Gip19 = (G144 + F3*(G76 + F6*G23 + F7*G16 + F8*G21) + F4*(G143 + F6*G26 + F7*G8 + F8*G14) + F5*(G145 + F6*G17 + F7*G13 + F8*G18) + F6*G63 + F7*G43 + F8*G123);
    
    // Number of operations: 30
    const double Gip20 = (G147 + F3*(G25 + F6*G16 + F7*G8 + F8*G13) + F4*(G146 + F6*G28 + F7*G6 + F8*G44) + F5*(G104 + F6*G14 + F7*G11 + F8*G47) + F6*G84 + F7*G1 + F8*G107);
    
    // Number of operations: 54
    const double Gip21 = (G150 + F0*(G129 + F0*G94 + F1*G89 + F2*G74) + F1*(G149 + F1*G92 + F2*G98) + F2*(G148 + F2*G95) + F3*(G86 + F3*G88 + F4*G8) + F4*(G1 + F4*G87) + F5*(G42 + F3*G14 + F4*G11 + F5*G90) + F6*(G143 + F6*G88 + F8*G14) + F7*(G10 + F6*G8 + F7*G87 + F8*G11) + F8*(G104 + F8*G90));
    
    // Number of operations: 30
    const double Gip22 = (G151 + F3*(G20 + F6*G23 + F7*G26 + F8*G17) + F4*(G25 + F6*G16 + F7*G8 + F8*G13) + F5*(G22 + F6*G21 + F7*G14 + F8*G18) + F6*G37 + F7*G86 + F8*G105);
    
    // Number of operations: 30
    const double Gip23 = (G153 + F3*(G134 + F6*G33 + F7*G4 + F8*G16) + F4*(G152 + F6*G34 + F7*G7 + F8*G28) + F5*(G143 + F6*G26 + F7*G8 + F8*G14) + F6*G52 + F7*G5 + F8*G84);
    
    // Number of operations: 54
    const double Gip24 = (G159 + F0*(G35 + F0*G53 + F1*G7 + F2*G28) + F1*(G83 + F1*G155 + F2*G6) + F2*(G121 + F2*G106) + F3*(G154 + F3*G53 + F4*G7) + F4*(G12 + F4*G155) + F5*(G48 + F3*G28 + F4*G6 + F5*G106) + F6*(G158 + F6*G50 + F7*G156) + F7*(G161 + F7*G157) + F8*(G99 + F6*G89 + F7*G160 + F8*G111));
    
    // Number of operations: 54
    const double Gip25 = (G164 + F0*(G29 + F0*G132 + F1*G4 + F2*G16) + F1*(G80 + F1*G126 + F2*G8) + F2*(G119 + F2*G128) + F3*(G162 + F3*G133 + F4*G125) + F4*(G163 + F4*G131) + F5*(G68 + F3*G54 + F4*G89 + F5*G127) + F6*(G134 + F6*G132 + F7*G4) + F7*(G3 + F7*G126) + F8*(G25 + F6*G16 + F7*G8 + F8*G128));
    
    // Number of operations: 30
    const double Gip26 = (G165 + F0*G43 + F1*G48 + F2*G42 + F3*(G73 + F0*G16 + F1*G28 + F2*G14) + F4*(G82 + F0*G8 + F1*G6 + F2*G11) + F5*(G109 + F0*G13 + F1*G44 + F2*G47));
    
    // Number of operations: 54
    const double Gip27 = (G168 + F0*(G166 + F0*G55 + F1*G74 + F2*G110) + F1*(G148 + F1*G111 + F2*G117) + F2*(G167 + F2*G113) + F3*(G105 + F3*G60 + F4*G13) + F4*(G107 + F4*G106) + F5*(G115 + F3*G18 + F4*G47 + F5*G108) + F6*(G145 + F6*G60 + F8*G18) + F7*(G46 + F6*G13 + F7*G106 + F8*G47) + F8*(G102 + F8*G108));
    
    // Number of operations: 30
    const double Gip28 = (G169 + F0*G134 + F1*G152 + F2*G143 + F6*(G138 + F0*G33 + F1*G34 + F2*G26) + F7*(G80 + F0*G4 + F1*G7 + F2*G8) + F8*(G73 + F0*G16 + F1*G28 + F2*G14));
    
    // Number of operations: 30
    const double Gip29 = (G170 + F0*G123 + F1*G42 + F2*G115 + F3*(G72 + F0*G21 + F1*G14 + F2*G18) + F4*(G91 + F0*G14 + F1*G11 + F2*G47) + F5*(G103 + F0*G18 + F1*G47 + F2*G100));
    
    // Number of operations: 30
    const double Gip30 = (G171 + F0*G41 + F1*G154 + F2*G86 + F3*(G138 + F0*G33 + F1*G34 + F2*G26) + F4*(G80 + F0*G4 + F1*G7 + F2*G8) + F5*(G73 + F0*G16 + F1*G28 + F2*G14));
    
    // Number of operations: 30
    const double Gip31 = (G172 + F0*G76 + F1*G143 + F2*G145 + F6*(G137 + F0*G23 + F1*G26 + F2*G17) + F7*(G119 + F0*G16 + F1*G8 + F2*G13) + F8*(G72 + F0*G21 + F1*G14 + F2*G18));
    
    // Number of operations: 55
    const double Gip32 = (G173 + F0*(G57 + F0*G67 + F1*G54 + F2*G71) + F1*(G129 + F1*G69 + F2*G74) + F2*(G166 + F2*G78) + F3*(G37 + F3*G75 + F4*G16) + F4*G84 + F5*(G123 + F3*G21 + F4*G14 + F5*G70) + F6*(G76 + F6*G75 + F7*G16) + F7*G32 + F8*(G22 + F6*G21 + F7*G14 + F8*G70) + G66*(F4*F4 + F7*F7));
    
    // Number of operations: 30
    const double Gip33 = (G174 + F3*(G31 + F6*G33 + F7*G34 + F8*G26) + F4*(G3 + F6*G4 + F7*G7 + F8*G8) + F5*(G32 + F6*G16 + F7*G28 + F8*G14) + F6*G41 + F7*G154 + F8*G86);
    
    // Number of operations: 30
    const double Gip34 = (G175 + F0*G63 + F1*G43 + F2*G123 + F3*(G15 + F0*G23 + F1*G16 + F2*G21) + F4*(G27 + F0*G26 + F1*G8 + F2*G14) + F5*(G24 + F0*G17 + F1*G13 + F2*G18));
    
    // Number of operations: 54
    const double Gip35 = (G177 + F0*(G39 + F0*G51) + F1*(G138 + F0*G33 + F1*G53) + F2*(G137 + F0*G23 + F1*G26 + F2*G60) + F3*(G176 + F3*G61 + F4*G49) + F4*(G162 + F4*G50) + F5*(G65 + F3*G59 + F4*G54 + F5*G55) + F6*(G62 + F6*G51 + F7*G33) + F7*(G31 + F7*G53) + F8*(G20 + F6*G23 + F7*G26 + F8*G60));
    
    // Number of operations: 30
    const double Gip36 = (G178 + F3*(G62 + F6*G36 + F7*G33 + F8*G23) + F4*(G134 + F6*G33 + F7*G4 + F8*G16) + F5*(G76 + F6*G23 + F7*G16 + F8*G21) + F6*G38 + F7*G41 + F8*G37);
    
    // Number of operations: 54
    const double Gip37 = (G181 + F0*(G35 + F0*G53 + F1*G7 + F2*G28) + F1*(G83 + F1*G155 + F2*G6) + F2*(G121 + F2*G106) + F3*(G163 + F3*G50) + F4*(G179 + F3*G156 + F4*G157 + F5*G160) + F5*(G180 + F3*G89 + F5*G111) + F6*(G152 + F6*G53 + F7*G7) + F7*(G0 + F7*G155) + F8*(G146 + F6*G28 + F7*G6 + F8*G106));
    
    // Number of operations: 54
    const double Gip38 = (G182 + F0*(G29 + F0*G132 + F1*G4 + F2*G16) + F1*(G80 + F1*G126 + F2*G8) + F2*(G119 + F2*G128) + F3*(G41 + F3*G132 + F4*G4) + F4*(G5 + F4*G126) + F5*(G43 + F3*G16 + F4*G8 + F5*G128) + F6*(G141 + F6*G133 + F7*G125) + F7*(G158 + F7*G131) + F8*(G96 + F6*G54 + F7*G89 + F8*G127));
    
    // Number of operations: 30
    const double Gip39 = (G183 + F0*G25 + F1*G146 + F2*G104 + F6*(G73 + F0*G16 + F1*G28 + F2*G14) + F7*(G82 + F0*G8 + F1*G6 + F2*G11) + F8*(G109 + F0*G13 + F1*G44 + F2*G47));
    
    // Number of operations: 54
    const double Gip40 = (G185 + F0*(G130 + F0*G50) + F1*(G184 + F0*G156 + F1*G157 + F2*G160) + F2*(G149 + F0*G89 + F2*G111) + F3*(G154 + F3*G53) + F4*(G12 + F3*G7 + F4*G155) + F5*(G48 + F3*G28 + F4*G6 + F5*G106) + F6*(G152 + F6*G53 + F7*G7) + F7*(G0 + F7*G155) + F8*(G146 + F6*G28 + F7*G6 + F8*G106));
    
    // Number of operations: 54
    const double Gip41 = (G188 + F0*(G24 + F0*G60 + F1*G13 + F2*G18) + F1*(G109 + F1*G106 + F2*G47) + F2*(G103 + F2*G108) + F3*(G77 + F3*G55) + F4*(G186 + F3*G74 + F4*G111 + F5*G117) + F5*(G187 + F3*G110 + F5*G113) + F6*(G145 + F6*G60 + F8*G18) + F7*(G46 + F6*G13 + F7*G106 + F8*G47) + F8*(G102 + F8*G108));
    
    // Number of operations: 30
    const double Gip42 = (G189 + F0*G84 + F1*G1 + F2*G107 + F3*(G119 + F0*G16 + F1*G8 + F2*G13) + F4*(G121 + F0*G28 + F1*G6 + F2*G44) + F5*(G91 + F0*G14 + F1*G11 + F2*G47));
    
    // Number of operations: 54
    const double Gip43 = (G190 + F0*(G27 + F0*G88 + F1*G8 + F2*G14) + F1*(G82 + F1*G87 + F2*G11) + F2*(G91 + F2*G90) + F3*(G68 + F3*G94 + F4*G89) + F4*(G180 + F4*G92) + F5*(G186 + F3*G74 + F4*G98 + F5*G95) + F6*(G143 + F6*G88 + F7*G8) + F7*(G10 + F7*G87) + F8*(G104 + F6*G14 + F7*G11 + F8*G90));
    
    // Number of operations: 30
    const double Gip44 = (G191 + F0*G62 + F1*G134 + F2*G76 + F6*(G39 + F0*G36 + F1*G33 + F2*G23) + F7*(G29 + F0*G33 + F1*G4 + F2*G16) + F8*(G15 + F0*G23 + F1*G16 + F2*G21));
    
    
    // Number of operations for primary indices: 972
    for (unsigned int j = 0; j < 2; j++)
    {
      for (unsigned int k = 0; k < 2; k++)
      {
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip0;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip1;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip2;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip3;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip4;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip5;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip6;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip7;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip8;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip9;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip10;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip11;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip12;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip13;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip14;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip15;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip16;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip12;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip8;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip17;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip14;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip18;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip19;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip20;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip21;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip22;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip23;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip24;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip9;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip25;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip26;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip25;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip27;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip28;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip29;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip30;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip31;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip15;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip32;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip16;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip26;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip33;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip30;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip1;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip34;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip10;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip31;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip7;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip35;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip36;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip37;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip38;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip0;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip39;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip40;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip2;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip23;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip41;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc2[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip21;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip39;
        // Number of operations to compute entry: 3
        A[nzc2[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip28;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip29;
        // Number of operations to compute entry: 3
        A[nzc1[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip42;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc9[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip22;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip19;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip13;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip6;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip3;
        // Number of operations to compute entry: 3
        A[nzc9[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip20;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip18;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc7[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip33;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc6[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip43;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip32;
        // Number of operations to compute entry: 3
        A[nzc5[j]*12 + nzc10[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip4;
        // Number of operations to compute entry: 3
        A[nzc7[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip36;
        // Number of operations to compute entry: 3
        A[nzc10[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip38;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip34;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc1[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip42;
        // Number of operations to compute entry: 3
        A[nzc11[j]*12 + nzc3[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip44;
        // Number of operations to compute entry: 3
        A[nzc3[j]*12 + nzc11[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip44;
        // Number of operations to compute entry: 3
        A[nzc6[j]*12 + nzc5[k]] += FE1_C0_D001[0][j]*FE1_C0_D001[0][k]*Gip43;
      }// end loop over 'k'
    }// end loop over 'j'
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class hyperelasticity_cell_integral_1_0: public ufc::cell_integral
{
public:

  /// Constructor
  hyperelasticity_cell_integral_1_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_cell_integral_1_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_02 = x[3][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    const double J_12 = x[3][1] - x[0][1];
    const double J_20 = x[1][2] - x[0][2];
    const double J_21 = x[2][2] - x[0][2];
    const double J_22 = x[3][2] - x[0][2];
    
    // Compute sub determinants
    const double d_00 = J_11*J_22 - J_12*J_21;
    const double d_01 = J_12*J_20 - J_10*J_22;
    const double d_02 = J_10*J_21 - J_11*J_20;
    const double d_10 = J_02*J_21 - J_01*J_22;
    const double d_11 = J_00*J_22 - J_02*J_20;
    const double d_12 = J_01*J_20 - J_00*J_21;
    const double d_20 = J_01*J_12 - J_02*J_11;
    const double d_21 = J_02*J_10 - J_00*J_12;
    const double d_22 = J_00*J_11 - J_01*J_10;
    
    // Compute determinant of Jacobian
    double detJ = J_00*d_00 + J_10*d_10 + J_20*d_20;
    
    // Compute inverse of Jacobian
    const double K_00 = d_00 / detJ;
    const double K_01 = d_10 / detJ;
    const double K_02 = d_20 / detJ;
    const double K_10 = d_01 / detJ;
    const double K_11 = d_11 / detJ;
    const double K_12 = d_21 / detJ;
    const double K_20 = d_02 / detJ;
    const double K_21 = d_12 / detJ;
    const double K_22 = d_22 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Array of quadrature weights
    static const double W8[8] = {0.036979856358853, 0.016027040598477, 0.021157006454524, 0.009169429921480, 0.036979856358853, 0.016027040598477, 0.021157006454524, 0.009169429921480};
    // Quadrature points on the UFC reference element: (0.156682637336818, 0.136054976802846, 0.122514822655441), (0.081395667014670, 0.070679724159397, 0.544151844011225), (0.065838687060044, 0.565933165072801, 0.122514822655441), (0.034202793236766, 0.293998800631623, 0.544151844011225), (0.584747563204894, 0.136054976802846, 0.122514822655441), (0.303772764814708, 0.070679724159397, 0.544151844011225), (0.245713325211713, 0.565933165072801, 0.122514822655441), (0.127646562120385, 0.293998800631623, 0.544151844011225)
    
    // Value of basis functions at quadrature points.
    static const double FE1_C0[8][4] = \
    {{0.584747563204894, 0.156682637336818, 0.136054976802846, 0.122514822655441},
    {0.303772764814707, 0.081395667014670, 0.070679724159397, 0.544151844011225},
    {0.245713325211713, 0.065838687060044, 0.565933165072801, 0.122514822655441},
    {0.127646562120385, 0.034202793236766, 0.293998800631623, 0.544151844011225},
    {0.156682637336818, 0.584747563204894, 0.136054976802846, 0.122514822655441},
    {0.081395667014670, 0.303772764814708, 0.070679724159397, 0.544151844011225},
    {0.065838687060044, 0.245713325211713, 0.565933165072801, 0.122514822655441},
    {0.034202793236766, 0.127646562120385, 0.293998800631623, 0.544151844011225}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {8, 9, 10, 11};
    
    static const double FE1_C0_D001[8][2] = \
    {{-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000},
    {-1.000000000000000, 1.000000000000000}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    for (unsigned int r = 0; r < 12; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    const double G0 = det*(w[3][0]*(K_00*(K_00*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22) + K_02*(K_10*K_22 + K_12*K_20)) + K_01*(K_01*(K_10*K_20 + K_12*K_22) + K_11*(K_00*K_20 + K_02*K_22) + K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12)) + K_02*K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)) + w[4][0]*(K_00*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_01*(K_02*K_11*K_22 + K_21*(K_01*K_11 + K_02*K_12)) + K_02*K_02*K_12*K_22));
    const double G1 = det*(0.500000000000000*w[4][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + w[3][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G2 = (0.500000000000000*det*w[4][0]*(K_00*K_00*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_01*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_02*(K_20*K_20 + K_21*K_21 + K_22*K_22)) + det*w[3][0]*(K_00*K_20*(2.000000000000000*K_01*K_21 + K_00*K_20) + K_01*K_01*K_21*K_21 + K_02*K_22*(2.000000000000000*(K_00*K_20 + K_01*K_21) + K_02*K_22)));
    const double G3 = det*(K_00*K_20*w[4][0] + w[3][0]*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G4 = det*(K_00*(K_01*K_21*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_22*(w[4][0] + 2.000000000000000*w[3][0])) + K_20*(K_00*K_00*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_01*K_01*(w[3][0] + 0.500000000000000*w[4][0]) + K_02*K_02*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G5 = det*(0.500000000000000*K_20*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_10*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G6 = det*(w[3][0]*(K_20*(K_20*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12) + K_21*(K_00*K_11 + K_01*K_10)) + K_21*K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + K_22*(K_00*(K_10*K_22 + K_12*K_20) + K_01*(K_11*K_22 + K_12*K_21) + K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21))) + w[4][0]*(K_01*K_11*K_21*K_21 + K_20*(K_00*K_10*K_20 + K_21*(K_00*K_11 + K_01*K_10)) + K_22*(K_02*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*(K_00*K_20 + K_01*K_21))));
    const double G7 = det*(w[3][0]*(K_10*(2.000000000000000*(K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_10*(3.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_11*(2.000000000000000*K_12*(K_01*K_22 + K_02*K_21) + K_11*(3.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22)) + K_12*K_12*(3.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21)) + w[4][0]*(K_10*(K_10*(0.500000000000000*(K_01*K_21 + K_02*K_22) + 1.500000000000000*K_00*K_20) + K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_11*(0.500000000000000*(K_00*K_20 + K_02*K_22) + 1.500000000000000*K_01*K_21) + K_12*(K_01*K_22 + K_02*K_21)) + K_12*K_12*(0.500000000000000*(K_00*K_20 + K_01*K_21) + 1.500000000000000*K_02*K_22)));
    const double G8 = det*(K_10*K_20*w[4][0] + w[3][0]*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G9 = det*(2.000000000000000*K_21*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_11*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G10 = det*(K_10*w[3][0]*(K_21*K_21 + K_22*K_22) + K_20*(w[3][0]*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22) + w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G11 = det*(K_20*K_20*(K_20*K_20*(w[3][0] + 0.500000000000000*w[4][0]) + K_21*K_21*(w[4][0] + 2.000000000000000*w[3][0])) + K_21*K_21*K_21*K_21*(w[3][0] + 0.500000000000000*w[4][0]) + K_22*K_22*(K_20*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_21*K_21*(w[4][0] + 2.000000000000000*w[3][0]) + K_22*K_22*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G12 = det*(2.000000000000000*K_21*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_01*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G13 = det*(0.500000000000000*w[4][0]*(K_00*K_20*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_21*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_22*(K_10*K_10 + K_11*K_11 + K_12*K_12)) + w[3][0]*(K_02*K_12*K_12*K_22 + K_10*(K_00*K_10*K_20 + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G14 = det*(w[3][0]*(K_00*(2.000000000000000*K_02*(K_10*K_22 + K_12*K_20) + K_00*(3.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_01*(2.000000000000000*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_01*(3.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22)) + K_02*K_02*(3.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)) + w[4][0]*(K_00*(K_00*(0.500000000000000*(K_11*K_21 + K_12*K_22) + 1.500000000000000*K_10*K_20) + K_02*(K_10*K_22 + K_12*K_20)) + K_01*(K_01*(0.500000000000000*(K_10*K_20 + K_12*K_22) + 1.500000000000000*K_11*K_21) + K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_02*K_02*(0.500000000000000*(K_10*K_20 + K_11*K_21) + 1.500000000000000*K_12*K_22)));
    const double G15 = det*(K_02*(w[3][0]*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21) + w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_22*w[3][0]*(K_00*K_00 + K_01*K_01));
    const double G16 = K_20*det*(0.500000000000000*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G17 = det*(0.500000000000000*w[4][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + w[3][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G18 = det*(K_02*w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + w[3][0]*(K_12*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21) + K_22*(K_00*K_10 + K_01*K_11)));
    const double G19 = det*(K_11*w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + w[3][0]*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12)));
    const double G20 = K_22*det*(2.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G21 = det*(K_11*w[3][0]*(K_20*K_20 + K_22*K_22) + K_21*(w[3][0]*(2.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22) + w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G22 = det*(w[3][0]*(2.000000000000000*(K_00*K_12*K_22 + K_01*K_10*K_21 + K_02*(K_10*K_22 + K_12*K_20) + K_11*(K_00*K_21 + K_01*K_20)) + 6.000000000000000*K_00*K_10*K_20) + w[4][0]*(K_10*(3.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)));
    const double G23 = det*(0.500000000000000*w[4][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + w[3][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G24 = det*(K_00*w[3][0]*(K_21*K_21 + K_22*K_22) + K_20*(w[3][0]*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G25 = (0.500000000000000*det*w[4][0]*(K_10*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_11*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_12*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)) + det*w[3][0]*(K_10*K_20*(2.000000000000000*K_11*K_21 + K_10*K_20) + K_11*K_11*K_21*K_21 + K_12*K_22*(2.000000000000000*(K_10*K_20 + K_11*K_21) + K_12*K_22)));
    const double G26 = det*(K_02*w[3][0]*(K_20*K_20 + K_21*K_21) + K_22*(w[3][0]*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21) + w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G27 = det*(K_10*K_21*w[3][0] + K_11*K_20*w[4][0]);
    const double G28 = det*(2.000000000000000*w[3][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + w[4][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G29 = det*(K_00*K_22*w[3][0] + K_02*K_20*w[4][0]);
    const double G30 = det*(2.000000000000000*K_22*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_02*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G31 = det*(0.500000000000000*w[4][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + w[3][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G32 = det*(2.000000000000000*w[3][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + w[4][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G33 = det*(w[3][0]*(2.000000000000000*(K_10*K_20*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_11*K_11*K_21*K_21 + K_12*K_22*(K_11*K_21 + K_12*K_22)) + K_20*K_20*(K_11*K_11 + K_12*K_12) + K_21*K_21*(K_10*K_10 + K_12*K_12) + K_22*K_22*(K_10*K_10 + K_11*K_11)) + w[4][0]*(K_10*K_20*(2.000000000000000*K_11*K_21 + K_10*K_20) + K_11*K_11*K_21*K_21 + K_12*K_22*(2.000000000000000*(K_10*K_20 + K_11*K_21) + K_12*K_22)));
    const double G34 = det*(K_12*w[3][0]*(K_20*K_20 + K_21*K_21) + K_22*(w[3][0]*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G35 = det*(K_12*w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + w[3][0]*(K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + K_22*(K_00*K_10 + K_01*K_11)));
    const double G36 = det*(K_20*K_20*w[4][0] + w[3][0]*(2.000000000000000*K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G37 = K_21*det*(2.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G38 = det*(0.500000000000000*w[4][0]*(K_10*K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*K_21*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_12*K_22*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + w[3][0]*(K_00*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_01*(K_02*K_11*K_22 + K_21*(K_01*K_11 + K_02*K_12)) + K_02*K_02*K_12*K_22));
    const double G39 = det*(K_00*(2.000000000000000*w[3][0]*(K_21*K_21 + K_22*K_22) + w[4][0]*(K_21*K_21 + K_22*K_22)) + K_20*(K_00*K_20*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_01*K_21*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_02*K_22*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])));
    const double G40 = det*(K_20*w[4][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + w[3][0]*(K_00*(K_11*K_21 + K_12*K_22) + K_10*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G41 = det*(K_10*(w[3][0]*(2.000000000000000*(K_11*K_21 + K_12*K_22) + 3.000000000000000*K_10*K_20) + w[4][0]*(1.500000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_20*(K_11*K_11*(w[3][0] + 0.500000000000000*w[4][0]) + K_12*K_12*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G42 = det*(K_01*w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + w[3][0]*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12)));
    const double G43 = det*(0.500000000000000*K_20*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_00*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G44 = det*(K_11*(w[3][0]*(2.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22) + w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_21*w[3][0]*(K_10*K_10 + K_12*K_12));
    const double G45 = det*(w[3][0]*(K_20*(4.000000000000000*K_21*(K_00*K_11 + K_01*K_10) + K_20*(2.000000000000000*(K_01*K_11 + K_02*K_12) + 6.000000000000000*K_00*K_10)) + K_21*K_21*(2.000000000000000*(K_00*K_10 + K_02*K_12) + 6.000000000000000*K_01*K_11) + K_22*(4.000000000000000*(K_20*(K_00*K_12 + K_02*K_10) + K_21*(K_01*K_12 + K_02*K_11)) + K_22*(2.000000000000000*(K_00*K_10 + K_01*K_11) + 6.000000000000000*K_02*K_12))) + w[4][0]*(K_20*(2.000000000000000*K_21*(K_00*K_11 + K_01*K_10) + K_20*(3.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_21*K_21*(3.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + K_22*(2.000000000000000*(K_20*(K_00*K_12 + K_02*K_10) + K_21*(K_01*K_12 + K_02*K_11)) + K_22*(3.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11))));
    const double G46 = det*(2.000000000000000*w[3][0]*(K_01*K_11*K_21*K_21 + K_20*(K_00*K_10*K_20 + K_21*(K_00*K_11 + K_01*K_10)) + K_22*(K_02*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*(K_00*K_20 + K_01*K_21))) + w[4][0]*(K_00*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)));
    const double G47 = det*(K_12*(w[3][0]*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_22*w[3][0]*(K_10*K_10 + K_11*K_11));
    const double G48 = det*(w[3][0]*(4.000000000000000*K_10*K_12*K_20*K_22 + K_10*K_10*(3.000000000000000*K_20*K_20 + K_21*K_21 + K_22*K_22) + K_11*(K_11*(K_20*K_20 + K_22*K_22) + K_21*(3.000000000000000*K_11*K_21 + 4.000000000000000*(K_10*K_20 + K_12*K_22))) + K_12*K_12*(3.000000000000000*K_22*K_22 + K_20*K_20 + K_21*K_21)) + w[4][0]*(0.500000000000000*(K_20*K_20*(K_11*K_11 + K_12*K_12) + K_21*K_21*(K_10*K_10 + K_12*K_12) + K_22*K_22*(K_10*K_10 + K_11*K_11)) + 1.500000000000000*K_12*K_12*K_22*K_22 + K_10*K_20*(1.500000000000000*K_10*K_20 + 2.000000000000000*(K_11*K_21 + K_12*K_22)) + K_11*K_21*(1.500000000000000*K_11*K_21 + 2.000000000000000*K_12*K_22)));
    const double G49 = det*(w[3][0]*(2.000000000000000*(K_00*K_20*(K_00*K_20 + K_01*K_21) + K_01*K_01*K_21*K_21 + K_02*K_22*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_00*K_00*(K_21*K_21 + K_22*K_22) + K_01*K_01*K_22*K_22 + K_02*K_02*K_21*K_21 + K_20*K_20*(K_01*K_01 + K_02*K_02)) + w[4][0]*(K_00*K_20*(2.000000000000000*K_01*K_21 + K_00*K_20) + K_01*K_01*K_21*K_21 + K_02*K_22*(2.000000000000000*(K_00*K_20 + K_01*K_21) + K_02*K_22)));
    const double G50 = det*(w[3][0]*(K_10*(K_10*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_11*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22) + K_12*(K_01*K_22 + K_02*K_21)) + K_12*K_12*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21)) + w[4][0]*(K_02*K_12*K_12*K_22 + K_10*(K_00*K_10*K_20 + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G51 = K_20*det*(1.500000000000000*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + 3.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G52 = det*(K_01*(w[3][0]*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22) + w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*w[3][0]*(K_00*K_00 + K_02*K_02));
    const double G53 = K_20*K_22*det*(w[3][0] + w[4][0]);
    const double G54 = det*(K_01*w[3][0]*(K_20*K_20 + K_22*K_22) + K_21*(w[3][0]*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22) + w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)));
    const double G55 = det*(K_10*(2.000000000000000*w[3][0]*(K_21*K_21 + K_22*K_22) + w[4][0]*(K_21*K_21 + K_22*K_22)) + K_20*(K_10*K_20*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_11*K_21*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_12*K_22*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])));
    const double G56 = det*(2.000000000000000*K_22*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G57 = det*(K_00*K_21*w[3][0] + K_01*K_20*w[4][0]);
    const double G58 = K_20*K_21*det*(w[3][0] + w[4][0]);
    const double G59 = det*(w[3][0]*(4.000000000000000*K_01*K_02*K_21*K_22 + K_20*(4.000000000000000*K_00*(K_01*K_21 + K_02*K_22) + K_20*(3.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_21*K_21*(3.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02) + K_22*K_22*(3.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01)) + w[4][0]*(0.500000000000000*(K_00*K_00*(K_21*K_21 + K_22*K_22) + K_01*K_01*K_22*K_22 + K_02*K_02*K_21*K_21 + K_20*K_20*(K_01*K_01 + K_02*K_02)) + 1.500000000000000*K_00*K_00*K_20*K_20 + K_01*K_21*(1.500000000000000*K_01*K_21 + 2.000000000000000*K_00*K_20) + K_02*K_22*(1.500000000000000*K_02*K_22 + 2.000000000000000*(K_00*K_20 + K_01*K_21))));
    const double G60 = det*(1.500000000000000*w[4][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)) + 3.000000000000000*w[3][0]*(K_02*K_22*K_22*K_22 + K_20*(K_00*(K_21*K_21 + K_22*K_22) + K_20*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*(K_01*(K_21*K_21 + K_22*K_22) + K_02*K_21*K_22)));
    const double G61 = det*(K_10*K_22*w[3][0] + K_12*K_20*w[4][0]);
    const double G62 = det*(1.500000000000000*w[4][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))) + 3.000000000000000*w[3][0]*(K_12*K_22*K_22*K_22 + K_20*(K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*(K_11*K_21 + K_12*K_22)) + K_21*(K_11*K_22*K_22 + K_21*(K_11*K_21 + K_12*K_22))));
    const double G63 = det*(2.000000000000000*w[3][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + w[4][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G64 = det*(K_00*K_00*(K_00*K_00*(w[3][0] + 0.500000000000000*w[4][0]) + K_01*K_01*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_02*(w[4][0] + 2.000000000000000*w[3][0])) + K_01*K_01*K_01*K_01*(w[3][0] + 0.500000000000000*w[4][0]) + K_02*K_02*(K_01*K_01*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_02*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G65 = K_00*K_01*det*(w[3][0] + w[4][0]);
    const double G66 = K_01*det*(0.500000000000000*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G67 = det*(0.500000000000000*K_01*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_11*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12));
    const double G68 = det*(w[3][0]*(2.000000000000000*(K_00*K_10*(K_00*K_10 + K_01*K_11) + K_01*K_01*K_11*K_11 + K_02*K_12*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_00*K_00*K_11*K_11 + K_01*K_01*K_10*K_10 + K_02*K_02*(K_10*K_10 + K_11*K_11) + K_12*K_12*(K_00*K_00 + K_01*K_01)) + w[4][0]*(K_00*K_10*(2.000000000000000*K_02*K_12 + K_00*K_10) + K_01*K_11*(2.000000000000000*(K_00*K_10 + K_02*K_12) + K_01*K_11) + K_02*K_02*K_12*K_12));
    const double G69 = det*(K_00*K_11*w[3][0] + K_01*K_10*w[4][0]);
    const double G70 = det*(w[3][0]*(2.000000000000000*(K_10*(K_00*K_21 + K_01*K_20) + K_11*(K_00*K_20 + K_02*K_22) + K_12*(K_01*K_22 + K_02*K_21)) + 6.000000000000000*K_01*K_11*K_21) + w[4][0]*(K_01*(3.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22) + K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)));
    const double G71 = det*(2.000000000000000*K_00*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_20*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G72 = det*(K_02*w[3][0]*(K_10*K_10 + K_11*K_11) + K_12*(K_00*K_10*(w[3][0] + w[4][0]) + K_01*K_11*(w[3][0] + w[4][0]) + K_02*K_12*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G73 = det*(1.500000000000000*w[4][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + 3.000000000000000*w[3][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G74 = det*(0.500000000000000*K_01*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_21*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G75 = det*(1.500000000000000*w[4][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + 3.000000000000000*w[3][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G76 = det*(0.500000000000000*w[4][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)) + w[3][0]*(K_00*(K_00*(K_01*K_11 + K_02*K_12) + K_10*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_11 + K_02*(K_01*(K_01*K_12 + K_02*K_11) + K_02*K_02*K_12)));
    const double G77 = det*(K_00*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_11*(w[3][0] + w[4][0]) + K_02*K_12*(w[3][0] + w[4][0])) + K_10*w[3][0]*(K_01*K_01 + K_02*K_02));
    const double G78 = det*(K_10*w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + w[3][0]*(K_00*(K_11*K_21 + K_12*K_22) + K_20*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G79 = det*(2.000000000000000*w[3][0]*(K_00*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_01*(K_02*K_11*K_22 + K_21*(K_01*K_11 + K_02*K_12)) + K_02*K_02*K_12*K_22) + w[4][0]*(K_10*K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*K_21*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_12*K_22*(K_00*K_00 + K_01*K_01 + K_02*K_02)));
    const double G80 = det*(K_01*(K_00*K_10*(w[3][0] + w[4][0]) + K_01*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(w[3][0] + w[4][0])) + K_11*w[3][0]*(K_00*K_00 + K_02*K_02));
    const double G81 = det*(K_01*(K_00*K_20*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_01*K_21*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_02*K_22*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])) + K_21*(K_00*K_00*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_02*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G82 = det*(2.000000000000000*w[3][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)) + w[4][0]*(K_00*(K_00*(K_01*K_21 + K_02*K_22) + K_20*(K_00*K_00 + K_01*K_01 + K_02*K_02)) + K_01*K_01*K_01*K_21 + K_02*(K_01*(K_01*K_22 + K_02*K_21) + K_02*K_02*K_22)));
    const double G83 = det*(w[3][0]*(K_00*(4.000000000000000*K_02*(K_10*K_22 + K_12*K_20) + K_00*(2.000000000000000*(K_11*K_21 + K_12*K_22) + 6.000000000000000*K_10*K_20)) + K_01*(4.000000000000000*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_01*(2.000000000000000*(K_10*K_20 + K_12*K_22) + 6.000000000000000*K_11*K_21)) + K_02*K_02*(2.000000000000000*(K_10*K_20 + K_11*K_21) + 6.000000000000000*K_12*K_22)) + w[4][0]*(K_00*(2.000000000000000*K_02*(K_10*K_22 + K_12*K_20) + K_00*(3.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_01*(2.000000000000000*(K_11*(K_00*K_20 + K_02*K_22) + K_21*(K_00*K_10 + K_02*K_12)) + K_01*(3.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22)) + K_02*K_02*(3.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)));
    const double G84 = det*(2.000000000000000*K_02*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_12*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G85 = det*(K_01*K_11*w[4][0] + w[3][0]*(2.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12));
    const double G86 = det*(K_22*w[4][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + w[3][0]*(K_02*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21) + K_12*(K_00*K_20 + K_01*K_21)));
    const double G87 = (0.500000000000000*det*w[4][0]*(K_00*K_00*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_01*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_02*(K_10*K_10 + K_11*K_11 + K_12*K_12)) + det*w[3][0]*(K_00*K_10*(2.000000000000000*K_02*K_12 + K_00*K_10) + K_01*K_11*(2.000000000000000*(K_00*K_10 + K_02*K_12) + K_01*K_11) + K_02*K_02*K_12*K_12));
    const double G88 = det*(0.500000000000000*w[4][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + w[3][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G89 = det*(w[3][0]*(4.000000000000000*K_00*K_02*K_10*K_12 + K_10*K_10*(3.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02) + K_11*(4.000000000000000*K_01*(K_00*K_10 + K_02*K_12) + K_11*(3.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02)) + K_12*K_12*(3.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01)) + w[4][0]*(0.500000000000000*(K_00*K_00*K_11*K_11 + K_01*K_01*K_10*K_10 + K_02*K_02*(K_10*K_10 + K_11*K_11) + K_12*K_12*(K_00*K_00 + K_01*K_01)) + 1.500000000000000*K_01*K_01*K_11*K_11 + K_00*K_10*(1.500000000000000*K_00*K_10 + 2.000000000000000*K_01*K_11) + K_02*K_12*(1.500000000000000*K_02*K_12 + 2.000000000000000*(K_00*K_10 + K_01*K_11))));
    const double G90 = det*(K_01*(K_20*K_20*(w[3][0] + 0.500000000000000*w[4][0]) + K_21*K_21*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_22*K_22*(w[3][0] + 0.500000000000000*w[4][0])) + K_21*(2.000000000000000*w[3][0]*(K_00*K_20 + K_02*K_22) + w[4][0]*(K_00*K_20 + K_02*K_22)));
    const double G91 = det*(0.500000000000000*w[4][0]*(K_00*K_10*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_01*K_11*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_02*K_12*(K_20*K_20 + K_21*K_21 + K_22*K_22)) + w[3][0]*(K_01*K_11*K_21*K_21 + K_20*(K_00*K_10*K_20 + K_21*(K_00*K_11 + K_01*K_10)) + K_22*(K_02*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_12*(K_00*K_20 + K_01*K_21))));
    const double G92 = det*(K_01*K_21*w[4][0] + w[3][0]*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22));
    const double G93 = K_01*K_02*det*(w[3][0] + w[4][0]);
    const double G94 = det*(2.000000000000000*K_02*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_22*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G95 = det*(K_01*(2.000000000000000*w[4][0]*(K_00*K_10 + K_02*K_12) + 4.000000000000000*w[3][0]*(K_00*K_10 + K_02*K_12)) + K_11*(K_00*K_00*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_01*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_02*K_02*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G96 = det*(2.000000000000000*K_00*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_10*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G97 = det*(K_00*w[3][0]*(K_11*K_11 + K_12*K_12) + K_10*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_11*(w[3][0] + w[4][0]) + K_02*K_12*(w[3][0] + w[4][0])));
    const double G98 = K_01*det*(1.500000000000000*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + 3.000000000000000*w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G99 = det*(K_02*(K_00*K_10*(w[3][0] + w[4][0]) + K_01*K_11*(w[3][0] + w[4][0]) + K_02*K_12*(w[4][0] + 2.000000000000000*w[3][0])) + K_12*w[3][0]*(K_00*K_00 + K_01*K_01));
    const double G100 = K_00*det*(2.000000000000000*w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G101 = det*(K_01*K_22*w[4][0] + K_02*K_21*w[3][0]);
    const double G102 = det*(K_00*(w[3][0]*(2.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22) + w[4][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_20*w[3][0]*(K_01*K_01 + K_02*K_02));
    const double G103 = det*(K_01*K_01*w[4][0] + w[3][0]*(2.000000000000000*K_01*K_01 + K_00*K_00 + K_02*K_02));
    const double G104 = K_02*det*(2.000000000000000*w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G105 = det*(K_01*K_12*w[4][0] + K_02*K_11*w[3][0]);
    const double G106 = det*(K_01*(K_10*K_10*(w[3][0] + 0.500000000000000*w[4][0]) + K_11*K_11*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_12*K_12*(w[3][0] + 0.500000000000000*w[4][0])) + K_11*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G107 = det*(w[3][0]*(K_20*(2.000000000000000*K_21*(K_00*K_11 + K_01*K_10) + K_20*(3.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)) + K_21*K_21*(3.000000000000000*K_01*K_11 + K_00*K_10 + K_02*K_12) + K_22*(2.000000000000000*(K_20*(K_00*K_12 + K_02*K_10) + K_21*(K_01*K_12 + K_02*K_11)) + K_22*(3.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11))) + w[4][0]*(K_20*(0.500000000000000*K_20*(K_01*K_11 + K_02*K_12) + K_00*(K_11*K_21 + K_12*K_22) + K_10*(1.500000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_21*K_21*(0.500000000000000*(K_00*K_10 + K_02*K_12) + 1.500000000000000*K_01*K_11) + K_22*(K_21*(K_01*K_12 + K_02*K_11) + K_22*(0.500000000000000*(K_00*K_10 + K_01*K_11) + 1.500000000000000*K_02*K_12))));
    const double G108 = det*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + w[3][0]*(K_01*K_11 + K_02*K_12));
    const double G109 = det*(K_00*(K_00*K_10*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_01*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(w[4][0] + 2.000000000000000*w[3][0])) + K_10*(K_01*K_01*(w[3][0] + 0.500000000000000*w[4][0]) + K_02*K_02*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G110 = K_10*det*(0.500000000000000*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G111 = det*(1.500000000000000*w[4][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + 3.000000000000000*w[3][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G112 = det*(K_10*K_10*w[4][0] + w[3][0]*(2.000000000000000*K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G113 = det*(2.000000000000000*w[3][0]*(K_02*K_12*K_12*K_22 + K_10*(K_00*K_10*K_20 + K_12*(K_00*K_22 + K_02*K_20)) + K_11*(K_01*(K_10*K_20 + K_12*K_22) + K_21*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + w[4][0]*(K_00*K_20*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_01*K_21*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_02*K_22*(K_10*K_10 + K_11*K_11 + K_12*K_12)));
    const double G114 = det*(K_10*(w[3][0]*(2.000000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22) + w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22)) + K_20*w[3][0]*(K_11*K_11 + K_12*K_12));
    const double G115 = det*(0.500000000000000*K_10*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G116 = det*(K_10*K_10*K_10*K_10*(w[3][0] + 0.500000000000000*w[4][0]) + K_11*K_11*(K_10*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_11*K_11*(w[3][0] + 0.500000000000000*w[4][0])) + K_12*K_12*(K_10*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_11*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_12*K_12*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G117 = det*(2.000000000000000*K_12*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_02*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G118 = det*(K_01*w[3][0]*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10*(w[3][0] + w[4][0]) + K_01*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(w[3][0] + w[4][0])));
    const double G119 = det*(2.000000000000000*K_11*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G120 = det*(K_00*(K_10*K_10*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_11*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_12*K_12*(w[4][0] + 2.000000000000000*w[3][0])) + K_10*(K_01*K_11*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_02*K_12*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])));
    const double G121 = K_10*K_11*det*(w[3][0] + w[4][0]);
    const double G122 = det*(K_00*K_12*w[3][0] + K_02*K_10*w[4][0]);
    const double G123 = det*(2.000000000000000*w[3][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + w[4][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G124 = det*(2.000000000000000*K_12*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_22*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G125 = K_10*det*(1.500000000000000*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + 3.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G126 = det*(2.000000000000000*K_11*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_01*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G127 = det*(0.500000000000000*K_10*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_00*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12));
    const double G128 = K_11*det*(2.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G129 = det*(w[3][0]*(K_10*(4.000000000000000*(K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_10*(2.000000000000000*(K_01*K_21 + K_02*K_22) + 6.000000000000000*K_00*K_20)) + K_11*(4.000000000000000*K_12*(K_01*K_22 + K_02*K_21) + K_11*(2.000000000000000*(K_00*K_20 + K_02*K_22) + 6.000000000000000*K_01*K_21)) + K_12*K_12*(2.000000000000000*(K_00*K_20 + K_01*K_21) + 6.000000000000000*K_02*K_22)) + w[4][0]*(K_10*(2.000000000000000*(K_11*(K_00*K_21 + K_01*K_20) + K_12*(K_00*K_22 + K_02*K_20)) + K_10*(3.000000000000000*K_00*K_20 + K_01*K_21 + K_02*K_22)) + K_11*(2.000000000000000*K_12*(K_01*K_22 + K_02*K_21) + K_11*(3.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22)) + K_12*K_12*(3.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21)));
    const double G130 = K_12*det*(2.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G131 = det*(1.500000000000000*w[4][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))) + 3.000000000000000*w[3][0]*(K_10*K_10*K_10*K_20 + K_11*(K_11*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_21*(K_10*K_10 + K_12*K_12)) + K_12*(K_10*K_10*K_22 + K_12*(K_10*K_20 + K_12*K_22))));
    const double G132 = det*(2.000000000000000*w[3][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))) + w[4][0]*(K_02*K_12*K_12*K_12 + K_10*(K_00*K_10*K_10 + K_12*(K_00*K_12 + K_02*K_10)) + K_11*(K_01*(K_10*K_10 + K_12*K_12) + K_11*(K_00*K_10 + K_01*K_11 + K_02*K_12))));
    const double G133 = det*(K_10*(K_21*K_21*(w[3][0] + 0.500000000000000*w[4][0]) + K_22*K_22*(w[3][0] + 0.500000000000000*w[4][0])) + K_20*(w[3][0]*(2.000000000000000*(K_11*K_21 + K_12*K_22) + 3.000000000000000*K_10*K_20) + w[4][0]*(1.500000000000000*K_10*K_20 + K_11*K_21 + K_12*K_22)));
    const double G134 = det*(K_10*K_22*w[4][0] + K_12*K_20*w[3][0]);
    const double G135 = det*(K_21*w[4][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + w[3][0]*(K_01*(K_10*K_20 + K_12*K_22) + K_11*(2.000000000000000*K_01*K_21 + K_00*K_20 + K_02*K_22)));
    const double G136 = det*(K_10*(K_10*K_20*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_11*K_21*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_12*K_22*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])) + K_20*(2.000000000000000*w[3][0]*(K_11*K_11 + K_12*K_12) + w[4][0]*(K_11*K_11 + K_12*K_12)));
    const double G137 = det*(K_10*K_21*w[4][0] + K_11*K_20*w[3][0]);
    const double G138 = K_10*K_12*det*(w[3][0] + w[4][0]);
    const double G139 = det*(K_00*K_11*w[4][0] + K_01*K_10*w[3][0]);
    const double G140 = det*(0.500000000000000*K_11*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_01*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12));
    const double G141 = K_11*det*(0.500000000000000*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G142 = det*(2.000000000000000*K_10*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_20*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G143 = det*(K_11*(2.000000000000000*w[4][0]*(K_10*K_20 + K_12*K_22) + 4.000000000000000*w[3][0]*(K_10*K_20 + K_12*K_22)) + K_21*(K_10*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_11*K_11*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_12*K_12*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G144 = det*(0.500000000000000*K_11*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_21*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G145 = det*(2.000000000000000*K_10*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_00*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G146 = det*(K_11*K_11*w[4][0] + w[3][0]*(2.000000000000000*K_11*K_11 + K_10*K_10 + K_12*K_12));
    const double G147 = det*(K_11*(K_20*K_20*(w[3][0] + 0.500000000000000*w[4][0]) + K_22*K_22*(w[3][0] + 0.500000000000000*w[4][0])) + K_21*(K_10*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_11*K_21*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_12*K_22*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G148 = det*(K_11*K_21*w[4][0] + w[3][0]*(2.000000000000000*K_11*K_21 + K_10*K_20 + K_12*K_22));
    const double G149 = det*(K_01*K_12*w[3][0] + K_02*K_11*w[4][0]);
    const double G150 = det*(K_01*(K_10*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_11*K_11*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_12*K_12*(w[4][0] + 2.000000000000000*w[3][0])) + K_11*(2.000000000000000*w[4][0]*(K_00*K_10 + K_02*K_12) + 4.000000000000000*w[3][0]*(K_00*K_10 + K_02*K_12)));
    const double G151 = K_10*det*(2.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G152 = det*(K_01*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_11*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_02*K_12*(w[4][0] + 2.000000000000000*w[3][0])) + K_11*(0.500000000000000*w[4][0]*(K_00*K_00 + K_02*K_02) + w[3][0]*(K_00*K_00 + K_02*K_02)));
    const double G153 = det*(K_11*K_22*w[4][0] + K_12*K_21*w[3][0]);
    const double G154 = det*(K_00*w[4][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + w[3][0]*(K_10*(K_01*K_21 + K_02*K_22) + K_20*(2.000000000000000*K_00*K_10 + K_01*K_11 + K_02*K_12)));
    const double G155 = K_11*K_12*det*(w[3][0] + w[4][0]);
    const double G156 = K_11*det*(1.500000000000000*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + 3.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G157 = K_00*K_02*det*(w[3][0] + w[4][0]);
    const double G158 = K_02*det*(0.500000000000000*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G159 = det*(K_02*(K_10*K_10*(w[3][0] + 0.500000000000000*w[4][0]) + K_11*K_11*(w[3][0] + 0.500000000000000*w[4][0])) + K_12*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0])));
    const double G160 = det*(K_02*(K_20*K_20*(w[3][0] + 0.500000000000000*w[4][0]) + K_21*K_21*(w[3][0] + 0.500000000000000*w[4][0])) + K_22*(K_00*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_21*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_22*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0])));
    const double G161 = det*(2.000000000000000*K_01*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_21*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G162 = det*(w[3][0]*(2.000000000000000*(K_10*(K_00*K_22 + K_02*K_20) + K_11*(K_01*K_22 + K_02*K_21) + K_12*(K_00*K_20 + K_01*K_21)) + 6.000000000000000*K_02*K_12*K_22) + w[4][0]*(K_00*(K_10*K_22 + K_12*K_20) + K_01*(K_11*K_22 + K_12*K_21) + K_02*(3.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21)));
    const double G163 = det*(K_02*K_02*w[4][0] + w[3][0]*(2.000000000000000*K_02*K_02 + K_00*K_00 + K_01*K_01));
    const double G164 = det*(0.500000000000000*K_02*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_22*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G165 = det*(K_01*K_22*w[3][0] + K_02*K_21*w[4][0]);
    const double G166 = det*(0.500000000000000*K_02*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_12*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12));
    const double G167 = K_02*det*(1.500000000000000*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + 3.000000000000000*w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G168 = det*(K_02*(K_00*K_10*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_01*K_11*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])) + K_12*(K_00*K_00*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_01*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_02*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0])));
    const double G169 = det*(K_02*K_22*w[4][0] + w[3][0]*(2.000000000000000*K_02*K_22 + K_00*K_20 + K_01*K_21));
    const double G170 = K_01*det*(2.000000000000000*w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G171 = det*(K_02*K_12*w[4][0] + w[3][0]*(2.000000000000000*K_02*K_12 + K_00*K_10 + K_01*K_11));
    const double G172 = det*(2.000000000000000*K_01*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12) + K_11*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G173 = det*(K_02*(2.000000000000000*w[4][0]*(K_00*K_20 + K_01*K_21) + 4.000000000000000*w[3][0]*(K_00*K_20 + K_01*K_21)) + K_22*(K_00*K_00*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_01*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_02*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0])));
    const double G174 = det*(K_00*K_21*w[4][0] + K_01*K_20*w[3][0]);
    const double G175 = det*(0.500000000000000*K_21*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_01*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G176 = det*(0.500000000000000*K_21*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_11*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G177 = det*(K_11*(K_20*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_22*K_22*(w[4][0] + 2.000000000000000*w[3][0])) + K_21*(K_10*K_20*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_11*K_21*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_12*K_22*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])));
    const double G178 = K_21*det*(0.500000000000000*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G179 = det*(2.000000000000000*K_20*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22) + K_10*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G180 = det*(K_01*(K_20*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_22*K_22*(w[4][0] + 2.000000000000000*w[3][0])) + K_21*(K_00*K_20*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_01*K_21*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_02*K_22*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])));
    const double G181 = K_21*det*(1.500000000000000*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + 3.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G182 = det*(K_21*K_21*w[4][0] + w[3][0]*(2.000000000000000*K_21*K_21 + K_20*K_20 + K_22*K_22));
    const double G183 = det*(K_01*(K_00*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_21*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_02*K_22*(w[4][0] + 2.000000000000000*w[3][0])) + K_21*(0.500000000000000*w[4][0]*(K_00*K_00 + K_02*K_02) + w[3][0]*(K_00*K_00 + K_02*K_02)));
    const double G184 = K_21*K_22*det*(w[3][0] + w[4][0]);
    const double G185 = det*(2.000000000000000*K_20*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22) + K_00*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G186 = det*(K_11*K_22*w[3][0] + K_12*K_21*w[4][0]);
    const double G187 = K_20*det*(2.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G188 = det*(K_11*(2.000000000000000*w[3][0]*(K_10*K_20 + K_12*K_22) + w[4][0]*(K_10*K_20 + K_12*K_22)) + K_21*(K_10*K_10*(w[3][0] + 0.500000000000000*w[4][0]) + K_11*K_11*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_12*K_12*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G189 = det*(K_00*K_22*w[4][0] + K_02*K_20*w[3][0]);
    const double G190 = det*(0.500000000000000*K_22*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_02*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G191 = det*(K_12*(K_10*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_11*K_21*(w[4][0] + 2.000000000000000*w[3][0]) + K_12*K_22*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0])) + K_22*(K_10*K_10*(w[3][0] + 0.500000000000000*w[4][0]) + K_11*K_11*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G192 = K_22*det*(1.500000000000000*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + 3.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G193 = det*(K_12*(K_20*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_21*K_21*(w[4][0] + 2.000000000000000*w[3][0]) + K_22*K_22*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0])) + K_22*(2.000000000000000*w[4][0]*(K_10*K_20 + K_11*K_21) + 4.000000000000000*w[3][0]*(K_10*K_20 + K_11*K_21)));
    const double G194 = K_22*det*(0.500000000000000*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + w[3][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22));
    const double G195 = det*(0.500000000000000*K_22*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_12*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G196 = det*(K_02*(K_00*K_20*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_21*(w[4][0] + 2.000000000000000*w[3][0])) + K_22*(K_00*K_00*(w[3][0] + 0.500000000000000*w[4][0]) + K_01*K_01*(w[3][0] + 0.500000000000000*w[4][0]) + K_02*K_02*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0])));
    const double G197 = det*(K_22*K_22*w[4][0] + w[3][0]*(2.000000000000000*K_22*K_22 + K_20*K_20 + K_21*K_21));
    const double G198 = det*(K_12*K_22*w[4][0] + w[3][0]*(2.000000000000000*K_12*K_22 + K_10*K_20 + K_11*K_21));
    const double G199 = det*(K_02*(2.000000000000000*w[3][0]*(K_20*K_20 + K_21*K_21) + w[4][0]*(K_20*K_20 + K_21*K_21)) + K_22*(K_00*K_20*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_01*K_21*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_02*K_22*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0])));
    const double G200 = det*(K_00*K_12*w[4][0] + K_02*K_10*w[3][0]);
    const double G201 = det*(0.500000000000000*K_12*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + K_02*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12));
    const double G202 = K_12*det*(1.500000000000000*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + 3.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G203 = det*(K_12*(K_20*K_20*(w[3][0] + 0.500000000000000*w[4][0]) + K_21*K_21*(w[3][0] + 0.500000000000000*w[4][0]) + K_22*K_22*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0])) + K_22*(2.000000000000000*w[3][0]*(K_10*K_20 + K_11*K_21) + w[4][0]*(K_10*K_20 + K_11*K_21)));
    const double G204 = det*(K_12*(w[3][0]*(4.000000000000000*(K_10*K_20 + K_11*K_21) + 6.000000000000000*K_12*K_22) + w[4][0]*(2.000000000000000*(K_10*K_20 + K_11*K_21) + 3.000000000000000*K_12*K_22)) + K_22*(2.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11) + w[4][0]*(K_10*K_10 + K_11*K_11)));
    const double G205 = det*(0.500000000000000*K_12*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_22*w[3][0]*(K_10*K_20 + K_11*K_21 + K_12*K_22));
    const double G206 = K_12*det*(0.500000000000000*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + w[3][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12));
    const double G207 = det*(K_02*(K_00*K_10*(w[4][0] + 2.000000000000000*w[3][0]) + K_01*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0])) + K_12*(K_00*K_00*(w[3][0] + 0.500000000000000*w[4][0]) + K_01*K_01*(w[3][0] + 0.500000000000000*w[4][0])));
    const double G208 = det*(K_02*(2.000000000000000*w[3][0]*(K_10*K_10 + K_11*K_11) + w[4][0]*(K_10*K_10 + K_11*K_11)) + K_12*(K_00*K_10*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_01*K_11*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_02*K_12*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0])));
    const double G209 = det*(K_12*K_12*w[4][0] + w[3][0]*(2.000000000000000*K_12*K_12 + K_10*K_10 + K_11*K_11));
    const double G210 = det*(K_00*K_00*w[4][0] + w[3][0]*(2.000000000000000*K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G211 = K_00*det*(1.500000000000000*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + 3.000000000000000*w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G212 = det*(0.500000000000000*K_00*w[4][0]*(K_10*K_10 + K_11*K_11 + K_12*K_12) + K_10*w[3][0]*(K_00*K_10 + K_01*K_11 + K_02*K_12));
    const double G213 = det*(0.500000000000000*K_00*w[4][0]*(K_20*K_20 + K_21*K_21 + K_22*K_22) + K_20*w[3][0]*(K_00*K_20 + K_01*K_21 + K_02*K_22));
    const double G214 = det*(K_00*(K_00*K_10*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_01*K_11*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0]) + K_02*K_12*(2.000000000000000*w[4][0] + 4.000000000000000*w[3][0])) + K_10*(2.000000000000000*w[3][0]*(K_01*K_01 + K_02*K_02) + w[4][0]*(K_01*K_01 + K_02*K_02)));
    const double G215 = det*(K_00*(2.000000000000000*w[4][0]*(K_01*K_21 + K_02*K_22) + 4.000000000000000*w[3][0]*(K_01*K_21 + K_02*K_22)) + K_20*(K_00*K_00*(3.000000000000000*w[4][0] + 6.000000000000000*w[3][0]) + K_01*K_01*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_02*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G216 = det*(K_00*(K_10*K_10*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_11*K_11*(w[3][0] + 0.500000000000000*w[4][0]) + K_12*K_12*(w[3][0] + 0.500000000000000*w[4][0])) + K_10*(K_01*K_11*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_12*(w[4][0] + 2.000000000000000*w[3][0])));
    const double G217 = K_00*det*(0.500000000000000*w[4][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02) + w[3][0]*(K_00*K_00 + K_01*K_01 + K_02*K_02));
    const double G218 = det*(K_00*(K_21*K_21*(w[3][0] + 0.500000000000000*w[4][0]) + K_22*K_22*(w[3][0] + 0.500000000000000*w[4][0])) + K_20*(K_00*K_20*(1.500000000000000*w[4][0] + 3.000000000000000*w[3][0]) + K_01*K_21*(w[4][0] + 2.000000000000000*w[3][0]) + K_02*K_22*(w[4][0] + 2.000000000000000*w[3][0])));
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('simplify expressions', True), ('ignore zero tables', True), ('non zero columns', True), ('remove zero terms', True), ('ignore ones', True)
    
    // Loop quadrature points for integral
    // Number of operations to compute element tensor for following IP loop = 14176
    for (unsigned int ip = 0; ip < 8; ip++)
    {
      
      // Coefficient declarations
      double F0 = 0.000000000000000;
      double F1 = 0.000000000000000;
      double F2 = 0.000000000000000;
      double F3 = 0.000000000000000;
      double F4 = 0.000000000000000;
      double F5 = 0.000000000000000;
      double F6 = 0.000000000000000;
      double F7 = 0.000000000000000;
      double F8 = 0.000000000000000;
      double F9 = 0.000000000000000;
      double F10 = 0.000000000000000;
      double F11 = 0.000000000000000;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F0 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F1 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 4; r++)
      {
        F9 += FE1_C0[ip][r]*w[1][nzc0[r]];
        F10 += FE1_C0[ip][r]*w[1][nzc4[r]];
        F11 += FE1_C0[ip][r]*w[1][nzc8[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 1652
      // Number of operations: 182
      const double Gip0 = W8[ip]*(F0*(G3 + F0*(G4 + F0*G23) + F2*(G39 + F0*G59 + F2*G60) + F3*(G52 + F3*G23) + F4*(G19 + F3*G0 + F4*G13 + F5*G6) + F5*(G54 + F3*G49 + F5*G1) + F6*(G15 + F6*G23 + F7*G0) + F7*(G35 + F7*G13) + F8*(G26 + F6*G49 + F7*G6 + F8*G1)) + F1*(G8 + F0*(G22 + F0*G14) + F1*(G41 + F0*G7 + F1*G17) + F2*(G55 + F0*G45 + F1*G48 + F2*G62) + F3*(G42 + F3*G38 + F4*G50) + F4*(G44 + F4*G17) + F5*(G21 + F3*G6 + F4*G33 + F5*G31) + F6*(G18 + F6*G38 + F7*G50) + F7*(G47 + F7*G17) + F8*(G34 + F6*G6 + F7*G33 + F8*G31)) + F2*(G36 + F2*(G51 + F2*G11) + F3*(G12 + F3*G2) + F4*(G9 + F3*G46 + F4*G25) + F5*(G37 + F3*G28 + F4*G32 + F5*G11) + F6*(G30 + F6*G2 + F7*G46) + F7*(G56 + F7*G25) + F8*(G20 + F6*G28 + F7*G32 + F8*G11)) + F3*(G57 + F3*G43 + F4*G40) + F4*(G27 + F4*G5) + F5*(G58 + F3*G24 + F4*G10 + F5*G16) + F6*(G29 + F6*G43 + F8*G24) + F7*(G61 + F6*G40 + F7*G5 + F8*G10) + F8*(G53 + F8*G16));
      
      // Number of operations: 183
      const double Gip1 = W8[ip]*(F0*(G65 + F0*G66 + F1*G80 + F2*G52) + F1*(G69 + F1*G67 + F2*G42) + F2*(G57 + F2*G74) + F3*(G103 + F0*(G100 + F0*G64 + F1*G63 + F2*G82) + F1*(G96 + F1*G87 + F2*G79) + F2*(G71 + F2*G2) + F3*(G98 + F3*G64) + F5*(G81 + F3*G73 + F5*G59) + F6*(G104 + F6*G64 + F7*G63) + F7*(G84 + F7*G87) + F8*(G94 + F6*G82 + F7*G79 + F8*G2)) + F4*(G85 + F0*(G77 + F0*G76 + F1*G68 + F2*G0) + F1*(G97 + F1*G88 + F2*G50) + F2*(G40 + F2*G91) + F3*(G95 + F3*G75) + F4*(G106 + F3*G89 + F4*G88 + F5*G7) + F5*(G70 + F3*G83 + F5*G107) + F6*(G99 + F6*G76 + F8*G0) + F7*(G72 + F6*G68 + F7*G88 + F8*G50) + F8*(G86 + F8*G91)) + F5*(G92 + F0*(G102 + F0*G23 + F1*G0 + F2*G49) + F1*G78 + F2*(G24 + F1*G6 + F2*G1) + F5*(G90 + F5*G1) + F6*(G15 + F6*G23 + F7*G0) + F7*G35 + F8*(G26 + F6*G49 + F7*G6 + F8*G1) + G13*(F1*F1 + F7*F7)) + F6*(G93 + F6*G66 + F7*G80) + F7*(G105 + F7*G67) + F8*(G101 + F6*G52 + F7*G42 + F8*G74));
      
      // Number of operations: 184
      const double Gip2 = W8[ip]*(F0*(G108 + F0*G109 + F2*(G22 + F0*G14 + F2*G107) + F3*G80 + F4*(G118 + F3*G68 + F4*G88 + F5*G50) + F5*(G135 + F3*G0 + F5*G91) + F6*G99 + F7*(G72 + F6*G68 + F7*G88) + F8*(G86 + F6*G0 + F7*G50 + F8*G91) + G76*(F0*F0 + F3*F3 + F6*F6)) + F1*(G112 + F0*(G120 + F0*G89 + F1*G111 + F2*G129) + F1*(G125 + F1*G116 + F2*G131) + F2*(G136 + F2*G48) + F3*(G126 + F3*G87) + F4*(G128 + F3*G132 + F4*G116 + F5*G123) + F5*(G119 + F3*G113 + F5*G25) + F6*(G117 + F6*G87 + F7*G132) + F7*(G130 + F7*G116) + F8*(G124 + F6*G113 + F7*G123 + F8*G25)) + F2*(G8 + F2*(G133 + F2*G31) + F3*(G42 + F3*G38 + F4*G50) + F4*(G44 + F4*G17) + F5*(G21 + F3*G6 + F4*G33 + F5*G31) + F6*(G18 + F6*G38 + F7*G50) + F7*(G47 + F7*G17) + F8*(G34 + F6*G6 + F7*G33 + F8*G31)) + F3*(G69 + F3*G127 + F4*G97) + F4*G121 + F5*(G137 + F3*G78 + F4*G114 + F5*G115) + F6*(G122 + F6*G127 + F7*G97) + F7*G138 + F8*(G134 + F6*G78 + F7*G114 + F8*G115) + G110*(F4*F4 + F7*F7));
      
      // Number of operations: 184
      const double Gip3 = W8[ip]*(F0*(G139 + F0*G140) + F1*(G121 + F0*G118 + F1*G141) + F2*(G27 + F0*G19 + F1*G44 + F2*G144) + F3*(G85 + F0*G77 + F1*(G97 + F0*G68 + F1*G88 + F2*G50) + F2*(G40 + F0*G0 + F2*G91) + F3*G152 + F5*(G70 + F3*G14 + F5*G107) + F6*G99 + F7*(G72 + F6*G68 + F7*G88) + F8*(G86 + F6*G0 + F7*G50 + F8*G91) + G76*(F0*F0 + F3*F3 + F6*F6)) + F4*(G146 + F0*(G145 + F0*G87 + F1*G132 + F2*G113) + F1*(G151 + F1*G116 + F2*G123) + F2*(G142 + F2*G25) + F3*(G150 + F3*G89 + F4*G111) + F4*(G156 + F4*G116) + F5*(G143 + F3*G129 + F4*G131 + F5*G48) + F6*(G117 + F6*G87 + F7*G132) + F7*(G130 + F7*G116) + F8*(G124 + F6*G113 + F7*G123 + F8*G25)) + F5*(G148 + F0*(G154 + F0*G38 + F1*G50 + F2*G6) + F1*(G114 + F1*G17 + F2*G33) + F2*G10 + F5*G147 + F6*(G18 + F6*G38 + F7*G50) + F7*(G47 + F7*G17) + F8*(G34 + F6*G6 + F7*G33 + F8*G31) + G31*(F2*F2 + F5*F5)) + F6*(G149 + F6*G140 + F7*G118) + F7*(G155 + F7*G141) + F8*(G153 + F6*G19 + F7*G44 + F8*G144));
      
      // Number of operations: 182
      const double Gip4 = W8[ip]*(F0*(G157 + F0*G158 + F1*G99 + F2*G15) + F1*(G122 + F1*G166 + F2*G18) + F2*(G29 + F2*G164) + F3*(G93 + F3*G158 + F4*G99) + F4*(G149 + F4*G166) + F5*(G165 + F3*G15 + F4*G18 + F5*G164) + F6*(G163 + F0*(G100 + F0*G64 + F1*G63 + F2*G82) + F1*(G96 + F1*G87 + F2*G79) + F2*(G71 + F2*G2) + F3*(G170 + F3*G64 + F4*G63) + F4*(G172 + F4*G87) + F5*(G161 + F3*G82 + F4*G79 + F5*G2) + F6*(G167 + F6*G64)) + F7*(G171 + F0*(G77 + F0*G76 + F1*G68 + F2*G0) + F1*(G97 + F1*G88 + F2*G50) + F2*(G40 + F2*G91) + F3*(G80 + F3*G76) + F4*(G118 + F3*G68 + F4*G88 + F5*G50) + F5*(G135 + F3*G0 + F5*G91) + F6*(G168 + F6*G75 + F8*G83) + F7*(G159 + F6*G89 + F7*G88 + F8*G7) + F8*(G162 + F8*G107)) + F8*(G169 + F0*(G102 + F0*G23 + F1*G0 + F2*G49) + F1*(G78 + F1*G13 + F2*G6) + F2*(G24 + F2*G1) + F3*(G52 + F3*G23 + F4*G0) + F4*(G19 + F4*G13) + F5*(G54 + F3*G49 + F4*G6 + F5*G1) + F6*(G173 + F6*G73 + F8*G59) + F8*(G160 + F8*G1)));
      
      // Number of operations: 2
      const double Gip5 =  - F11*W8[ip]*det;
      
      // Number of operations: 2
      const double Gip6 =  - F9*W8[ip]*det;
      
      // Number of operations: 2
      const double Gip7 =  - F10*W8[ip]*det;
      
      // Number of operations: 182
      const double Gip8 = W8[ip]*(F0*(G174 + F0*G175 + F1*G135 + F2*G54) + F1*(G137 + F1*G176 + F2*G21) + F2*(G58 + F2*G178) + F3*(G92 + F0*(G102 + F0*G23 + F1*G0 + F2*G49) + F1*(G78 + F1*G13 + F2*G6) + F2*(G24 + F2*G1) + F3*(G183 + F3*G23) + F5*(G180 + F3*G59 + F5*G60) + F6*(G15 + F6*G23 + F7*G0) + F7*(G35 + F7*G13) + F8*(G26 + F6*G49 + F7*G6 + F8*G1)) + F4*(G148 + F0*(G154 + F0*G38 + F1*G50 + F2*G6) + F1*(G114 + F1*G17 + F2*G33) + F2*(G10 + F2*G31) + F3*(G70 + F3*G14 + F4*G7) + F4*(G188 + F4*G17) + F5*(G177 + F3*G45 + F4*G48 + F5*G62) + F6*(G18 + F6*G38 + F7*G50) + F7*(G47 + F7*G17) + F8*(G34 + F6*G6 + F7*G33 + F8*G31)) + F5*(G182 + F0*(G185 + F0*G2 + F1*G46 + F2*G28) + F1*(G179 + F1*G25 + F2*G32) + F2*(G187 + F2*G11) + F5*(G181 + F5*G11) + F6*(G30 + F6*G2 + F7*G46) + F7*(G56 + F7*G25) + F8*(G20 + F6*G28 + F7*G32 + F8*G11)) + F6*(G165 + F6*G175 + F7*G135) + F7*(G186 + F7*G176) + F8*(G184 + F6*G54 + F7*G21 + F8*G178));
      
      // Number of operations: 182
      const double Gip9 = W8[ip]*(F0*(G189 + F0*G190 + F1*G86 + F2*G26) + F1*(G134 + F1*G195 + F2*G34) + F2*(G53 + F2*G194) + F3*(G101 + F3*G190 + F4*G86) + F4*(G153 + F4*G195) + F5*(G184 + F3*G26 + F4*G34 + F5*G194) + F6*(G169 + F0*(G102 + F0*G23 + F1*G0 + F2*G49) + F1*(G78 + F1*G13 + F2*G6) + F2*(G24 + F2*G1) + F3*(G52 + F3*G23 + F4*G0) + F4*(G19 + F4*G13) + F5*(G54 + F3*G49 + F4*G6 + F5*G1) + F6*(G196 + F6*G23)) + F7*(G198 + F0*(G154 + F0*G38 + F1*G50 + F2*G6) + F1*(G114 + F1*G17 + F2*G33) + F2*(G10 + F2*G31) + F3*(G42 + F3*G38 + F4*G50) + F4*(G44 + F4*G17) + F5*(G21 + F3*G6 + F4*G33 + F5*G31) + F6*(G162 + F6*G14 + F8*G45) + F7*(G191 + F6*G7 + F7*G17 + F8*G48) + F8*(G193 + F8*G62)) + F8*(G197 + F0*(G185 + F0*G2 + F1*G46 + F2*G28) + F1*(G179 + F1*G25 + F2*G32) + F2*(G187 + F2*G11) + F3*(G12 + F3*G2 + F4*G46) + F4*(G9 + F4*G25) + F5*(G37 + F3*G28 + F4*G32 + F5*G11) + F6*(G199 + F6*G59 + F8*G60) + F8*(G192 + F8*G11)));
      
      // Number of operations: 183
      const double Gip10 = W8[ip]*(F0*(G200 + F0*G201) + F1*(G138 + F0*G72 + F1*G206) + F2*(G61 + F0*G35 + F1*G47 + F2*G205) + F3*(G105 + F3*G201 + F5*G35) + F4*(G155 + F3*G72 + F4*G206 + F5*G47) + F5*(G186 + F5*G205) + F6*(G171 + F0*(G77 + F0*G76 + F1*G68 + F2*G0) + F1*(G97 + F1*G88 + F2*G50) + F2*(G40 + F2*G91) + F3*G80 + F4*(G118 + F3*G68 + F4*G88 + F5*G50) + F5*(G135 + F3*G0 + F5*G91) + F6*G207 + G76*(F3*F3 + F6*F6)) + F7*(G209 + F0*(G145 + F0*G87 + F1*G132 + F2*G113) + F1*(G151 + F1*G116 + F2*G123) + F2*(G142 + F2*G25) + F3*(G126 + F3*G87) + F4*(G128 + F3*G132 + F4*G116 + F5*G123) + F5*(G119 + F3*G113 + F5*G25) + F6*(G208 + F6*G89 + F7*G111) + F7*(G202 + F7*G116) + F8*(G204 + F6*G129 + F7*G131 + F8*G48)) + F8*(G198 + F0*(G154 + F0*G38) + F1*(G114 + F0*G50 + F1*G17 + F2*G33) + F2*(G10 + F0*G6 + F2*G31) + F3*(G42 + F3*G38 + F4*G50) + F4*(G44 + F4*G17) + F5*(G21 + F3*G6 + F4*G33 + F5*G31) + F6*(G162 + F6*G14 + F8*G107) + F8*(G203 + F8*G31)));
      
      // Number of operations: 184
      const double Gip11 = W8[ip]*(F0*(G210 + F0*(G211 + F0*G64) + F2*(G215 + F0*G73 + F2*G59) + F3*(G170 + F3*G64 + F4*G63) + F4*(G172 + F4*G87) + F5*(G161 + F3*G82 + F4*G79 + F5*G2) + F6*(G104 + F6*G64 + F7*G63) + F7*(G84 + F7*G87) + F8*(G94 + F6*G82 + F7*G79 + F8*G2)) + F1*(G108 + F0*(G214 + F0*G75 + F1*G89 + F2*G83) + F1*(G216 + F1*G88 + F2*G7) + F2*(G22 + F2*G107) + F3*(G80 + F3*G76) + F4*(G118 + F3*G68 + F4*G88 + F5*G50) + F5*(G135 + F3*G0 + F5*G91) + F6*(G99 + F6*G76 + F7*G68) + F7*(G72 + F7*G88) + F8*(G86 + F6*G0 + F7*G50 + F8*G91)) + F2*(G3 + F2*(G218 + F2*G1) + F3*(G52 + F3*G23 + F4*G0) + F4*G19 + F5*(G54 + F3*G49 + F4*G6 + F5*G1) + F6*(G15 + F6*G23 + F7*G0) + F7*G35 + F8*(G26 + F6*G49 + F7*G6 + F8*G1) + G13*(F4*F4 + F7*F7)) + F3*(G65 + F3*G217 + F4*G77) + F4*G139 + F5*(G174 + F3*G102 + F4*G154 + F5*G213) + F6*(G157 + F6*G217 + F7*G77) + F7*G200 + F8*(G189 + F6*G102 + F7*G154 + F8*G213) + G212*(F4*F4 + F7*F7));
      
      
      // Number of operations for primary indices: 36
      for (unsigned int j = 0; j < 2; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE1_C0_D001[ip][j]*Gip0;
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE1_C0_D001[ip][j]*Gip1;
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE1_C0_D001[ip][j]*Gip2;
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE1_C0_D001[ip][j]*Gip3;
        // Number of operations to compute entry: 2
        A[nzc11[j]] += FE1_C0_D001[ip][j]*Gip4;
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE1_C0_D001[ip][j]*Gip8;
        // Number of operations to compute entry: 2
        A[nzc9[j]] += FE1_C0_D001[ip][j]*Gip9;
        // Number of operations to compute entry: 2
        A[nzc10[j]] += FE1_C0_D001[ip][j]*Gip10;
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE1_C0_D001[ip][j]*Gip11;
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE1_C0[ip][j]*Gip5;
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE1_C0[ip][j]*Gip6;
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE1_C0[ip][j]*Gip7;
      }// end loop over 'j'
    }// end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class hyperelasticity_exterior_facet_integral_1_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  hyperelasticity_exterior_facet_integral_1_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_exterior_facet_integral_1_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      52
    // Number of operations (multiply-add pairs) for geometry tensor:    12
    // Number of operations (multiply-add pairs) for tensor contraction: 108
    // Total number of operations (multiply-add pairs):                  172
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute sub determinants
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on face
    static unsigned int face_vertices[4][3] = {{1, 2, 3}, {0, 2, 3}, {0, 1, 3}, {0, 1, 2}};
    const unsigned int v0 = face_vertices[facet][0];
    const unsigned int v1 = face_vertices[facet][1];
    const unsigned int v2 = face_vertices[facet][2];
    
    // Compute scale factor (area of face scaled by area of reference triangle)
    const double a0 = (x[v0][1]*x[v1][2]
                     + x[v0][2]*x[v2][1]
                     + x[v1][1]*x[v2][2])
                    - (x[v2][1]*x[v1][2]
                     + x[v2][2]*x[v0][1]
                     + x[v1][1]*x[v0][2]);
    
    const double a1 = (x[v0][2]*x[v1][0]
                     + x[v0][0]*x[v2][2]
                     + x[v1][2]*x[v2][0])
                    - (x[v2][2]*x[v1][0]
                     + x[v2][0]*x[v0][2]
                    + x[v1][2]*x[v0][0]);
    
    const double a2 = (x[v0][0]*x[v1][1]
                     + x[v0][1]*x[v2][0]
                     + x[v1][0]*x[v2][1])
                    - (x[v2][0]*x[v1][1]
                     + x[v2][1]*x[v0][0]
                     + x[v1][0]*x[v0][1]);
    
    const double det = std::sqrt(a0*a0 + a1*a1 + a2*a2);
    
    // Compute geometry tensor
    const double G0_0 = det*w[2][0]*(1.0);
    const double G0_1 = det*w[2][1]*(1.0);
    const double G0_2 = det*w[2][2]*(1.0);
    const double G0_3 = det*w[2][3]*(1.0);
    const double G0_4 = det*w[2][4]*(1.0);
    const double G0_5 = det*w[2][5]*(1.0);
    const double G0_6 = det*w[2][6]*(1.0);
    const double G0_7 = det*w[2][7]*(1.0);
    const double G0_8 = det*w[2][8]*(1.0);
    const double G0_9 = det*w[2][9]*(1.0);
    const double G0_10 = det*w[2][10]*(1.0);
    const double G0_11 = det*w[2][11]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.000000000000000;
      A[1] = (-0.083333333333333)*G0_1 - 0.041666666666667*G0_2 - 0.041666666666667*G0_3;
      A[2] = (-0.041666666666667)*G0_1 - 0.083333333333333*G0_2 - 0.041666666666667*G0_3;
      A[3] = (-0.041666666666667)*G0_1 - 0.041666666666667*G0_2 - 0.083333333333333*G0_3;
      A[4] = 0.000000000000000;
      A[5] = (-0.083333333333333)*G0_5 - 0.041666666666667*G0_6 - 0.041666666666667*G0_7;
      A[6] = (-0.041666666666667)*G0_5 - 0.083333333333333*G0_6 - 0.041666666666667*G0_7;
      A[7] = (-0.041666666666667)*G0_5 - 0.041666666666667*G0_6 - 0.083333333333333*G0_7;
      A[8] = 0.000000000000000;
      A[9] = (-0.083333333333333)*G0_9 - 0.041666666666667*G0_10 - 0.041666666666667*G0_11;
      A[10] = (-0.041666666666667)*G0_9 - 0.083333333333333*G0_10 - 0.041666666666667*G0_11;
      A[11] = (-0.041666666666667)*G0_9 - 0.041666666666667*G0_10 - 0.083333333333333*G0_11;
        break;
      }
    case 1:
      {
        A[0] = (-0.083333333333333)*G0_0 - 0.041666666666667*G0_2 - 0.041666666666667*G0_3;
      A[1] = 0.000000000000000;
      A[2] = (-0.041666666666667)*G0_0 - 0.083333333333333*G0_2 - 0.041666666666667*G0_3;
      A[3] = (-0.041666666666667)*G0_0 - 0.041666666666667*G0_2 - 0.083333333333333*G0_3;
      A[4] = (-0.083333333333333)*G0_4 - 0.041666666666667*G0_6 - 0.041666666666667*G0_7;
      A[5] = 0.000000000000000;
      A[6] = (-0.041666666666667)*G0_4 - 0.083333333333333*G0_6 - 0.041666666666667*G0_7;
      A[7] = (-0.041666666666667)*G0_4 - 0.041666666666667*G0_6 - 0.083333333333333*G0_7;
      A[8] = (-0.083333333333333)*G0_8 - 0.041666666666667*G0_10 - 0.041666666666667*G0_11;
      A[9] = 0.000000000000000;
      A[10] = (-0.041666666666667)*G0_8 - 0.083333333333333*G0_10 - 0.041666666666667*G0_11;
      A[11] = (-0.041666666666667)*G0_8 - 0.041666666666667*G0_10 - 0.083333333333333*G0_11;
        break;
      }
    case 2:
      {
        A[0] = (-0.083333333333333)*G0_0 - 0.041666666666667*G0_1 - 0.041666666666667*G0_3;
      A[1] = (-0.041666666666667)*G0_0 - 0.083333333333333*G0_1 - 0.041666666666667*G0_3;
      A[2] = 0.000000000000000;
      A[3] = (-0.041666666666667)*G0_0 - 0.041666666666667*G0_1 - 0.083333333333333*G0_3;
      A[4] = (-0.083333333333333)*G0_4 - 0.041666666666667*G0_5 - 0.041666666666667*G0_7;
      A[5] = (-0.041666666666667)*G0_4 - 0.083333333333333*G0_5 - 0.041666666666667*G0_7;
      A[6] = 0.000000000000000;
      A[7] = (-0.041666666666667)*G0_4 - 0.041666666666667*G0_5 - 0.083333333333333*G0_7;
      A[8] = (-0.083333333333333)*G0_8 - 0.041666666666667*G0_9 - 0.041666666666667*G0_11;
      A[9] = (-0.041666666666667)*G0_8 - 0.083333333333333*G0_9 - 0.041666666666667*G0_11;
      A[10] = 0.000000000000000;
      A[11] = (-0.041666666666667)*G0_8 - 0.041666666666667*G0_9 - 0.083333333333333*G0_11;
        break;
      }
    case 3:
      {
        A[0] = (-0.083333333333333)*G0_0 - 0.041666666666667*G0_1 - 0.041666666666667*G0_2;
      A[1] = (-0.041666666666667)*G0_0 - 0.083333333333333*G0_1 - 0.041666666666667*G0_2;
      A[2] = (-0.041666666666667)*G0_0 - 0.041666666666667*G0_1 - 0.083333333333333*G0_2;
      A[3] = 0.000000000000000;
      A[4] = (-0.083333333333333)*G0_4 - 0.041666666666667*G0_5 - 0.041666666666667*G0_6;
      A[5] = (-0.041666666666667)*G0_4 - 0.083333333333333*G0_5 - 0.041666666666667*G0_6;
      A[6] = (-0.041666666666667)*G0_4 - 0.041666666666667*G0_5 - 0.083333333333333*G0_6;
      A[7] = 0.000000000000000;
      A[8] = (-0.083333333333333)*G0_8 - 0.041666666666667*G0_9 - 0.041666666666667*G0_10;
      A[9] = (-0.041666666666667)*G0_8 - 0.083333333333333*G0_9 - 0.041666666666667*G0_10;
      A[10] = (-0.041666666666667)*G0_8 - 0.041666666666667*G0_9 - 0.083333333333333*G0_10;
      A[11] = 0.000000000000000;
        break;
      }
    }
    
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class hyperelasticity_form_0: public ufc::form
{
public:

  /// Constructor
  hyperelasticity_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(IndexSum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(0),), {Index(0): 3})), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(1), Index(0)), {Index(0): 3, Index(1): 3})), MultiIndex((Index(2), Index(3)), {Index(2): 3, Index(3): 3})), MultiIndex((Index(3), Index(2)), {Index(2): 3, Index(3): 3})), MultiIndex((Index(4), Index(5)), {Index(4): 3, Index(5): 3})), Indexed(Sum(ComponentTensor(Product(Constant(Cell('tetrahedron', 1, Space(3)), 1), Indexed(IndexSum(ComponentTensor(Indexed(ComponentTensor(Indexed(IndexSum(Sum(ComponentTensor(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(10), Index(11), Index(12), Index(13)), {Index(11): 3, Index(13): 3, Index(10): 3, Index(12): 3})), MultiIndex((Index(12), Index(13)), {Index(13): 3, Index(12): 3})), MultiIndex((Index(14), Index(15)), {Index(14): 3, Index(15): 3})), Indexed(Variable(ComponentTensor(Division(Indexed(Sum(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Identity(3), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), Label(0)), MultiIndex((Index(11), Index(33)), {Index(11): 3, Index(33): 3}))), MultiIndex((Index(14), Index(15)), {Index(14): 3, Index(15): 3})), ComponentTensor(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(11), Index(33), Index(34), Index(35)), {Index(35): 3, Index(11): 3, Index(34): 3, Index(33): 3})), MultiIndex((Index(34), Index(35)), {Index(35): 3, Index(34): 3})), MultiIndex((Index(36), Index(37)), {Index(36): 3, Index(37): 3})), Indexed(Variable(ComponentTensor(Division(Indexed(Sum(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Identity(3), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), Label(0)), MultiIndex((Index(10), Index(11)), {Index(11): 3, Index(10): 3}))), MultiIndex((Index(36), Index(37)), {Index(36): 3, Index(37): 3}))), MultiIndex((Index(11),), {Index(11): 3})), MultiIndex((Index(38), Index(39)), {Index(39): 3, Index(38): 3})), MultiIndex((Index(10), Index(33), Index(38), Index(39)), {Index(33): 3, Index(39): 3, Index(10): 3, Index(38): 3})), MultiIndex((Index(40), Index(40), Index(41), Index(42)), {Index(40): 3, Index(41): 3, Index(42): 3})), MultiIndex((Index(41), Index(42)), {Index(41): 3, Index(42): 3})), MultiIndex((Index(40),), {Index(40): 3})), MultiIndex((Index(43), Index(44)), {Index(43): 3, Index(44): 3}))), MultiIndex((Index(43), Index(44)), {Index(43): 3, Index(44): 3})), ComponentTensor(Product(Division(Constant(Cell('tetrahedron', 1, Space(3)), 2), IntValue(2, (), (), {})), Indexed(ComponentTensor(Product(IndexSum(Indexed(Variable(ComponentTensor(Division(Indexed(Sum(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Identity(3), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), Label(0)), MultiIndex((Index(45), Index(45)), {Index(45): 3})), MultiIndex((Index(45),), {Index(45): 3})), Indexed(ComponentTensor(Product(IntValue(2, (), (), {}), Indexed(IndexSum(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(45), Index(45), Index(46), Index(47)), {Index(46): 3, Index(47): 3, Index(45): 3})), MultiIndex((Index(46), Index(47)), {Index(46): 3, Index(47): 3})), MultiIndex((Index(45),), {Index(45): 3})), MultiIndex((Index(48), Index(49)), {Index(48): 3, Index(49): 3}))), MultiIndex((Index(48), Index(49)), {Index(48): 3, Index(49): 3})), MultiIndex((Index(50), Index(51)), {Index(50): 3, Index(51): 3}))), MultiIndex((Index(50), Index(51)), {Index(50): 3, Index(51): 3})), MultiIndex((Index(52), Index(53)), {Index(53): 3, Index(52): 3}))), MultiIndex((Index(52), Index(53)), {Index(53): 3, Index(52): 3}))), MultiIndex((Index(5), Index(54)), {Index(5): 3, Index(54): 3}))), Product(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(0),), {Index(0): 3})), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(1), Index(0)), {Index(0): 3, Index(1): 3})), MultiIndex((Index(2), Index(3)), {Index(2): 3, Index(3): 3})), MultiIndex((Index(3), Index(2)), {Index(2): 3, Index(3): 3})), Identity(3)), MultiIndex((Index(4), Index(5)), {Index(4): 3, Index(5): 3})), Indexed(Sum(ComponentTensor(Product(Constant(Cell('tetrahedron', 1, Space(3)), 1), Indexed(IndexSum(ComponentTensor(Indexed(ComponentTensor(Indexed(IndexSum(Sum(ComponentTensor(Product(Indexed(ComponentTensor(Division(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3})), Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), MultiIndex((Index(11), Index(33)), {Index(11): 3, Index(33): 3})), Indexed(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(10), Index(11), Index(12), Index(13)), {Index(11): 3, Index(13): 3, Index(10): 3, Index(12): 3})), MultiIndex((Index(12), Index(13)), {Index(13): 3, Index(12): 3})), MultiIndex((Index(14), Index(15)), {Index(14): 3, Index(15): 3}))), MultiIndex((Index(14), Index(15)), {Index(14): 3, Index(15): 3})), ComponentTensor(Product(Indexed(ComponentTensor(Division(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3})), Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), MultiIndex((Index(10), Index(11)), {Index(11): 3, Index(10): 3})), Indexed(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(11), Index(33), Index(34), Index(35)), {Index(35): 3, Index(11): 3, Index(34): 3, Index(33): 3})), MultiIndex((Index(34), Index(35)), {Index(35): 3, Index(34): 3})), MultiIndex((Index(36), Index(37)), {Index(36): 3, Index(37): 3}))), MultiIndex((Index(36), Index(37)), {Index(36): 3, Index(37): 3}))), MultiIndex((Index(11),), {Index(11): 3})), MultiIndex((Index(38), Index(39)), {Index(39): 3, Index(38): 3})), MultiIndex((Index(10), Index(33), Index(38), Index(39)), {Index(33): 3, Index(39): 3, Index(10): 3, Index(38): 3})), MultiIndex((Index(40), Index(40), Index(41), Index(42)), {Index(40): 3, Index(41): 3, Index(42): 3})), MultiIndex((Index(41), Index(42)), {Index(41): 3, Index(42): 3})), MultiIndex((Index(40),), {Index(40): 3})), MultiIndex((Index(43), Index(44)), {Index(43): 3, Index(44): 3}))), MultiIndex((Index(43), Index(44)), {Index(43): 3, Index(44): 3})), ComponentTensor(Product(Division(Constant(Cell('tetrahedron', 1, Space(3)), 2), IntValue(2, (), (), {})), Indexed(ComponentTensor(Product(IndexSum(Indexed(ComponentTensor(Division(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3})), Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), MultiIndex((Index(45), Index(45)), {Index(45): 3})), MultiIndex((Index(45),), {Index(45): 3})), Indexed(ComponentTensor(Product(IntValue(2, (), (), {}), Indexed(IndexSum(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(45), Index(45), Index(46), Index(47)), {Index(46): 3, Index(47): 3, Index(45): 3})), MultiIndex((Index(46), Index(47)), {Index(46): 3, Index(47): 3})), MultiIndex((Index(45),), {Index(45): 3})), MultiIndex((Index(48), Index(49)), {Index(48): 3, Index(49): 3}))), MultiIndex((Index(48), Index(49)), {Index(48): 3, Index(49): 3})), MultiIndex((Index(50), Index(51)), {Index(50): 3, Index(51): 3}))), MultiIndex((Index(50), Index(51)), {Index(50): 3, Index(51): 3})), MultiIndex((Index(52), Index(53)), {Index(53): 3, Index(52): 3}))), MultiIndex((Index(52), Index(53)), {Index(53): 3, Index(52): 3}))), MultiIndex((Index(5), Index(54)), {Index(5): 3, Index(54): 3})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((Index(4), Index(54)), {Index(4): 3, Index(54): 3})), MultiIndex((Index(55), Index(56)), {Index(55): 3, Index(56): 3})), Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(57),), {Index(57): 3})), MultiIndex((Index(58),), {Index(58): 3})), MultiIndex((Index(58), Index(57)), {Index(58): 3, Index(57): 3})), MultiIndex((Index(59), Index(60)), {Index(60): 3, Index(59): 3})), MultiIndex((Index(60), Index(59)), {Index(60): 3, Index(59): 3})), MultiIndex((Index(55), Index(56)), {Index(55): 3, Index(56): 3}))), MultiIndex((Index(55),), {Index(55): 3})), MultiIndex((Index(56),), {Index(56): 3})), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 3;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 0;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 1:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 2:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 3:
      {
        return new hyperelasticity_finite_element_0();
        break;
      }
    case 4:
      {
        return new hyperelasticity_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 1:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 2:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 3:
      {
        return new hyperelasticity_dof_map_0();
        break;
      }
    case 4:
      {
        return new hyperelasticity_dof_map_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_cell_integral_0_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};
/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class hyperelasticity_form_1: public ufc::form
{
public:

  /// Constructor
  hyperelasticity_form_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~hyperelasticity_form_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(0),), {Index(0): 3})), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(1), Index(0)), {Index(0): 3, Index(1): 3})), MultiIndex((Index(2), Index(3)), {Index(2): 3, Index(3): 3})), MultiIndex((Index(3), Index(2)), {Index(2): 3, Index(3): 3})), Identity(3)), MultiIndex((Index(4), Index(5)), {Index(4): 3, Index(5): 3})), Indexed(Sum(ComponentTensor(Product(Constant(Cell('tetrahedron', 1, Space(3)), 3), Indexed(IndexSum(ComponentTensor(Indexed(ComponentTensor(Indexed(IndexSum(Sum(ComponentTensor(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(10), Index(11), Index(12), Index(13)), {Index(11): 3, Index(13): 3, Index(10): 3, Index(12): 3})), MultiIndex((Index(12), Index(13)), {Index(13): 3, Index(12): 3})), MultiIndex((Index(14), Index(15)), {Index(14): 3, Index(15): 3})), Indexed(Variable(ComponentTensor(Division(Indexed(Sum(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Identity(3), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), Label(0)), MultiIndex((Index(11), Index(33)), {Index(11): 3, Index(33): 3}))), MultiIndex((Index(14), Index(15)), {Index(14): 3, Index(15): 3})), ComponentTensor(Product(Indexed(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(11), Index(33), Index(34), Index(35)), {Index(35): 3, Index(11): 3, Index(34): 3, Index(33): 3})), MultiIndex((Index(34), Index(35)), {Index(35): 3, Index(34): 3})), MultiIndex((Index(36), Index(37)), {Index(36): 3, Index(37): 3})), Indexed(Variable(ComponentTensor(Division(Indexed(Sum(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Identity(3), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), Label(0)), MultiIndex((Index(10), Index(11)), {Index(11): 3, Index(10): 3}))), MultiIndex((Index(36), Index(37)), {Index(36): 3, Index(37): 3}))), MultiIndex((Index(11),), {Index(11): 3})), MultiIndex((Index(38), Index(39)), {Index(39): 3, Index(38): 3})), MultiIndex((Index(10), Index(33), Index(38), Index(39)), {Index(33): 3, Index(39): 3, Index(10): 3, Index(38): 3})), MultiIndex((Index(40), Index(40), Index(41), Index(42)), {Index(40): 3, Index(41): 3, Index(42): 3})), MultiIndex((Index(41), Index(42)), {Index(41): 3, Index(42): 3})), MultiIndex((Index(40),), {Index(40): 3})), MultiIndex((Index(43), Index(44)), {Index(43): 3, Index(44): 3}))), MultiIndex((Index(43), Index(44)), {Index(43): 3, Index(44): 3})), ComponentTensor(Product(Division(Constant(Cell('tetrahedron', 1, Space(3)), 4), IntValue(2, (), (), {})), Indexed(ComponentTensor(Product(IndexSum(Indexed(Variable(ComponentTensor(Division(Indexed(Sum(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(16),), {Index(16): 3})), MultiIndex((Index(17),), {Index(17): 3})), MultiIndex((Index(17), Index(16)), {Index(17): 3, Index(16): 3})), MultiIndex((Index(18), Index(19)), {Index(19): 3, Index(18): 3})), MultiIndex((Index(19), Index(18)), {Index(19): 3, Index(18): 3})), Identity(3)), MultiIndex((Index(20), Index(21)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(21), Index(20)), {Index(21): 3, Index(20): 3})), MultiIndex((Index(22), Index(23)), {Index(22): 3, Index(23): 3})), Indexed(Sum(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(24),), {Index(24): 3})), MultiIndex((Index(25),), {Index(25): 3})), MultiIndex((Index(25), Index(24)), {Index(24): 3, Index(25): 3})), MultiIndex((Index(26), Index(27)), {Index(26): 3, Index(27): 3})), MultiIndex((Index(27), Index(26)), {Index(26): 3, Index(27): 3})), Identity(3)), MultiIndex((Index(23), Index(28)), {Index(23): 3, Index(28): 3}))), MultiIndex((Index(23),), {Index(23): 3})), MultiIndex((Index(22), Index(28)), {Index(22): 3, Index(28): 3})), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Identity(3), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(29), Index(30)), {Index(29): 3, Index(30): 3}))), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), IntValue(2, (), (), {})), MultiIndex((Index(31), Index(32)), {Index(31): 3, Index(32): 3})), Label(0)), MultiIndex((Index(45), Index(45)), {Index(45): 3})), MultiIndex((Index(45),), {Index(45): 3})), Indexed(ComponentTensor(Product(IntValue(2, (), (), {}), Indexed(IndexSum(ComponentTensor(Indexed(ComponentTensor(Product(Indexed(Identity(3), MultiIndex((Index(6), Index(7)), {Index(7): 3, Index(6): 3})), Indexed(Identity(3), MultiIndex((Index(8), Index(9)), {Index(8): 3, Index(9): 3}))), MultiIndex((Index(6), Index(8), Index(7), Index(9)), {Index(7): 3, Index(8): 3, Index(9): 3, Index(6): 3})), MultiIndex((Index(45), Index(45), Index(46), Index(47)), {Index(46): 3, Index(47): 3, Index(45): 3})), MultiIndex((Index(46), Index(47)), {Index(46): 3, Index(47): 3})), MultiIndex((Index(45),), {Index(45): 3})), MultiIndex((Index(48), Index(49)), {Index(48): 3, Index(49): 3}))), MultiIndex((Index(48), Index(49)), {Index(48): 3, Index(49): 3})), MultiIndex((Index(50), Index(51)), {Index(50): 3, Index(51): 3}))), MultiIndex((Index(50), Index(51)), {Index(50): 3, Index(51): 3})), MultiIndex((Index(52), Index(53)), {Index(53): 3, Index(52): 3}))), MultiIndex((Index(52), Index(53)), {Index(53): 3, Index(52): 3}))), MultiIndex((Index(5), Index(54)), {Index(5): 3, Index(54): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((Index(4), Index(54)), {Index(4): 3, Index(54): 3})), MultiIndex((Index(55), Index(56)), {Index(55): 3, Index(56): 3})), Indexed(ComponentTensor(Indexed(ComponentTensor(Indexed(SpatialDerivative(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(57),), {Index(57): 3})), MultiIndex((Index(58),), {Index(58): 3})), MultiIndex((Index(58), Index(57)), {Index(58): 3, Index(57): 3})), MultiIndex((Index(59), Index(60)), {Index(60): 3, Index(59): 3})), MultiIndex((Index(60), Index(59)), {Index(60): 3, Index(59): 3})), MultiIndex((Index(55), Index(56)), {Index(55): 3, Index(56): 3}))), MultiIndex((Index(55),), {Index(55): 3})), MultiIndex((Index(56),), {Index(56): 3})), Product(IntValue(-1, (), (), {}), IndexSum(Product(Indexed(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(61),), {Index(61): 3})), Indexed(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 1), MultiIndex((Index(61),), {Index(61): 3}))), MultiIndex((Index(61),), {Index(61): 3})))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), IndexSum(Product(Indexed(Argument(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 0), MultiIndex((Index(62),), {Index(62): 3})), Indexed(Coefficient(VectorElement('Lagrange', Cell('tetrahedron', 1, Space(3)), 1, 3), 2), MultiIndex((Index(62),), {Index(62): 3}))), MultiIndex((Index(62),), {Index(62): 3}))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 5;
  }

  /// Return the number of cell integrals
  virtual unsigned int num_cell_integrals() const
  {
    return 1;
  }

  /// Return the number of exterior facet integrals
  virtual unsigned int num_exterior_facet_integrals() const
  {
    return 1;
  }

  /// Return the number of interior facet integrals
  virtual unsigned int num_interior_facet_integrals() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 1:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 2:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 3:
      {
        return new hyperelasticity_finite_element_2();
        break;
      }
    case 4:
      {
        return new hyperelasticity_finite_element_0();
        break;
      }
    case 5:
      {
        return new hyperelasticity_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dof map for argument function i
  virtual ufc::dof_map* create_dof_map(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 1:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 2:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 3:
      {
        return new hyperelasticity_dof_map_2();
        break;
      }
    case 4:
      {
        return new hyperelasticity_dof_map_0();
        break;
      }
    case 5:
      {
        return new hyperelasticity_dof_map_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_cell_integral_1_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new hyperelasticity_exterior_facet_integral_1_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>

namespace HyperElasticity
{

class CoefficientSpace_B: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_B(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_B(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_B(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_B(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_B()
  {
  }

};

class CoefficientSpace_T: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_T(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_T(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_T(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_T(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_T()
  {
  }

};

class CoefficientSpace_lmbda: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_lmbda(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_lmbda(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_lmbda(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_lmbda(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_lmbda()
  {
  }

};

class CoefficientSpace_mu: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_mu(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_mu(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_mu(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_mu(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_0()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_mu()
  {
  }

};

class CoefficientSpace_u: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_u(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_u(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_u(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_u(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_u()
  {
  }

};

class Form_0_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_0()
  {
  }

};

class Form_0_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_u Form_0_FunctionSpace_2;

typedef CoefficientSpace_mu Form_0_FunctionSpace_3;

typedef CoefficientSpace_lmbda Form_0_FunctionSpace_4;

class Form_0: public dolfin::Form
{
public:

  // Constructor
  Form_0(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1):
    dolfin::Form(2, 3), u(*this, 0), mu(*this, 1), lmbda(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1, const dolfin::GenericFunction& u, const dolfin::GenericFunction& mu, const dolfin::GenericFunction& lmbda):
    dolfin::Form(2, 3), u(*this, 0), mu(*this, 1), lmbda(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->u = u;
    this->mu = mu;
    this->lmbda = lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V0, const dolfin::FunctionSpace& V1, boost::shared_ptr<const dolfin::GenericFunction> u, boost::shared_ptr<const dolfin::GenericFunction> mu, boost::shared_ptr<const dolfin::GenericFunction> lmbda):
    dolfin::Form(2, 3), u(*this, 0), mu(*this, 1), lmbda(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->u = *u;
    this->mu = *mu;
    this->lmbda = *lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1):
    dolfin::Form(2, 3), u(*this, 0), mu(*this, 1), lmbda(*this, 2)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1, const dolfin::GenericFunction& u, const dolfin::GenericFunction& mu, const dolfin::GenericFunction& lmbda):
    dolfin::Form(2, 3), u(*this, 0), mu(*this, 1), lmbda(*this, 2)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->u = u;
    this->mu = mu;
    this->lmbda = lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::GenericFunction> u, boost::shared_ptr<const dolfin::GenericFunction> mu, boost::shared_ptr<const dolfin::GenericFunction> lmbda):
    dolfin::Form(2, 3), u(*this, 0), mu(*this, 1), lmbda(*this, 2)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->u = *u;
    this->mu = *mu;
    this->lmbda = *lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_0());
  }

  // Destructor
  ~Form_0()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "u")
      return 0;
    else if (name == "mu")
      return 1;
    else if (name == "lmbda")
      return 2;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "u";
    case 1:
      return "mu";
    case 2:
      return "lmbda";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_0_FunctionSpace_0 TestSpace;
  typedef Form_0_FunctionSpace_1 TrialSpace;
  typedef Form_0_FunctionSpace_2 CoefficientSpace_u;
  typedef Form_0_FunctionSpace_3 CoefficientSpace_mu;
  typedef Form_0_FunctionSpace_4 CoefficientSpace_lmbda;

  // Coefficients
  dolfin::CoefficientAssigner u;
  dolfin::CoefficientAssigner mu;
  dolfin::CoefficientAssigner lmbda;
};

class Form_1_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_1_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new hyperelasticity_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dof_map>(new hyperelasticity_dof_map_2()), *mesh)))
  {
      // Do nothing
  }

  ~Form_1_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_u Form_1_FunctionSpace_1;

typedef CoefficientSpace_B Form_1_FunctionSpace_2;

typedef CoefficientSpace_T Form_1_FunctionSpace_3;

typedef CoefficientSpace_mu Form_1_FunctionSpace_4;

typedef CoefficientSpace_lmbda Form_1_FunctionSpace_5;

class Form_1: public dolfin::Form
{
public:

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 5), u(*this, 0), B(*this, 1), T(*this, 2), mu(*this, 3), lmbda(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_1());
  }

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& u, const dolfin::GenericFunction& B, const dolfin::GenericFunction& T, const dolfin::GenericFunction& mu, const dolfin::GenericFunction& lmbda):
    dolfin::Form(1, 5), u(*this, 0), B(*this, 1), T(*this, 2), mu(*this, 3), lmbda(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->u = u;
    this->B = B;
    this->T = T;
    this->mu = mu;
    this->lmbda = lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_1());
  }

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> u, boost::shared_ptr<const dolfin::GenericFunction> B, boost::shared_ptr<const dolfin::GenericFunction> T, boost::shared_ptr<const dolfin::GenericFunction> mu, boost::shared_ptr<const dolfin::GenericFunction> lmbda):
    dolfin::Form(1, 5), u(*this, 0), B(*this, 1), T(*this, 2), mu(*this, 3), lmbda(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->u = *u;
    this->B = *B;
    this->T = *T;
    this->mu = *mu;
    this->lmbda = *lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_1());
  }

  // Constructor
  Form_1(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 5), u(*this, 0), B(*this, 1), T(*this, 2), mu(*this, 3), lmbda(*this, 4)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_1());
  }

  // Constructor
  Form_1(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& u, const dolfin::GenericFunction& B, const dolfin::GenericFunction& T, const dolfin::GenericFunction& mu, const dolfin::GenericFunction& lmbda):
    dolfin::Form(1, 5), u(*this, 0), B(*this, 1), T(*this, 2), mu(*this, 3), lmbda(*this, 4)
  {
    _function_spaces[0] = V0;

    this->u = u;
    this->B = B;
    this->T = T;
    this->mu = mu;
    this->lmbda = lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_1());
  }

  // Constructor
  Form_1(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> u, boost::shared_ptr<const dolfin::GenericFunction> B, boost::shared_ptr<const dolfin::GenericFunction> T, boost::shared_ptr<const dolfin::GenericFunction> mu, boost::shared_ptr<const dolfin::GenericFunction> lmbda):
    dolfin::Form(1, 5), u(*this, 0), B(*this, 1), T(*this, 2), mu(*this, 3), lmbda(*this, 4)
  {
    _function_spaces[0] = V0;

    this->u = *u;
    this->B = *B;
    this->T = *T;
    this->mu = *mu;
    this->lmbda = *lmbda;

    _ufc_form = boost::shared_ptr<const ufc::form>(new hyperelasticity_form_1());
  }

  // Destructor
  ~Form_1()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "u")
      return 0;
    else if (name == "B")
      return 1;
    else if (name == "T")
      return 2;
    else if (name == "mu")
      return 3;
    else if (name == "lmbda")
      return 4;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "u";
    case 1:
      return "B";
    case 2:
      return "T";
    case 3:
      return "mu";
    case 4:
      return "lmbda";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_1_FunctionSpace_0 TestSpace;
  typedef Form_1_FunctionSpace_1 CoefficientSpace_u;
  typedef Form_1_FunctionSpace_2 CoefficientSpace_B;
  typedef Form_1_FunctionSpace_3 CoefficientSpace_T;
  typedef Form_1_FunctionSpace_4 CoefficientSpace_mu;
  typedef Form_1_FunctionSpace_5 CoefficientSpace_lmbda;

  // Coefficients
  dolfin::CoefficientAssigner u;
  dolfin::CoefficientAssigner B;
  dolfin::CoefficientAssigner T;
  dolfin::CoefficientAssigner mu;
  dolfin::CoefficientAssigner lmbda;
};

// Class typedefs
typedef Form_0 BilinearForm;
typedef Form_1 LinearForm;
typedef Form_0::TestSpace FunctionSpace;

}

#endif