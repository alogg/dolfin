// Automatically generated by FFC, the FEniCS Form Compiler, version 0.3.3.
// For further information, go to http://www/fenics.org/ffc/.
// Licensed under the GNU GPL Version 2.

#ifndef __ELASTICITYSTRAIN_H
#define __ELASTICITYSTRAIN_H

#include <dolfin/Mesh.h>
#include <dolfin/Cell.h>
#include <dolfin/Point.h>
#include <dolfin/AffineMap.h>
#include <dolfin/FiniteElement.h>
#include <dolfin/FiniteElementSpec.h>
#include <dolfin/LinearForm.h>
#include <dolfin/BilinearForm.h>

namespace dolfin { namespace ElasticityStrain {

/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class BilinearForm : public dolfin::BilinearForm
{
public:
  
  class TestElement : public dolfin::FiniteElement
  {
  public:
  
    TestElement() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      tensordims = new unsigned int [1];
      tensordims[0] = 6;
  
      subelements = new FiniteElement* [2];
      subelements[0] = new SubElement_0();
      subelements[1] = new SubElement_1();
    }
  
    ~TestElement()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 24;
    }
  
    inline unsigned int shapedim() const
    {
      return 3;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_assert(i < 1);
      return tensordims[i];
    }
  
    inline unsigned int elementdim() const
    {
      return 2;
    }
  
    inline unsigned int rank() const
    {
      return 1;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      nodes[3] = cell.vertexID(3);
      int offset = mesh.numVertices();
      nodes[4] = offset + cell.vertexID(0);
      nodes[5] = offset + cell.vertexID(1);
      nodes[6] = offset + cell.vertexID(2);
      nodes[7] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[8] = offset + cell.vertexID(0);
      nodes[9] = offset + cell.vertexID(1);
      nodes[10] = offset + cell.vertexID(2);
      nodes[11] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[12] = offset + cell.vertexID(0);
      nodes[13] = offset + cell.vertexID(1);
      nodes[14] = offset + cell.vertexID(2);
      nodes[15] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[16] = offset + cell.vertexID(0);
      nodes[17] = offset + cell.vertexID(1);
      nodes[18] = offset + cell.vertexID(2);
      nodes[19] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[20] = offset + cell.vertexID(0);
      nodes[21] = offset + cell.vertexID(1);
      nodes[22] = offset + cell.vertexID(2);
      nodes[23] = offset + cell.vertexID(3);
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 1;
      components[5] = 1;
      components[6] = 1;
      components[7] = 1;
      components[8] = 2;
      components[9] = 2;
      components[10] = 2;
      components[11] = 2;
      points[12] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[13] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[14] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[15] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[16] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[17] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[18] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[19] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[20] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[21] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[22] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[23] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[12] = 3;
      components[13] = 3;
      components[14] = 3;
      components[15] = 3;
      components[16] = 4;
      components[17] = 4;
      components[18] = 4;
      components[19] = 4;
      components[20] = 5;
      components[21] = 5;
      components[22] = 5;
      components[23] = 5;
    }
  
    void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      vertex_nodes[0] = vertex;
      int offset = mesh.numVertices();
      vertex_nodes[1] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[2] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[3] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[4] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[5] = offset + vertex;
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *subelements[i];
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *subelements[i];
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("mixed");
      return s;
    }
    
  private:
    
    class SubElement_0 : public dolfin::FiniteElement
    {
    public:
    
      SubElement_0() : dolfin::FiniteElement(), tensordims(0), subelements(0)
      {
        tensordims = new unsigned int [1];
        tensordims[0] = 3;
    
        // Element is simple, don't need to initialize subelements
      }
    
      ~SubElement_0()
      {
        if ( tensordims ) delete [] tensordims;
        if ( subelements )
        {
          for (unsigned int i = 0; i < elementdim(); i++)
            delete subelements[i];
          delete [] subelements;
        }
      }
    
      inline unsigned int spacedim() const
      {
        return 12;
      }
    
      inline unsigned int shapedim() const
      {
        return 3;
      }
    
      inline unsigned int tensordim(unsigned int i) const
      {
        dolfin_assert(i < 1);
        return tensordims[i];
      }
    
      inline unsigned int elementdim() const
      {
        return 1;
      }
    
      inline unsigned int rank() const
      {
        return 1;
      }
    
      void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
      {
        nodes[0] = cell.vertexID(0);
        nodes[1] = cell.vertexID(1);
        nodes[2] = cell.vertexID(2);
        nodes[3] = cell.vertexID(3);
        int offset = mesh.numVertices();
        nodes[4] = offset + cell.vertexID(0);
        nodes[5] = offset + cell.vertexID(1);
        nodes[6] = offset + cell.vertexID(2);
        nodes[7] = offset + cell.vertexID(3);
        offset = offset + mesh.numVertices();
        nodes[8] = offset + cell.vertexID(0);
        nodes[9] = offset + cell.vertexID(1);
        nodes[10] = offset + cell.vertexID(2);
        nodes[11] = offset + cell.vertexID(3);
      }
    
      void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
      {
        points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        components[0] = 0;
        components[1] = 0;
        components[2] = 0;
        components[3] = 0;
        components[4] = 1;
        components[5] = 1;
        components[6] = 1;
        components[7] = 1;
        components[8] = 2;
        components[9] = 2;
        components[10] = 2;
        components[11] = 2;
      }
    
      void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
      {
        // FIXME: Temporary fix for Lagrange elements
        vertex_nodes[0] = vertex;
        int offset = mesh.numVertices();
        vertex_nodes[1] = offset + vertex;
        offset = offset + mesh.numVertices();
        vertex_nodes[2] = offset + vertex;
      }
    
      const FiniteElement& operator[] (unsigned int i) const
      {
        return *this;
      }
    
      FiniteElement& operator[] (unsigned int i)
      {
        return *this;
      }
    
      FiniteElementSpec spec() const
      {
        FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
        return s;
      }
      
    private:
    
      unsigned int* tensordims;
      FiniteElement** subelements;
    
    };
      
    class SubElement_1 : public dolfin::FiniteElement
    {
    public:
    
      SubElement_1() : dolfin::FiniteElement(), tensordims(0), subelements(0)
      {
        tensordims = new unsigned int [1];
        tensordims[0] = 3;
    
        // Element is simple, don't need to initialize subelements
      }
    
      ~SubElement_1()
      {
        if ( tensordims ) delete [] tensordims;
        if ( subelements )
        {
          for (unsigned int i = 0; i < elementdim(); i++)
            delete subelements[i];
          delete [] subelements;
        }
      }
    
      inline unsigned int spacedim() const
      {
        return 12;
      }
    
      inline unsigned int shapedim() const
      {
        return 3;
      }
    
      inline unsigned int tensordim(unsigned int i) const
      {
        dolfin_assert(i < 1);
        return tensordims[i];
      }
    
      inline unsigned int elementdim() const
      {
        return 1;
      }
    
      inline unsigned int rank() const
      {
        return 1;
      }
    
      void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
      {
        nodes[0] = cell.vertexID(0);
        nodes[1] = cell.vertexID(1);
        nodes[2] = cell.vertexID(2);
        nodes[3] = cell.vertexID(3);
        int offset = mesh.numVertices();
        nodes[4] = offset + cell.vertexID(0);
        nodes[5] = offset + cell.vertexID(1);
        nodes[6] = offset + cell.vertexID(2);
        nodes[7] = offset + cell.vertexID(3);
        offset = offset + mesh.numVertices();
        nodes[8] = offset + cell.vertexID(0);
        nodes[9] = offset + cell.vertexID(1);
        nodes[10] = offset + cell.vertexID(2);
        nodes[11] = offset + cell.vertexID(3);
      }
    
      void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
      {
        points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        components[0] = 0;
        components[1] = 0;
        components[2] = 0;
        components[3] = 0;
        components[4] = 1;
        components[5] = 1;
        components[6] = 1;
        components[7] = 1;
        components[8] = 2;
        components[9] = 2;
        components[10] = 2;
        components[11] = 2;
      }
    
      void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
      {
        // FIXME: Temporary fix for Lagrange elements
        vertex_nodes[0] = vertex;
        int offset = mesh.numVertices();
        vertex_nodes[1] = offset + vertex;
        offset = offset + mesh.numVertices();
        vertex_nodes[2] = offset + vertex;
      }
    
      const FiniteElement& operator[] (unsigned int i) const
      {
        return *this;
      }
    
      FiniteElement& operator[] (unsigned int i)
      {
        return *this;
      }
    
      FiniteElementSpec spec() const
      {
        FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
        return s;
      }
      
    private:
    
      unsigned int* tensordims;
      FiniteElement** subelements;
    
    };
    
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
    
  class TrialElement : public dolfin::FiniteElement
  {
  public:
  
    TrialElement() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      tensordims = new unsigned int [1];
      tensordims[0] = 6;
  
      subelements = new FiniteElement* [2];
      subelements[0] = new SubElement_0();
      subelements[1] = new SubElement_1();
    }
  
    ~TrialElement()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 24;
    }
  
    inline unsigned int shapedim() const
    {
      return 3;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_assert(i < 1);
      return tensordims[i];
    }
  
    inline unsigned int elementdim() const
    {
      return 2;
    }
  
    inline unsigned int rank() const
    {
      return 1;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      nodes[3] = cell.vertexID(3);
      int offset = mesh.numVertices();
      nodes[4] = offset + cell.vertexID(0);
      nodes[5] = offset + cell.vertexID(1);
      nodes[6] = offset + cell.vertexID(2);
      nodes[7] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[8] = offset + cell.vertexID(0);
      nodes[9] = offset + cell.vertexID(1);
      nodes[10] = offset + cell.vertexID(2);
      nodes[11] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[12] = offset + cell.vertexID(0);
      nodes[13] = offset + cell.vertexID(1);
      nodes[14] = offset + cell.vertexID(2);
      nodes[15] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[16] = offset + cell.vertexID(0);
      nodes[17] = offset + cell.vertexID(1);
      nodes[18] = offset + cell.vertexID(2);
      nodes[19] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[20] = offset + cell.vertexID(0);
      nodes[21] = offset + cell.vertexID(1);
      nodes[22] = offset + cell.vertexID(2);
      nodes[23] = offset + cell.vertexID(3);
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 1;
      components[5] = 1;
      components[6] = 1;
      components[7] = 1;
      components[8] = 2;
      components[9] = 2;
      components[10] = 2;
      components[11] = 2;
      points[12] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[13] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[14] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[15] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[16] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[17] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[18] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[19] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[20] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[21] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[22] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[23] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[12] = 3;
      components[13] = 3;
      components[14] = 3;
      components[15] = 3;
      components[16] = 4;
      components[17] = 4;
      components[18] = 4;
      components[19] = 4;
      components[20] = 5;
      components[21] = 5;
      components[22] = 5;
      components[23] = 5;
    }
  
    void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      vertex_nodes[0] = vertex;
      int offset = mesh.numVertices();
      vertex_nodes[1] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[2] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[3] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[4] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[5] = offset + vertex;
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *subelements[i];
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *subelements[i];
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("mixed");
      return s;
    }
    
  private:
    
    class SubElement_0 : public dolfin::FiniteElement
    {
    public:
    
      SubElement_0() : dolfin::FiniteElement(), tensordims(0), subelements(0)
      {
        tensordims = new unsigned int [1];
        tensordims[0] = 3;
    
        // Element is simple, don't need to initialize subelements
      }
    
      ~SubElement_0()
      {
        if ( tensordims ) delete [] tensordims;
        if ( subelements )
        {
          for (unsigned int i = 0; i < elementdim(); i++)
            delete subelements[i];
          delete [] subelements;
        }
      }
    
      inline unsigned int spacedim() const
      {
        return 12;
      }
    
      inline unsigned int shapedim() const
      {
        return 3;
      }
    
      inline unsigned int tensordim(unsigned int i) const
      {
        dolfin_assert(i < 1);
        return tensordims[i];
      }
    
      inline unsigned int elementdim() const
      {
        return 1;
      }
    
      inline unsigned int rank() const
      {
        return 1;
      }
    
      void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
      {
        nodes[0] = cell.vertexID(0);
        nodes[1] = cell.vertexID(1);
        nodes[2] = cell.vertexID(2);
        nodes[3] = cell.vertexID(3);
        int offset = mesh.numVertices();
        nodes[4] = offset + cell.vertexID(0);
        nodes[5] = offset + cell.vertexID(1);
        nodes[6] = offset + cell.vertexID(2);
        nodes[7] = offset + cell.vertexID(3);
        offset = offset + mesh.numVertices();
        nodes[8] = offset + cell.vertexID(0);
        nodes[9] = offset + cell.vertexID(1);
        nodes[10] = offset + cell.vertexID(2);
        nodes[11] = offset + cell.vertexID(3);
      }
    
      void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
      {
        points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        components[0] = 0;
        components[1] = 0;
        components[2] = 0;
        components[3] = 0;
        components[4] = 1;
        components[5] = 1;
        components[6] = 1;
        components[7] = 1;
        components[8] = 2;
        components[9] = 2;
        components[10] = 2;
        components[11] = 2;
      }
    
      void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
      {
        // FIXME: Temporary fix for Lagrange elements
        vertex_nodes[0] = vertex;
        int offset = mesh.numVertices();
        vertex_nodes[1] = offset + vertex;
        offset = offset + mesh.numVertices();
        vertex_nodes[2] = offset + vertex;
      }
    
      const FiniteElement& operator[] (unsigned int i) const
      {
        return *this;
      }
    
      FiniteElement& operator[] (unsigned int i)
      {
        return *this;
      }
    
      FiniteElementSpec spec() const
      {
        FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
        return s;
      }
      
    private:
    
      unsigned int* tensordims;
      FiniteElement** subelements;
    
    };
      
    class SubElement_1 : public dolfin::FiniteElement
    {
    public:
    
      SubElement_1() : dolfin::FiniteElement(), tensordims(0), subelements(0)
      {
        tensordims = new unsigned int [1];
        tensordims[0] = 3;
    
        // Element is simple, don't need to initialize subelements
      }
    
      ~SubElement_1()
      {
        if ( tensordims ) delete [] tensordims;
        if ( subelements )
        {
          for (unsigned int i = 0; i < elementdim(); i++)
            delete subelements[i];
          delete [] subelements;
        }
      }
    
      inline unsigned int spacedim() const
      {
        return 12;
      }
    
      inline unsigned int shapedim() const
      {
        return 3;
      }
    
      inline unsigned int tensordim(unsigned int i) const
      {
        dolfin_assert(i < 1);
        return tensordims[i];
      }
    
      inline unsigned int elementdim() const
      {
        return 1;
      }
    
      inline unsigned int rank() const
      {
        return 1;
      }
    
      void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
      {
        nodes[0] = cell.vertexID(0);
        nodes[1] = cell.vertexID(1);
        nodes[2] = cell.vertexID(2);
        nodes[3] = cell.vertexID(3);
        int offset = mesh.numVertices();
        nodes[4] = offset + cell.vertexID(0);
        nodes[5] = offset + cell.vertexID(1);
        nodes[6] = offset + cell.vertexID(2);
        nodes[7] = offset + cell.vertexID(3);
        offset = offset + mesh.numVertices();
        nodes[8] = offset + cell.vertexID(0);
        nodes[9] = offset + cell.vertexID(1);
        nodes[10] = offset + cell.vertexID(2);
        nodes[11] = offset + cell.vertexID(3);
      }
    
      void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
      {
        points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        components[0] = 0;
        components[1] = 0;
        components[2] = 0;
        components[3] = 0;
        components[4] = 1;
        components[5] = 1;
        components[6] = 1;
        components[7] = 1;
        components[8] = 2;
        components[9] = 2;
        components[10] = 2;
        components[11] = 2;
      }
    
      void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
      {
        // FIXME: Temporary fix for Lagrange elements
        vertex_nodes[0] = vertex;
        int offset = mesh.numVertices();
        vertex_nodes[1] = offset + vertex;
        offset = offset + mesh.numVertices();
        vertex_nodes[2] = offset + vertex;
      }
    
      const FiniteElement& operator[] (unsigned int i) const
      {
        return *this;
      }
    
      FiniteElement& operator[] (unsigned int i)
      {
        return *this;
      }
    
      FiniteElementSpec spec() const
      {
        FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
        return s;
      }
      
    private:
    
      unsigned int* tensordims;
      FiniteElement** subelements;
    
    };
    
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
  
  BilinearForm() : dolfin::BilinearForm(0)
  {
    // Create finite element for test space
    _test = new TestElement();

    // Create finite element for trial space
    _trial = new TrialElement();
  }

  void eval(real block[], const AffineMap& map) const
  {
    // Compute geometry tensors
    const real G0_ = map.det;
    const real G1_ = map.det;
    const real G2_ = map.det;
    const real G3_ = map.det;
    const real G4_ = map.det;
    const real G5_ = map.det;

    // Compute element tensor
    block[0] = 1.666666666666662e-02*G0_;
    block[1] = 8.333333333333307e-03*G0_;
    block[2] = 8.333333333333309e-03*G0_;
    block[3] = 8.333333333333311e-03*G0_;
    block[4] = 0.000000000000000e+00;
    block[5] = 0.000000000000000e+00;
    block[6] = 0.000000000000000e+00;
    block[7] = 0.000000000000000e+00;
    block[8] = 0.000000000000000e+00;
    block[9] = 0.000000000000000e+00;
    block[10] = 0.000000000000000e+00;
    block[11] = 0.000000000000000e+00;
    block[12] = 0.000000000000000e+00;
    block[13] = 0.000000000000000e+00;
    block[14] = 0.000000000000000e+00;
    block[15] = 0.000000000000000e+00;
    block[16] = 0.000000000000000e+00;
    block[17] = 0.000000000000000e+00;
    block[18] = 0.000000000000000e+00;
    block[19] = 0.000000000000000e+00;
    block[20] = 0.000000000000000e+00;
    block[21] = 0.000000000000000e+00;
    block[22] = 0.000000000000000e+00;
    block[23] = 0.000000000000000e+00;
    block[24] = 8.333333333333309e-03*G0_;
    block[25] = 1.666666666666661e-02*G0_;
    block[26] = 8.333333333333309e-03*G0_;
    block[27] = 8.333333333333307e-03*G0_;
    block[28] = 0.000000000000000e+00;
    block[29] = 0.000000000000000e+00;
    block[30] = 0.000000000000000e+00;
    block[31] = 0.000000000000000e+00;
    block[32] = 0.000000000000000e+00;
    block[33] = 0.000000000000000e+00;
    block[34] = 0.000000000000000e+00;
    block[35] = 0.000000000000000e+00;
    block[36] = 0.000000000000000e+00;
    block[37] = 0.000000000000000e+00;
    block[38] = 0.000000000000000e+00;
    block[39] = 0.000000000000000e+00;
    block[40] = 0.000000000000000e+00;
    block[41] = 0.000000000000000e+00;
    block[42] = 0.000000000000000e+00;
    block[43] = 0.000000000000000e+00;
    block[44] = 0.000000000000000e+00;
    block[45] = 0.000000000000000e+00;
    block[46] = 0.000000000000000e+00;
    block[47] = 0.000000000000000e+00;
    block[48] = 8.333333333333309e-03*G0_;
    block[49] = 8.333333333333309e-03*G0_;
    block[50] = 1.666666666666662e-02*G0_;
    block[51] = 8.333333333333311e-03*G0_;
    block[52] = 0.000000000000000e+00;
    block[53] = 0.000000000000000e+00;
    block[54] = 0.000000000000000e+00;
    block[55] = 0.000000000000000e+00;
    block[56] = 0.000000000000000e+00;
    block[57] = 0.000000000000000e+00;
    block[58] = 0.000000000000000e+00;
    block[59] = 0.000000000000000e+00;
    block[60] = 0.000000000000000e+00;
    block[61] = 0.000000000000000e+00;
    block[62] = 0.000000000000000e+00;
    block[63] = 0.000000000000000e+00;
    block[64] = 0.000000000000000e+00;
    block[65] = 0.000000000000000e+00;
    block[66] = 0.000000000000000e+00;
    block[67] = 0.000000000000000e+00;
    block[68] = 0.000000000000000e+00;
    block[69] = 0.000000000000000e+00;
    block[70] = 0.000000000000000e+00;
    block[71] = 0.000000000000000e+00;
    block[72] = 8.333333333333311e-03*G0_;
    block[73] = 8.333333333333309e-03*G0_;
    block[74] = 8.333333333333311e-03*G0_;
    block[75] = 1.666666666666662e-02*G0_;
    block[76] = 0.000000000000000e+00;
    block[77] = 0.000000000000000e+00;
    block[78] = 0.000000000000000e+00;
    block[79] = 0.000000000000000e+00;
    block[80] = 0.000000000000000e+00;
    block[81] = 0.000000000000000e+00;
    block[82] = 0.000000000000000e+00;
    block[83] = 0.000000000000000e+00;
    block[84] = 0.000000000000000e+00;
    block[85] = 0.000000000000000e+00;
    block[86] = 0.000000000000000e+00;
    block[87] = 0.000000000000000e+00;
    block[88] = 0.000000000000000e+00;
    block[89] = 0.000000000000000e+00;
    block[90] = 0.000000000000000e+00;
    block[91] = 0.000000000000000e+00;
    block[92] = 0.000000000000000e+00;
    block[93] = 0.000000000000000e+00;
    block[94] = 0.000000000000000e+00;
    block[95] = 0.000000000000000e+00;
    block[96] = 0.000000000000000e+00;
    block[97] = 0.000000000000000e+00;
    block[98] = 0.000000000000000e+00;
    block[99] = 0.000000000000000e+00;
    block[100] = 1.666666666666662e-02*G1_;
    block[101] = 8.333333333333307e-03*G1_;
    block[102] = 8.333333333333311e-03*G1_;
    block[103] = 8.333333333333309e-03*G1_;
    block[104] = 0.000000000000000e+00;
    block[105] = 0.000000000000000e+00;
    block[106] = 0.000000000000000e+00;
    block[107] = 0.000000000000000e+00;
    block[108] = 0.000000000000000e+00;
    block[109] = 0.000000000000000e+00;
    block[110] = 0.000000000000000e+00;
    block[111] = 0.000000000000000e+00;
    block[112] = 0.000000000000000e+00;
    block[113] = 0.000000000000000e+00;
    block[114] = 0.000000000000000e+00;
    block[115] = 0.000000000000000e+00;
    block[116] = 0.000000000000000e+00;
    block[117] = 0.000000000000000e+00;
    block[118] = 0.000000000000000e+00;
    block[119] = 0.000000000000000e+00;
    block[120] = 0.000000000000000e+00;
    block[121] = 0.000000000000000e+00;
    block[122] = 0.000000000000000e+00;
    block[123] = 0.000000000000000e+00;
    block[124] = 8.333333333333307e-03*G1_;
    block[125] = 1.666666666666662e-02*G1_;
    block[126] = 8.333333333333312e-03*G1_;
    block[127] = 8.333333333333311e-03*G1_;
    block[128] = 0.000000000000000e+00;
    block[129] = 0.000000000000000e+00;
    block[130] = 0.000000000000000e+00;
    block[131] = 0.000000000000000e+00;
    block[132] = 0.000000000000000e+00;
    block[133] = 0.000000000000000e+00;
    block[134] = 0.000000000000000e+00;
    block[135] = 0.000000000000000e+00;
    block[136] = 0.000000000000000e+00;
    block[137] = 0.000000000000000e+00;
    block[138] = 0.000000000000000e+00;
    block[139] = 0.000000000000000e+00;
    block[140] = 0.000000000000000e+00;
    block[141] = 0.000000000000000e+00;
    block[142] = 0.000000000000000e+00;
    block[143] = 0.000000000000000e+00;
    block[144] = 0.000000000000000e+00;
    block[145] = 0.000000000000000e+00;
    block[146] = 0.000000000000000e+00;
    block[147] = 0.000000000000000e+00;
    block[148] = 8.333333333333309e-03*G1_;
    block[149] = 8.333333333333312e-03*G1_;
    block[150] = 1.666666666666662e-02*G1_;
    block[151] = 8.333333333333314e-03*G1_;
    block[152] = 0.000000000000000e+00;
    block[153] = 0.000000000000000e+00;
    block[154] = 0.000000000000000e+00;
    block[155] = 0.000000000000000e+00;
    block[156] = 0.000000000000000e+00;
    block[157] = 0.000000000000000e+00;
    block[158] = 0.000000000000000e+00;
    block[159] = 0.000000000000000e+00;
    block[160] = 0.000000000000000e+00;
    block[161] = 0.000000000000000e+00;
    block[162] = 0.000000000000000e+00;
    block[163] = 0.000000000000000e+00;
    block[164] = 0.000000000000000e+00;
    block[165] = 0.000000000000000e+00;
    block[166] = 0.000000000000000e+00;
    block[167] = 0.000000000000000e+00;
    block[168] = 0.000000000000000e+00;
    block[169] = 0.000000000000000e+00;
    block[170] = 0.000000000000000e+00;
    block[171] = 0.000000000000000e+00;
    block[172] = 8.333333333333309e-03*G1_;
    block[173] = 8.333333333333311e-03*G1_;
    block[174] = 8.333333333333314e-03*G1_;
    block[175] = 1.666666666666662e-02*G1_;
    block[176] = 0.000000000000000e+00;
    block[177] = 0.000000000000000e+00;
    block[178] = 0.000000000000000e+00;
    block[179] = 0.000000000000000e+00;
    block[180] = 0.000000000000000e+00;
    block[181] = 0.000000000000000e+00;
    block[182] = 0.000000000000000e+00;
    block[183] = 0.000000000000000e+00;
    block[184] = 0.000000000000000e+00;
    block[185] = 0.000000000000000e+00;
    block[186] = 0.000000000000000e+00;
    block[187] = 0.000000000000000e+00;
    block[188] = 0.000000000000000e+00;
    block[189] = 0.000000000000000e+00;
    block[190] = 0.000000000000000e+00;
    block[191] = 0.000000000000000e+00;
    block[192] = 0.000000000000000e+00;
    block[193] = 0.000000000000000e+00;
    block[194] = 0.000000000000000e+00;
    block[195] = 0.000000000000000e+00;
    block[196] = 0.000000000000000e+00;
    block[197] = 0.000000000000000e+00;
    block[198] = 0.000000000000000e+00;
    block[199] = 0.000000000000000e+00;
    block[200] = 1.666666666666662e-02*G2_;
    block[201] = 8.333333333333309e-03*G2_;
    block[202] = 8.333333333333307e-03*G2_;
    block[203] = 8.333333333333309e-03*G2_;
    block[204] = 0.000000000000000e+00;
    block[205] = 0.000000000000000e+00;
    block[206] = 0.000000000000000e+00;
    block[207] = 0.000000000000000e+00;
    block[208] = 0.000000000000000e+00;
    block[209] = 0.000000000000000e+00;
    block[210] = 0.000000000000000e+00;
    block[211] = 0.000000000000000e+00;
    block[212] = 0.000000000000000e+00;
    block[213] = 0.000000000000000e+00;
    block[214] = 0.000000000000000e+00;
    block[215] = 0.000000000000000e+00;
    block[216] = 0.000000000000000e+00;
    block[217] = 0.000000000000000e+00;
    block[218] = 0.000000000000000e+00;
    block[219] = 0.000000000000000e+00;
    block[220] = 0.000000000000000e+00;
    block[221] = 0.000000000000000e+00;
    block[222] = 0.000000000000000e+00;
    block[223] = 0.000000000000000e+00;
    block[224] = 8.333333333333309e-03*G2_;
    block[225] = 1.666666666666662e-02*G2_;
    block[226] = 8.333333333333311e-03*G2_;
    block[227] = 8.333333333333311e-03*G2_;
    block[228] = 0.000000000000000e+00;
    block[229] = 0.000000000000000e+00;
    block[230] = 0.000000000000000e+00;
    block[231] = 0.000000000000000e+00;
    block[232] = 0.000000000000000e+00;
    block[233] = 0.000000000000000e+00;
    block[234] = 0.000000000000000e+00;
    block[235] = 0.000000000000000e+00;
    block[236] = 0.000000000000000e+00;
    block[237] = 0.000000000000000e+00;
    block[238] = 0.000000000000000e+00;
    block[239] = 0.000000000000000e+00;
    block[240] = 0.000000000000000e+00;
    block[241] = 0.000000000000000e+00;
    block[242] = 0.000000000000000e+00;
    block[243] = 0.000000000000000e+00;
    block[244] = 0.000000000000000e+00;
    block[245] = 0.000000000000000e+00;
    block[246] = 0.000000000000000e+00;
    block[247] = 0.000000000000000e+00;
    block[248] = 8.333333333333307e-03*G2_;
    block[249] = 8.333333333333311e-03*G2_;
    block[250] = 1.666666666666662e-02*G2_;
    block[251] = 8.333333333333311e-03*G2_;
    block[252] = 0.000000000000000e+00;
    block[253] = 0.000000000000000e+00;
    block[254] = 0.000000000000000e+00;
    block[255] = 0.000000000000000e+00;
    block[256] = 0.000000000000000e+00;
    block[257] = 0.000000000000000e+00;
    block[258] = 0.000000000000000e+00;
    block[259] = 0.000000000000000e+00;
    block[260] = 0.000000000000000e+00;
    block[261] = 0.000000000000000e+00;
    block[262] = 0.000000000000000e+00;
    block[263] = 0.000000000000000e+00;
    block[264] = 0.000000000000000e+00;
    block[265] = 0.000000000000000e+00;
    block[266] = 0.000000000000000e+00;
    block[267] = 0.000000000000000e+00;
    block[268] = 0.000000000000000e+00;
    block[269] = 0.000000000000000e+00;
    block[270] = 0.000000000000000e+00;
    block[271] = 0.000000000000000e+00;
    block[272] = 8.333333333333309e-03*G2_;
    block[273] = 8.333333333333312e-03*G2_;
    block[274] = 8.333333333333311e-03*G2_;
    block[275] = 1.666666666666662e-02*G2_;
    block[276] = 0.000000000000000e+00;
    block[277] = 0.000000000000000e+00;
    block[278] = 0.000000000000000e+00;
    block[279] = 0.000000000000000e+00;
    block[280] = 0.000000000000000e+00;
    block[281] = 0.000000000000000e+00;
    block[282] = 0.000000000000000e+00;
    block[283] = 0.000000000000000e+00;
    block[284] = 0.000000000000000e+00;
    block[285] = 0.000000000000000e+00;
    block[286] = 0.000000000000000e+00;
    block[287] = 0.000000000000000e+00;
    block[288] = 0.000000000000000e+00;
    block[289] = 0.000000000000000e+00;
    block[290] = 0.000000000000000e+00;
    block[291] = 0.000000000000000e+00;
    block[292] = 0.000000000000000e+00;
    block[293] = 0.000000000000000e+00;
    block[294] = 0.000000000000000e+00;
    block[295] = 0.000000000000000e+00;
    block[296] = 0.000000000000000e+00;
    block[297] = 0.000000000000000e+00;
    block[298] = 0.000000000000000e+00;
    block[299] = 0.000000000000000e+00;
    block[300] = 1.666666666666662e-02*G3_;
    block[301] = 8.333333333333307e-03*G3_;
    block[302] = 8.333333333333309e-03*G3_;
    block[303] = 8.333333333333311e-03*G3_;
    block[304] = 0.000000000000000e+00;
    block[305] = 0.000000000000000e+00;
    block[306] = 0.000000000000000e+00;
    block[307] = 0.000000000000000e+00;
    block[308] = 0.000000000000000e+00;
    block[309] = 0.000000000000000e+00;
    block[310] = 0.000000000000000e+00;
    block[311] = 0.000000000000000e+00;
    block[312] = 0.000000000000000e+00;
    block[313] = 0.000000000000000e+00;
    block[314] = 0.000000000000000e+00;
    block[315] = 0.000000000000000e+00;
    block[316] = 0.000000000000000e+00;
    block[317] = 0.000000000000000e+00;
    block[318] = 0.000000000000000e+00;
    block[319] = 0.000000000000000e+00;
    block[320] = 0.000000000000000e+00;
    block[321] = 0.000000000000000e+00;
    block[322] = 0.000000000000000e+00;
    block[323] = 0.000000000000000e+00;
    block[324] = 8.333333333333309e-03*G3_;
    block[325] = 1.666666666666661e-02*G3_;
    block[326] = 8.333333333333309e-03*G3_;
    block[327] = 8.333333333333307e-03*G3_;
    block[328] = 0.000000000000000e+00;
    block[329] = 0.000000000000000e+00;
    block[330] = 0.000000000000000e+00;
    block[331] = 0.000000000000000e+00;
    block[332] = 0.000000000000000e+00;
    block[333] = 0.000000000000000e+00;
    block[334] = 0.000000000000000e+00;
    block[335] = 0.000000000000000e+00;
    block[336] = 0.000000000000000e+00;
    block[337] = 0.000000000000000e+00;
    block[338] = 0.000000000000000e+00;
    block[339] = 0.000000000000000e+00;
    block[340] = 0.000000000000000e+00;
    block[341] = 0.000000000000000e+00;
    block[342] = 0.000000000000000e+00;
    block[343] = 0.000000000000000e+00;
    block[344] = 0.000000000000000e+00;
    block[345] = 0.000000000000000e+00;
    block[346] = 0.000000000000000e+00;
    block[347] = 0.000000000000000e+00;
    block[348] = 8.333333333333309e-03*G3_;
    block[349] = 8.333333333333309e-03*G3_;
    block[350] = 1.666666666666662e-02*G3_;
    block[351] = 8.333333333333311e-03*G3_;
    block[352] = 0.000000000000000e+00;
    block[353] = 0.000000000000000e+00;
    block[354] = 0.000000000000000e+00;
    block[355] = 0.000000000000000e+00;
    block[356] = 0.000000000000000e+00;
    block[357] = 0.000000000000000e+00;
    block[358] = 0.000000000000000e+00;
    block[359] = 0.000000000000000e+00;
    block[360] = 0.000000000000000e+00;
    block[361] = 0.000000000000000e+00;
    block[362] = 0.000000000000000e+00;
    block[363] = 0.000000000000000e+00;
    block[364] = 0.000000000000000e+00;
    block[365] = 0.000000000000000e+00;
    block[366] = 0.000000000000000e+00;
    block[367] = 0.000000000000000e+00;
    block[368] = 0.000000000000000e+00;
    block[369] = 0.000000000000000e+00;
    block[370] = 0.000000000000000e+00;
    block[371] = 0.000000000000000e+00;
    block[372] = 8.333333333333311e-03*G3_;
    block[373] = 8.333333333333309e-03*G3_;
    block[374] = 8.333333333333311e-03*G3_;
    block[375] = 1.666666666666662e-02*G3_;
    block[376] = 0.000000000000000e+00;
    block[377] = 0.000000000000000e+00;
    block[378] = 0.000000000000000e+00;
    block[379] = 0.000000000000000e+00;
    block[380] = 0.000000000000000e+00;
    block[381] = 0.000000000000000e+00;
    block[382] = 0.000000000000000e+00;
    block[383] = 0.000000000000000e+00;
    block[384] = 0.000000000000000e+00;
    block[385] = 0.000000000000000e+00;
    block[386] = 0.000000000000000e+00;
    block[387] = 0.000000000000000e+00;
    block[388] = 0.000000000000000e+00;
    block[389] = 0.000000000000000e+00;
    block[390] = 0.000000000000000e+00;
    block[391] = 0.000000000000000e+00;
    block[392] = 0.000000000000000e+00;
    block[393] = 0.000000000000000e+00;
    block[394] = 0.000000000000000e+00;
    block[395] = 0.000000000000000e+00;
    block[396] = 0.000000000000000e+00;
    block[397] = 0.000000000000000e+00;
    block[398] = 0.000000000000000e+00;
    block[399] = 0.000000000000000e+00;
    block[400] = 1.666666666666662e-02*G4_;
    block[401] = 8.333333333333307e-03*G4_;
    block[402] = 8.333333333333311e-03*G4_;
    block[403] = 8.333333333333309e-03*G4_;
    block[404] = 0.000000000000000e+00;
    block[405] = 0.000000000000000e+00;
    block[406] = 0.000000000000000e+00;
    block[407] = 0.000000000000000e+00;
    block[408] = 0.000000000000000e+00;
    block[409] = 0.000000000000000e+00;
    block[410] = 0.000000000000000e+00;
    block[411] = 0.000000000000000e+00;
    block[412] = 0.000000000000000e+00;
    block[413] = 0.000000000000000e+00;
    block[414] = 0.000000000000000e+00;
    block[415] = 0.000000000000000e+00;
    block[416] = 0.000000000000000e+00;
    block[417] = 0.000000000000000e+00;
    block[418] = 0.000000000000000e+00;
    block[419] = 0.000000000000000e+00;
    block[420] = 0.000000000000000e+00;
    block[421] = 0.000000000000000e+00;
    block[422] = 0.000000000000000e+00;
    block[423] = 0.000000000000000e+00;
    block[424] = 8.333333333333307e-03*G4_;
    block[425] = 1.666666666666662e-02*G4_;
    block[426] = 8.333333333333312e-03*G4_;
    block[427] = 8.333333333333311e-03*G4_;
    block[428] = 0.000000000000000e+00;
    block[429] = 0.000000000000000e+00;
    block[430] = 0.000000000000000e+00;
    block[431] = 0.000000000000000e+00;
    block[432] = 0.000000000000000e+00;
    block[433] = 0.000000000000000e+00;
    block[434] = 0.000000000000000e+00;
    block[435] = 0.000000000000000e+00;
    block[436] = 0.000000000000000e+00;
    block[437] = 0.000000000000000e+00;
    block[438] = 0.000000000000000e+00;
    block[439] = 0.000000000000000e+00;
    block[440] = 0.000000000000000e+00;
    block[441] = 0.000000000000000e+00;
    block[442] = 0.000000000000000e+00;
    block[443] = 0.000000000000000e+00;
    block[444] = 0.000000000000000e+00;
    block[445] = 0.000000000000000e+00;
    block[446] = 0.000000000000000e+00;
    block[447] = 0.000000000000000e+00;
    block[448] = 8.333333333333309e-03*G4_;
    block[449] = 8.333333333333312e-03*G4_;
    block[450] = 1.666666666666662e-02*G4_;
    block[451] = 8.333333333333314e-03*G4_;
    block[452] = 0.000000000000000e+00;
    block[453] = 0.000000000000000e+00;
    block[454] = 0.000000000000000e+00;
    block[455] = 0.000000000000000e+00;
    block[456] = 0.000000000000000e+00;
    block[457] = 0.000000000000000e+00;
    block[458] = 0.000000000000000e+00;
    block[459] = 0.000000000000000e+00;
    block[460] = 0.000000000000000e+00;
    block[461] = 0.000000000000000e+00;
    block[462] = 0.000000000000000e+00;
    block[463] = 0.000000000000000e+00;
    block[464] = 0.000000000000000e+00;
    block[465] = 0.000000000000000e+00;
    block[466] = 0.000000000000000e+00;
    block[467] = 0.000000000000000e+00;
    block[468] = 0.000000000000000e+00;
    block[469] = 0.000000000000000e+00;
    block[470] = 0.000000000000000e+00;
    block[471] = 0.000000000000000e+00;
    block[472] = 8.333333333333309e-03*G4_;
    block[473] = 8.333333333333311e-03*G4_;
    block[474] = 8.333333333333314e-03*G4_;
    block[475] = 1.666666666666662e-02*G4_;
    block[476] = 0.000000000000000e+00;
    block[477] = 0.000000000000000e+00;
    block[478] = 0.000000000000000e+00;
    block[479] = 0.000000000000000e+00;
    block[480] = 0.000000000000000e+00;
    block[481] = 0.000000000000000e+00;
    block[482] = 0.000000000000000e+00;
    block[483] = 0.000000000000000e+00;
    block[484] = 0.000000000000000e+00;
    block[485] = 0.000000000000000e+00;
    block[486] = 0.000000000000000e+00;
    block[487] = 0.000000000000000e+00;
    block[488] = 0.000000000000000e+00;
    block[489] = 0.000000000000000e+00;
    block[490] = 0.000000000000000e+00;
    block[491] = 0.000000000000000e+00;
    block[492] = 0.000000000000000e+00;
    block[493] = 0.000000000000000e+00;
    block[494] = 0.000000000000000e+00;
    block[495] = 0.000000000000000e+00;
    block[496] = 0.000000000000000e+00;
    block[497] = 0.000000000000000e+00;
    block[498] = 0.000000000000000e+00;
    block[499] = 0.000000000000000e+00;
    block[500] = 1.666666666666662e-02*G5_;
    block[501] = 8.333333333333309e-03*G5_;
    block[502] = 8.333333333333307e-03*G5_;
    block[503] = 8.333333333333309e-03*G5_;
    block[504] = 0.000000000000000e+00;
    block[505] = 0.000000000000000e+00;
    block[506] = 0.000000000000000e+00;
    block[507] = 0.000000000000000e+00;
    block[508] = 0.000000000000000e+00;
    block[509] = 0.000000000000000e+00;
    block[510] = 0.000000000000000e+00;
    block[511] = 0.000000000000000e+00;
    block[512] = 0.000000000000000e+00;
    block[513] = 0.000000000000000e+00;
    block[514] = 0.000000000000000e+00;
    block[515] = 0.000000000000000e+00;
    block[516] = 0.000000000000000e+00;
    block[517] = 0.000000000000000e+00;
    block[518] = 0.000000000000000e+00;
    block[519] = 0.000000000000000e+00;
    block[520] = 0.000000000000000e+00;
    block[521] = 0.000000000000000e+00;
    block[522] = 0.000000000000000e+00;
    block[523] = 0.000000000000000e+00;
    block[524] = 8.333333333333309e-03*G5_;
    block[525] = 1.666666666666662e-02*G5_;
    block[526] = 8.333333333333311e-03*G5_;
    block[527] = 8.333333333333311e-03*G5_;
    block[528] = 0.000000000000000e+00;
    block[529] = 0.000000000000000e+00;
    block[530] = 0.000000000000000e+00;
    block[531] = 0.000000000000000e+00;
    block[532] = 0.000000000000000e+00;
    block[533] = 0.000000000000000e+00;
    block[534] = 0.000000000000000e+00;
    block[535] = 0.000000000000000e+00;
    block[536] = 0.000000000000000e+00;
    block[537] = 0.000000000000000e+00;
    block[538] = 0.000000000000000e+00;
    block[539] = 0.000000000000000e+00;
    block[540] = 0.000000000000000e+00;
    block[541] = 0.000000000000000e+00;
    block[542] = 0.000000000000000e+00;
    block[543] = 0.000000000000000e+00;
    block[544] = 0.000000000000000e+00;
    block[545] = 0.000000000000000e+00;
    block[546] = 0.000000000000000e+00;
    block[547] = 0.000000000000000e+00;
    block[548] = 8.333333333333307e-03*G5_;
    block[549] = 8.333333333333311e-03*G5_;
    block[550] = 1.666666666666662e-02*G5_;
    block[551] = 8.333333333333311e-03*G5_;
    block[552] = 0.000000000000000e+00;
    block[553] = 0.000000000000000e+00;
    block[554] = 0.000000000000000e+00;
    block[555] = 0.000000000000000e+00;
    block[556] = 0.000000000000000e+00;
    block[557] = 0.000000000000000e+00;
    block[558] = 0.000000000000000e+00;
    block[559] = 0.000000000000000e+00;
    block[560] = 0.000000000000000e+00;
    block[561] = 0.000000000000000e+00;
    block[562] = 0.000000000000000e+00;
    block[563] = 0.000000000000000e+00;
    block[564] = 0.000000000000000e+00;
    block[565] = 0.000000000000000e+00;
    block[566] = 0.000000000000000e+00;
    block[567] = 0.000000000000000e+00;
    block[568] = 0.000000000000000e+00;
    block[569] = 0.000000000000000e+00;
    block[570] = 0.000000000000000e+00;
    block[571] = 0.000000000000000e+00;
    block[572] = 8.333333333333309e-03*G5_;
    block[573] = 8.333333333333312e-03*G5_;
    block[574] = 8.333333333333311e-03*G5_;
    block[575] = 1.666666666666662e-02*G5_;
  }

  // No contribution from the boundary
  void eval(real block[], const AffineMap& map, unsigned int facet) const {}   

};

/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class LinearForm : public dolfin::LinearForm
{
public:
  
  class TestElement : public dolfin::FiniteElement
  {
  public:
  
    TestElement() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      tensordims = new unsigned int [1];
      tensordims[0] = 6;
  
      subelements = new FiniteElement* [2];
      subelements[0] = new SubElement_0();
      subelements[1] = new SubElement_1();
    }
  
    ~TestElement()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 24;
    }
  
    inline unsigned int shapedim() const
    {
      return 3;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_assert(i < 1);
      return tensordims[i];
    }
  
    inline unsigned int elementdim() const
    {
      return 2;
    }
  
    inline unsigned int rank() const
    {
      return 1;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      nodes[3] = cell.vertexID(3);
      int offset = mesh.numVertices();
      nodes[4] = offset + cell.vertexID(0);
      nodes[5] = offset + cell.vertexID(1);
      nodes[6] = offset + cell.vertexID(2);
      nodes[7] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[8] = offset + cell.vertexID(0);
      nodes[9] = offset + cell.vertexID(1);
      nodes[10] = offset + cell.vertexID(2);
      nodes[11] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[12] = offset + cell.vertexID(0);
      nodes[13] = offset + cell.vertexID(1);
      nodes[14] = offset + cell.vertexID(2);
      nodes[15] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[16] = offset + cell.vertexID(0);
      nodes[17] = offset + cell.vertexID(1);
      nodes[18] = offset + cell.vertexID(2);
      nodes[19] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[20] = offset + cell.vertexID(0);
      nodes[21] = offset + cell.vertexID(1);
      nodes[22] = offset + cell.vertexID(2);
      nodes[23] = offset + cell.vertexID(3);
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 1;
      components[5] = 1;
      components[6] = 1;
      components[7] = 1;
      components[8] = 2;
      components[9] = 2;
      components[10] = 2;
      components[11] = 2;
      points[12] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[13] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[14] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[15] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[16] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[17] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[18] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[19] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[20] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[21] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[22] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[23] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[12] = 3;
      components[13] = 3;
      components[14] = 3;
      components[15] = 3;
      components[16] = 4;
      components[17] = 4;
      components[18] = 4;
      components[19] = 4;
      components[20] = 5;
      components[21] = 5;
      components[22] = 5;
      components[23] = 5;
    }
  
    void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      vertex_nodes[0] = vertex;
      int offset = mesh.numVertices();
      vertex_nodes[1] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[2] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[3] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[4] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[5] = offset + vertex;
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *subelements[i];
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *subelements[i];
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("mixed");
      return s;
    }
    
  private:
    
    class SubElement_0 : public dolfin::FiniteElement
    {
    public:
    
      SubElement_0() : dolfin::FiniteElement(), tensordims(0), subelements(0)
      {
        tensordims = new unsigned int [1];
        tensordims[0] = 3;
    
        // Element is simple, don't need to initialize subelements
      }
    
      ~SubElement_0()
      {
        if ( tensordims ) delete [] tensordims;
        if ( subelements )
        {
          for (unsigned int i = 0; i < elementdim(); i++)
            delete subelements[i];
          delete [] subelements;
        }
      }
    
      inline unsigned int spacedim() const
      {
        return 12;
      }
    
      inline unsigned int shapedim() const
      {
        return 3;
      }
    
      inline unsigned int tensordim(unsigned int i) const
      {
        dolfin_assert(i < 1);
        return tensordims[i];
      }
    
      inline unsigned int elementdim() const
      {
        return 1;
      }
    
      inline unsigned int rank() const
      {
        return 1;
      }
    
      void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
      {
        nodes[0] = cell.vertexID(0);
        nodes[1] = cell.vertexID(1);
        nodes[2] = cell.vertexID(2);
        nodes[3] = cell.vertexID(3);
        int offset = mesh.numVertices();
        nodes[4] = offset + cell.vertexID(0);
        nodes[5] = offset + cell.vertexID(1);
        nodes[6] = offset + cell.vertexID(2);
        nodes[7] = offset + cell.vertexID(3);
        offset = offset + mesh.numVertices();
        nodes[8] = offset + cell.vertexID(0);
        nodes[9] = offset + cell.vertexID(1);
        nodes[10] = offset + cell.vertexID(2);
        nodes[11] = offset + cell.vertexID(3);
      }
    
      void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
      {
        points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        components[0] = 0;
        components[1] = 0;
        components[2] = 0;
        components[3] = 0;
        components[4] = 1;
        components[5] = 1;
        components[6] = 1;
        components[7] = 1;
        components[8] = 2;
        components[9] = 2;
        components[10] = 2;
        components[11] = 2;
      }
    
      void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
      {
        // FIXME: Temporary fix for Lagrange elements
        vertex_nodes[0] = vertex;
        int offset = mesh.numVertices();
        vertex_nodes[1] = offset + vertex;
        offset = offset + mesh.numVertices();
        vertex_nodes[2] = offset + vertex;
      }
    
      const FiniteElement& operator[] (unsigned int i) const
      {
        return *this;
      }
    
      FiniteElement& operator[] (unsigned int i)
      {
        return *this;
      }
    
      FiniteElementSpec spec() const
      {
        FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
        return s;
      }
      
    private:
    
      unsigned int* tensordims;
      FiniteElement** subelements;
    
    };
      
    class SubElement_1 : public dolfin::FiniteElement
    {
    public:
    
      SubElement_1() : dolfin::FiniteElement(), tensordims(0), subelements(0)
      {
        tensordims = new unsigned int [1];
        tensordims[0] = 3;
    
        // Element is simple, don't need to initialize subelements
      }
    
      ~SubElement_1()
      {
        if ( tensordims ) delete [] tensordims;
        if ( subelements )
        {
          for (unsigned int i = 0; i < elementdim(); i++)
            delete subelements[i];
          delete [] subelements;
        }
      }
    
      inline unsigned int spacedim() const
      {
        return 12;
      }
    
      inline unsigned int shapedim() const
      {
        return 3;
      }
    
      inline unsigned int tensordim(unsigned int i) const
      {
        dolfin_assert(i < 1);
        return tensordims[i];
      }
    
      inline unsigned int elementdim() const
      {
        return 1;
      }
    
      inline unsigned int rank() const
      {
        return 1;
      }
    
      void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
      {
        nodes[0] = cell.vertexID(0);
        nodes[1] = cell.vertexID(1);
        nodes[2] = cell.vertexID(2);
        nodes[3] = cell.vertexID(3);
        int offset = mesh.numVertices();
        nodes[4] = offset + cell.vertexID(0);
        nodes[5] = offset + cell.vertexID(1);
        nodes[6] = offset + cell.vertexID(2);
        nodes[7] = offset + cell.vertexID(3);
        offset = offset + mesh.numVertices();
        nodes[8] = offset + cell.vertexID(0);
        nodes[9] = offset + cell.vertexID(1);
        nodes[10] = offset + cell.vertexID(2);
        nodes[11] = offset + cell.vertexID(3);
      }
    
      void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
      {
        points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
        points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
        points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
        components[0] = 0;
        components[1] = 0;
        components[2] = 0;
        components[3] = 0;
        components[4] = 1;
        components[5] = 1;
        components[6] = 1;
        components[7] = 1;
        components[8] = 2;
        components[9] = 2;
        components[10] = 2;
        components[11] = 2;
      }
    
      void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
      {
        // FIXME: Temporary fix for Lagrange elements
        vertex_nodes[0] = vertex;
        int offset = mesh.numVertices();
        vertex_nodes[1] = offset + vertex;
        offset = offset + mesh.numVertices();
        vertex_nodes[2] = offset + vertex;
      }
    
      const FiniteElement& operator[] (unsigned int i) const
      {
        return *this;
      }
    
      FiniteElement& operator[] (unsigned int i)
      {
        return *this;
      }
    
      FiniteElementSpec spec() const
      {
        FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
        return s;
      }
      
    private:
    
      unsigned int* tensordims;
      FiniteElement** subelements;
    
    };
    
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
    
  class FunctionElement_0 : public dolfin::FiniteElement
  {
  public:
  
    FunctionElement_0() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      tensordims = new unsigned int [1];
      tensordims[0] = 3;
  
      // Element is simple, don't need to initialize subelements
    }
  
    ~FunctionElement_0()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 12;
    }
  
    inline unsigned int shapedim() const
    {
      return 3;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_assert(i < 1);
      return tensordims[i];
    }
  
    inline unsigned int elementdim() const
    {
      return 1;
    }
  
    inline unsigned int rank() const
    {
      return 1;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      nodes[3] = cell.vertexID(3);
      int offset = mesh.numVertices();
      nodes[4] = offset + cell.vertexID(0);
      nodes[5] = offset + cell.vertexID(1);
      nodes[6] = offset + cell.vertexID(2);
      nodes[7] = offset + cell.vertexID(3);
      offset = offset + mesh.numVertices();
      nodes[8] = offset + cell.vertexID(0);
      nodes[9] = offset + cell.vertexID(1);
      nodes[10] = offset + cell.vertexID(2);
      nodes[11] = offset + cell.vertexID(3);
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[3] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[4] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[5] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[6] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[7] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      points[8] = map(0.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[9] = map(1.000000000000000e+00, 0.000000000000000e+00, 0.000000000000000e+00);
      points[10] = map(0.000000000000000e+00, 1.000000000000000e+00, 0.000000000000000e+00);
      points[11] = map(0.000000000000000e+00, 0.000000000000000e+00, 1.000000000000000e+00);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 1;
      components[5] = 1;
      components[6] = 1;
      components[7] = 1;
      components[8] = 2;
      components[9] = 2;
      components[10] = 2;
      components[11] = 2;
    }
  
    void vertexeval(uint vertex_nodes[], unsigned int vertex, const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      vertex_nodes[0] = vertex;
      int offset = mesh.numVertices();
      vertex_nodes[1] = offset + vertex;
      offset = offset + mesh.numVertices();
      vertex_nodes[2] = offset + vertex;
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *this;
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *this;
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("Vector Lagrange", "tetrahedron", 1, 3);
      return s;
    }
    
  private:
  
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
  
  LinearForm(Function& w0) : dolfin::LinearForm(1)
  {
    // Create finite element for test space
    _test = new TestElement();

    // Add functions
    add(w0, new FunctionElement_0());
  }

  void eval(real block[], const AffineMap& map) const
  {
    // Compute coefficients
    const real c0_0 = c[0][0];
    const real c0_1 = c[0][1];
    const real c0_2 = c[0][2];
    const real c0_3 = c[0][3];
    const real c0_4 = c[0][4];
    const real c0_5 = c[0][5];
    const real c0_6 = c[0][6];
    const real c0_7 = c[0][7];
    const real c0_8 = c[0][8];
    const real c0_9 = c[0][9];
    const real c0_10 = c[0][10];
    const real c0_11 = c[0][11];

    // Compute geometry tensors
    const real G0_0_0 = map.det*c0_0*map.g00;
    const real G0_0_1 = map.det*c0_0*map.g10;
    const real G0_0_2 = map.det*c0_0*map.g20;
    const real G0_1_0 = map.det*c0_1*map.g00;
    const real G0_2_1 = map.det*c0_2*map.g10;
    const real G0_3_2 = map.det*c0_3*map.g20;
    const real G1_4_0 = map.det*c0_4*map.g01;
    const real G1_4_1 = map.det*c0_4*map.g11;
    const real G1_4_2 = map.det*c0_4*map.g21;
    const real G1_5_0 = map.det*c0_5*map.g01;
    const real G1_6_1 = map.det*c0_6*map.g11;
    const real G1_7_2 = map.det*c0_7*map.g21;
    const real G2_8_0 = map.det*c0_8*map.g02;
    const real G2_8_1 = map.det*c0_8*map.g12;
    const real G2_8_2 = map.det*c0_8*map.g22;
    const real G2_9_0 = map.det*c0_9*map.g02;
    const real G2_10_1 = map.det*c0_10*map.g12;
    const real G2_11_2 = map.det*c0_11*map.g22;
    const real G3_0_0 = map.det*c0_0*map.g01;
    const real G3_0_1 = map.det*c0_0*map.g11;
    const real G3_0_2 = map.det*c0_0*map.g21;
    const real G3_1_0 = map.det*c0_1*map.g01;
    const real G3_2_1 = map.det*c0_2*map.g11;
    const real G3_3_2 = map.det*c0_3*map.g21;
    const real G4_4_0 = map.det*c0_4*map.g00;
    const real G4_4_1 = map.det*c0_4*map.g10;
    const real G4_4_2 = map.det*c0_4*map.g20;
    const real G4_5_0 = map.det*c0_5*map.g00;
    const real G4_6_1 = map.det*c0_6*map.g10;
    const real G4_7_2 = map.det*c0_7*map.g20;
    const real G5_0_0 = map.det*c0_0*map.g02;
    const real G5_0_1 = map.det*c0_0*map.g12;
    const real G5_0_2 = map.det*c0_0*map.g22;
    const real G5_1_0 = map.det*c0_1*map.g02;
    const real G5_2_1 = map.det*c0_2*map.g12;
    const real G5_3_2 = map.det*c0_3*map.g22;
    const real G6_8_0 = map.det*c0_8*map.g00;
    const real G6_8_1 = map.det*c0_8*map.g10;
    const real G6_8_2 = map.det*c0_8*map.g20;
    const real G6_9_0 = map.det*c0_9*map.g00;
    const real G6_10_1 = map.det*c0_10*map.g10;
    const real G6_11_2 = map.det*c0_11*map.g20;
    const real G7_4_0 = map.det*c0_4*map.g02;
    const real G7_4_1 = map.det*c0_4*map.g12;
    const real G7_4_2 = map.det*c0_4*map.g22;
    const real G7_5_0 = map.det*c0_5*map.g02;
    const real G7_6_1 = map.det*c0_6*map.g12;
    const real G7_7_2 = map.det*c0_7*map.g22;
    const real G8_8_0 = map.det*c0_8*map.g01;
    const real G8_8_1 = map.det*c0_8*map.g11;
    const real G8_8_2 = map.det*c0_8*map.g21;
    const real G8_9_0 = map.det*c0_9*map.g01;
    const real G8_10_1 = map.det*c0_10*map.g11;
    const real G8_11_2 = map.det*c0_11*map.g21;

    // Compute element tensor
    block[0] = -4.166666666666662e-02*G0_0_0 - 4.166666666666662e-02*G0_0_1 - 4.166666666666662e-02*G0_0_2 + 4.166666666666662e-02*G0_1_0 + 4.166666666666662e-02*G0_2_1 + 4.166666666666662e-02*G0_3_2;
    block[1] = -4.166666666666660e-02*G0_0_0 - 4.166666666666661e-02*G0_0_1 - 4.166666666666660e-02*G0_0_2 + 4.166666666666660e-02*G0_1_0 + 4.166666666666661e-02*G0_2_1 + 4.166666666666661e-02*G0_3_2;
    block[2] = -4.166666666666661e-02*G0_0_0 - 4.166666666666662e-02*G0_0_1 - 4.166666666666661e-02*G0_0_2 + 4.166666666666661e-02*G0_1_0 + 4.166666666666662e-02*G0_2_1 + 4.166666666666662e-02*G0_3_2;
    block[3] = -4.166666666666661e-02*G0_0_0 - 4.166666666666662e-02*G0_0_1 - 4.166666666666661e-02*G0_0_2 + 4.166666666666661e-02*G0_1_0 + 4.166666666666662e-02*G0_2_1 + 4.166666666666662e-02*G0_3_2;
    block[4] = -4.166666666666661e-02*G1_4_0 - 4.166666666666662e-02*G1_4_1 - 4.166666666666662e-02*G1_4_2 + 4.166666666666661e-02*G1_5_0 + 4.166666666666662e-02*G1_6_1 + 4.166666666666662e-02*G1_7_2;
    block[5] = -4.166666666666661e-02*G1_4_0 - 4.166666666666662e-02*G1_4_1 - 4.166666666666662e-02*G1_4_2 + 4.166666666666661e-02*G1_5_0 + 4.166666666666662e-02*G1_6_1 + 4.166666666666662e-02*G1_7_2;
    block[6] = -4.166666666666662e-02*G1_4_0 - 4.166666666666662e-02*G1_4_1 - 4.166666666666662e-02*G1_4_2 + 4.166666666666662e-02*G1_5_0 + 4.166666666666662e-02*G1_6_1 + 4.166666666666662e-02*G1_7_2;
    block[7] = -4.166666666666661e-02*G1_4_0 - 4.166666666666662e-02*G1_4_1 - 4.166666666666662e-02*G1_4_2 + 4.166666666666661e-02*G1_5_0 + 4.166666666666662e-02*G1_6_1 + 4.166666666666662e-02*G1_7_2;
    block[8] = -4.166666666666661e-02*G2_8_0 - 4.166666666666662e-02*G2_8_1 - 4.166666666666662e-02*G2_8_2 + 4.166666666666661e-02*G2_9_0 + 4.166666666666662e-02*G2_10_1 + 4.166666666666662e-02*G2_11_2;
    block[9] = -4.166666666666661e-02*G2_8_0 - 4.166666666666662e-02*G2_8_1 - 4.166666666666662e-02*G2_8_2 + 4.166666666666661e-02*G2_9_0 + 4.166666666666662e-02*G2_10_1 + 4.166666666666662e-02*G2_11_2;
    block[10] = -4.166666666666661e-02*G2_8_0 - 4.166666666666662e-02*G2_8_1 - 4.166666666666662e-02*G2_8_2 + 4.166666666666661e-02*G2_9_0 + 4.166666666666662e-02*G2_10_1 + 4.166666666666662e-02*G2_11_2;
    block[11] = -4.166666666666661e-02*G2_8_0 - 4.166666666666662e-02*G2_8_1 - 4.166666666666662e-02*G2_8_2 + 4.166666666666661e-02*G2_9_0 + 4.166666666666662e-02*G2_10_1 + 4.166666666666662e-02*G2_11_2;
    block[12] = -4.166666666666662e-02*G3_0_0 - 4.166666666666662e-02*G3_0_1 - 4.166666666666662e-02*G3_0_2 + 4.166666666666662e-02*G3_1_0 + 4.166666666666662e-02*G3_2_1 + 4.166666666666662e-02*G3_3_2 - 4.166666666666662e-02*G4_4_0 - 4.166666666666662e-02*G4_4_1 - 4.166666666666662e-02*G4_4_2 + 4.166666666666662e-02*G4_5_0 + 4.166666666666662e-02*G4_6_1 + 4.166666666666662e-02*G4_7_2;
    block[13] = -4.166666666666660e-02*G3_0_0 - 4.166666666666661e-02*G3_0_1 - 4.166666666666660e-02*G3_0_2 + 4.166666666666660e-02*G3_1_0 + 4.166666666666661e-02*G3_2_1 + 4.166666666666661e-02*G3_3_2 - 4.166666666666660e-02*G4_4_0 - 4.166666666666661e-02*G4_4_1 - 4.166666666666661e-02*G4_4_2 + 4.166666666666660e-02*G4_5_0 + 4.166666666666661e-02*G4_6_1 + 4.166666666666661e-02*G4_7_2;
    block[14] = -4.166666666666661e-02*G3_0_0 - 4.166666666666662e-02*G3_0_1 - 4.166666666666661e-02*G3_0_2 + 4.166666666666661e-02*G3_1_0 + 4.166666666666662e-02*G3_2_1 + 4.166666666666662e-02*G3_3_2 - 4.166666666666661e-02*G4_4_0 - 4.166666666666662e-02*G4_4_1 - 4.166666666666662e-02*G4_4_2 + 4.166666666666661e-02*G4_5_0 + 4.166666666666662e-02*G4_6_1 + 4.166666666666662e-02*G4_7_2;
    block[15] = -4.166666666666661e-02*G3_0_0 - 4.166666666666662e-02*G3_0_1 - 4.166666666666661e-02*G3_0_2 + 4.166666666666661e-02*G3_1_0 + 4.166666666666662e-02*G3_2_1 + 4.166666666666662e-02*G3_3_2 - 4.166666666666661e-02*G4_4_0 - 4.166666666666662e-02*G4_4_1 - 4.166666666666662e-02*G4_4_2 + 4.166666666666661e-02*G4_5_0 + 4.166666666666662e-02*G4_6_1 + 4.166666666666662e-02*G4_7_2;
    block[16] = -4.166666666666661e-02*G5_0_0 - 4.166666666666662e-02*G5_0_1 - 4.166666666666661e-02*G5_0_2 + 4.166666666666661e-02*G5_1_0 + 4.166666666666662e-02*G5_2_1 + 4.166666666666662e-02*G5_3_2 - 4.166666666666661e-02*G6_8_0 - 4.166666666666662e-02*G6_8_1 - 4.166666666666662e-02*G6_8_2 + 4.166666666666661e-02*G6_9_0 + 4.166666666666662e-02*G6_10_1 + 4.166666666666662e-02*G6_11_2;
    block[17] = -4.166666666666661e-02*G5_0_0 - 4.166666666666662e-02*G5_0_1 - 4.166666666666661e-02*G5_0_2 + 4.166666666666661e-02*G5_1_0 + 4.166666666666662e-02*G5_2_1 + 4.166666666666662e-02*G5_3_2 - 4.166666666666661e-02*G6_8_0 - 4.166666666666662e-02*G6_8_1 - 4.166666666666662e-02*G6_8_2 + 4.166666666666661e-02*G6_9_0 + 4.166666666666662e-02*G6_10_1 + 4.166666666666662e-02*G6_11_2;
    block[18] = -4.166666666666662e-02*G5_0_0 - 4.166666666666662e-02*G5_0_1 - 4.166666666666662e-02*G5_0_2 + 4.166666666666662e-02*G5_1_0 + 4.166666666666662e-02*G5_2_1 + 4.166666666666662e-02*G5_3_2 - 4.166666666666662e-02*G6_8_0 - 4.166666666666662e-02*G6_8_1 - 4.166666666666662e-02*G6_8_2 + 4.166666666666662e-02*G6_9_0 + 4.166666666666662e-02*G6_10_1 + 4.166666666666662e-02*G6_11_2;
    block[19] = -4.166666666666661e-02*G5_0_0 - 4.166666666666662e-02*G5_0_1 - 4.166666666666661e-02*G5_0_2 + 4.166666666666661e-02*G5_1_0 + 4.166666666666662e-02*G5_2_1 + 4.166666666666662e-02*G5_3_2 - 4.166666666666661e-02*G6_8_0 - 4.166666666666662e-02*G6_8_1 - 4.166666666666662e-02*G6_8_2 + 4.166666666666661e-02*G6_9_0 + 4.166666666666662e-02*G6_10_1 + 4.166666666666662e-02*G6_11_2;
    block[20] = -4.166666666666661e-02*G7_4_0 - 4.166666666666662e-02*G7_4_1 - 4.166666666666662e-02*G7_4_2 + 4.166666666666661e-02*G7_5_0 + 4.166666666666662e-02*G7_6_1 + 4.166666666666662e-02*G7_7_2 - 4.166666666666661e-02*G8_8_0 - 4.166666666666662e-02*G8_8_1 - 4.166666666666662e-02*G8_8_2 + 4.166666666666661e-02*G8_9_0 + 4.166666666666662e-02*G8_10_1 + 4.166666666666662e-02*G8_11_2;
    block[21] = -4.166666666666661e-02*G7_4_0 - 4.166666666666662e-02*G7_4_1 - 4.166666666666662e-02*G7_4_2 + 4.166666666666661e-02*G7_5_0 + 4.166666666666662e-02*G7_6_1 + 4.166666666666662e-02*G7_7_2 - 4.166666666666661e-02*G8_8_0 - 4.166666666666662e-02*G8_8_1 - 4.166666666666662e-02*G8_8_2 + 4.166666666666661e-02*G8_9_0 + 4.166666666666662e-02*G8_10_1 + 4.166666666666662e-02*G8_11_2;
    block[22] = -4.166666666666661e-02*G7_4_0 - 4.166666666666662e-02*G7_4_1 - 4.166666666666662e-02*G7_4_2 + 4.166666666666661e-02*G7_5_0 + 4.166666666666662e-02*G7_6_1 + 4.166666666666662e-02*G7_7_2 - 4.166666666666661e-02*G8_8_0 - 4.166666666666662e-02*G8_8_1 - 4.166666666666662e-02*G8_8_2 + 4.166666666666661e-02*G8_9_0 + 4.166666666666662e-02*G8_10_1 + 4.166666666666662e-02*G8_11_2;
    block[23] = -4.166666666666661e-02*G7_4_0 - 4.166666666666662e-02*G7_4_1 - 4.166666666666662e-02*G7_4_2 + 4.166666666666661e-02*G7_5_0 + 4.166666666666662e-02*G7_6_1 + 4.166666666666662e-02*G7_7_2 - 4.166666666666661e-02*G8_8_0 - 4.166666666666662e-02*G8_8_1 - 4.166666666666662e-02*G8_8_2 + 4.166666666666661e-02*G8_9_0 + 4.166666666666662e-02*G8_10_1 + 4.166666666666662e-02*G8_11_2;
  }

  // No contribution from the boundary
  void eval(real block[], const AffineMap& map, unsigned int facet) const {}   

};

} }

#endif
