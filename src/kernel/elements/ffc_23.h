// This code conforms with the UFC specification version 1.0
// and was automatically generated by FFC version 0.3.5.

#ifndef __FFC_23_H
#define __FFC_23_H

#include <cmath>
#include <ufc.h>

/// This class defines the interface for a finite element.

class ffc_23_finite_element_0_0: public ufc::finite_element
{
public:

  /// Constructor
  ffc_23_finite_element_0_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_23_finite_element_0_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "Discontinuous Lagrange finite element of degree 1 on a tetrahedron";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 4;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_02 = element_coordinates[3][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    const double J_12 = element_coordinates[3][1] - element_coordinates[0][1];
    const double J_20 = element_coordinates[1][2] - element_coordinates[0][2];
    const double J_21 = element_coordinates[2][2] - element_coordinates[0][2];
    const double J_22 = element_coordinates[3][2] - element_coordinates[0][2];
      
    // Compute sub determinants
    const double d00 = J_11*J_22 - J_12*J_21;
    const double d01 = J_12*J_20 - J_10*J_22;
    const double d02 = J_10*J_21 - J_11*J_20;
    
    const double d10 = J_02*J_21 - J_01*J_22;
    const double d11 = J_00*J_22 - J_02*J_20;
    const double d12 = J_01*J_20 - J_00*J_21;
    
    const double d20 = J_01*J_12 - J_02*J_11;
    const double d21 = J_02*J_10 - J_00*J_12;
    const double d22 = J_00*J_11 - J_01*J_10;
      
    // Compute determinant of Jacobian
    double detJ = J_00*d00 + J_10*d10 + J_20*d20;
    
    // Compute constants
    const double C0 = element_coordinates[3][0] + element_coordinates[2][0] \
                    + element_coordinates[1][0] - element_coordinates[0][0];
    const double C1 = element_coordinates[3][1] + element_coordinates[2][1] \
                    + element_coordinates[1][1] - element_coordinates[0][1];
    const double C2 = element_coordinates[3][2] + element_coordinates[2][2] \
                    + element_coordinates[1][2] - element_coordinates[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double x = coordinates[0];
    double y = coordinates[1];
    double z = coordinates[2];
    
    x = (2.0*d00*x + 2.0*d10*y + 2.0*d20*z - d00*C0 - d10*C1 - d20*C2) / detJ;
    y = (2.0*d01*x + 2.0*d11*y + 2.0*d21*z - d01*C0 - d11*C1 - d21*C2) / detJ;
    z = (2.0*d02*x + 2.0*d12*y + 2.0*d22*z - d02*C0 - d12*C1 - d22*C2) / detJ;
    
    // Map coordinates to the reference cube
    if (std::abs(y + z) < 1e-14)
      x = 1.0;
    else
      x = -2.0 * (1.0 + x)/(y + z) - 1.0;
    if (std::abs(z - 1.0) < 1e-14)
      y = -1.0;
    else
      y = 2.0 * (1.0 + y)/(1.0 - z) - 1.0;
    
    const static unsigned int dof = i;
    
    // Table(s) of coefficients
    const static double coefficients0[4][4] = \
    {{0.2886751345948, -0.1825741858351, -0.1054092553389, -0.07453559924999},
    {0.2886751345948, 0.1825741858351, -0.1054092553389, -0.07453559924999},
    {0.2886751345948, 0, 0.2108185106779, -0.07453559924999},
    {0.2886751345948, 0, 0, 0.22360679775}};
    
    // Generate scalings
    const double scalings_y_0 = 1.0;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5 * y);
    const double scalings_z_0 = 1.0;
    const double scalings_z_1 = scalings_z_0*(0.5 - 0.5 * z);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1.0;
    const double psitilde_a_1 = 1*x;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1.0;
    const double psitilde_bs_0_1 = 0.5 + 1.5*y;
    const double psitilde_bs_1_0 = 1.0;
    
    // Compute psitilde_cs
    const double psitilde_cs_00_0 = 1.0;
    const double psitilde_cs_00_1 = 1 + 2*z;
    const double psitilde_cs_01_0 = 1.0;
    const double psitilde_cs_10_0 = 1.0;
    
    // Compute basisvalues
    const double basisvalues[4] = \
    {psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_0*0.8660254037844,\
     psitilde_a_1*scalings_y_1*psitilde_bs_1_0*scalings_z_1*psitilde_cs_10_0*2.738612787526,\
     psitilde_a_0*scalings_y_0*psitilde_bs_0_1*scalings_z_1*psitilde_cs_01_0*1.581138830084,\
     psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_1*1.11803398875};
    
    // Compute value(s)
    *values = 0.0;
    for (unsigned int j = 0; j < 4; j++)
      *values += coefficients0[dof][j]*basisvalues[j];
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Not implemented (only for Lagrange elements
    return 0;
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new ffc_23_finite_element_0_0();
  }

};

/// This class defines the interface for a finite element.

class ffc_23_finite_element_0_1: public ufc::finite_element
{
public:

  /// Constructor
  ffc_23_finite_element_0_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_23_finite_element_0_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "Discontinuous Lagrange finite element of degree 1 on a tetrahedron";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 4;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_02 = element_coordinates[3][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    const double J_12 = element_coordinates[3][1] - element_coordinates[0][1];
    const double J_20 = element_coordinates[1][2] - element_coordinates[0][2];
    const double J_21 = element_coordinates[2][2] - element_coordinates[0][2];
    const double J_22 = element_coordinates[3][2] - element_coordinates[0][2];
      
    // Compute sub determinants
    const double d00 = J_11*J_22 - J_12*J_21;
    const double d01 = J_12*J_20 - J_10*J_22;
    const double d02 = J_10*J_21 - J_11*J_20;
    
    const double d10 = J_02*J_21 - J_01*J_22;
    const double d11 = J_00*J_22 - J_02*J_20;
    const double d12 = J_01*J_20 - J_00*J_21;
    
    const double d20 = J_01*J_12 - J_02*J_11;
    const double d21 = J_02*J_10 - J_00*J_12;
    const double d22 = J_00*J_11 - J_01*J_10;
      
    // Compute determinant of Jacobian
    double detJ = J_00*d00 + J_10*d10 + J_20*d20;
    
    // Compute constants
    const double C0 = element_coordinates[3][0] + element_coordinates[2][0] \
                    + element_coordinates[1][0] - element_coordinates[0][0];
    const double C1 = element_coordinates[3][1] + element_coordinates[2][1] \
                    + element_coordinates[1][1] - element_coordinates[0][1];
    const double C2 = element_coordinates[3][2] + element_coordinates[2][2] \
                    + element_coordinates[1][2] - element_coordinates[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double x = coordinates[0];
    double y = coordinates[1];
    double z = coordinates[2];
    
    x = (2.0*d00*x + 2.0*d10*y + 2.0*d20*z - d00*C0 - d10*C1 - d20*C2) / detJ;
    y = (2.0*d01*x + 2.0*d11*y + 2.0*d21*z - d01*C0 - d11*C1 - d21*C2) / detJ;
    z = (2.0*d02*x + 2.0*d12*y + 2.0*d22*z - d02*C0 - d12*C1 - d22*C2) / detJ;
    
    // Map coordinates to the reference cube
    if (std::abs(y + z) < 1e-14)
      x = 1.0;
    else
      x = -2.0 * (1.0 + x)/(y + z) - 1.0;
    if (std::abs(z - 1.0) < 1e-14)
      y = -1.0;
    else
      y = 2.0 * (1.0 + y)/(1.0 - z) - 1.0;
    
    const static unsigned int dof = i;
    
    // Table(s) of coefficients
    const static double coefficients0[4][4] = \
    {{0.2886751345948, -0.1825741858351, -0.1054092553389, -0.07453559924999},
    {0.2886751345948, 0.1825741858351, -0.1054092553389, -0.07453559924999},
    {0.2886751345948, 0, 0.2108185106779, -0.07453559924999},
    {0.2886751345948, 0, 0, 0.22360679775}};
    
    // Generate scalings
    const double scalings_y_0 = 1.0;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5 * y);
    const double scalings_z_0 = 1.0;
    const double scalings_z_1 = scalings_z_0*(0.5 - 0.5 * z);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1.0;
    const double psitilde_a_1 = 1*x;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1.0;
    const double psitilde_bs_0_1 = 0.5 + 1.5*y;
    const double psitilde_bs_1_0 = 1.0;
    
    // Compute psitilde_cs
    const double psitilde_cs_00_0 = 1.0;
    const double psitilde_cs_00_1 = 1 + 2*z;
    const double psitilde_cs_01_0 = 1.0;
    const double psitilde_cs_10_0 = 1.0;
    
    // Compute basisvalues
    const double basisvalues[4] = \
    {psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_0*0.8660254037844,\
     psitilde_a_1*scalings_y_1*psitilde_bs_1_0*scalings_z_1*psitilde_cs_10_0*2.738612787526,\
     psitilde_a_0*scalings_y_0*psitilde_bs_0_1*scalings_z_1*psitilde_cs_01_0*1.581138830084,\
     psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_1*1.11803398875};
    
    // Compute value(s)
    *values = 0.0;
    for (unsigned int j = 0; j < 4; j++)
      *values += coefficients0[dof][j]*basisvalues[j];
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Not implemented (only for Lagrange elements
    return 0;
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new ffc_23_finite_element_0_1();
  }

};

/// This class defines the interface for a finite element.

class ffc_23_finite_element_0_2: public ufc::finite_element
{
public:

  /// Constructor
  ffc_23_finite_element_0_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_23_finite_element_0_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "Discontinuous Lagrange finite element of degree 1 on a tetrahedron";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 4;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_02 = element_coordinates[3][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    const double J_12 = element_coordinates[3][1] - element_coordinates[0][1];
    const double J_20 = element_coordinates[1][2] - element_coordinates[0][2];
    const double J_21 = element_coordinates[2][2] - element_coordinates[0][2];
    const double J_22 = element_coordinates[3][2] - element_coordinates[0][2];
      
    // Compute sub determinants
    const double d00 = J_11*J_22 - J_12*J_21;
    const double d01 = J_12*J_20 - J_10*J_22;
    const double d02 = J_10*J_21 - J_11*J_20;
    
    const double d10 = J_02*J_21 - J_01*J_22;
    const double d11 = J_00*J_22 - J_02*J_20;
    const double d12 = J_01*J_20 - J_00*J_21;
    
    const double d20 = J_01*J_12 - J_02*J_11;
    const double d21 = J_02*J_10 - J_00*J_12;
    const double d22 = J_00*J_11 - J_01*J_10;
      
    // Compute determinant of Jacobian
    double detJ = J_00*d00 + J_10*d10 + J_20*d20;
    
    // Compute constants
    const double C0 = element_coordinates[3][0] + element_coordinates[2][0] \
                    + element_coordinates[1][0] - element_coordinates[0][0];
    const double C1 = element_coordinates[3][1] + element_coordinates[2][1] \
                    + element_coordinates[1][1] - element_coordinates[0][1];
    const double C2 = element_coordinates[3][2] + element_coordinates[2][2] \
                    + element_coordinates[1][2] - element_coordinates[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double x = coordinates[0];
    double y = coordinates[1];
    double z = coordinates[2];
    
    x = (2.0*d00*x + 2.0*d10*y + 2.0*d20*z - d00*C0 - d10*C1 - d20*C2) / detJ;
    y = (2.0*d01*x + 2.0*d11*y + 2.0*d21*z - d01*C0 - d11*C1 - d21*C2) / detJ;
    z = (2.0*d02*x + 2.0*d12*y + 2.0*d22*z - d02*C0 - d12*C1 - d22*C2) / detJ;
    
    // Map coordinates to the reference cube
    if (std::abs(y + z) < 1e-14)
      x = 1.0;
    else
      x = -2.0 * (1.0 + x)/(y + z) - 1.0;
    if (std::abs(z - 1.0) < 1e-14)
      y = -1.0;
    else
      y = 2.0 * (1.0 + y)/(1.0 - z) - 1.0;
    
    const static unsigned int dof = i;
    
    // Table(s) of coefficients
    const static double coefficients0[4][4] = \
    {{0.2886751345948, -0.1825741858351, -0.1054092553389, -0.07453559924999},
    {0.2886751345948, 0.1825741858351, -0.1054092553389, -0.07453559924999},
    {0.2886751345948, 0, 0.2108185106779, -0.07453559924999},
    {0.2886751345948, 0, 0, 0.22360679775}};
    
    // Generate scalings
    const double scalings_y_0 = 1.0;
    const double scalings_y_1 = scalings_y_0*(0.5 - 0.5 * y);
    const double scalings_z_0 = 1.0;
    const double scalings_z_1 = scalings_z_0*(0.5 - 0.5 * z);
    
    // Compute psitilde_a
    const double psitilde_a_0 = 1.0;
    const double psitilde_a_1 = 1*x;
    
    // Compute psitilde_bs
    const double psitilde_bs_0_0 = 1.0;
    const double psitilde_bs_0_1 = 0.5 + 1.5*y;
    const double psitilde_bs_1_0 = 1.0;
    
    // Compute psitilde_cs
    const double psitilde_cs_00_0 = 1.0;
    const double psitilde_cs_00_1 = 1 + 2*z;
    const double psitilde_cs_01_0 = 1.0;
    const double psitilde_cs_10_0 = 1.0;
    
    // Compute basisvalues
    const double basisvalues[4] = \
    {psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_0*0.8660254037844,\
     psitilde_a_1*scalings_y_1*psitilde_bs_1_0*scalings_z_1*psitilde_cs_10_0*2.738612787526,\
     psitilde_a_0*scalings_y_0*psitilde_bs_0_1*scalings_z_1*psitilde_cs_01_0*1.581138830084,\
     psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_1*1.11803398875};
    
    // Compute value(s)
    *values = 0.0;
    for (unsigned int j = 0; j < 4; j++)
      *values += coefficients0[dof][j]*basisvalues[j];
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Not implemented (only for Lagrange elements
    return 0;
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 1;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return new ffc_23_finite_element_0_2();
  }

};

/// This class defines the interface for a finite element.

class ffc_23_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  ffc_23_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_23_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "Mixed finite element: [Discontinuous Lagrange finite element of degree 1 on a tetrahedron, Discontinuous Lagrange finite element of degree 1 on a tetrahedron, Discontinuous Lagrange finite element of degree 1 on a tetrahedron]";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::tetrahedron;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 3;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * element_coordinates = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = element_coordinates[1][0] - element_coordinates[0][0];
    const double J_01 = element_coordinates[2][0] - element_coordinates[0][0];
    const double J_02 = element_coordinates[3][0] - element_coordinates[0][0];
    const double J_10 = element_coordinates[1][1] - element_coordinates[0][1];
    const double J_11 = element_coordinates[2][1] - element_coordinates[0][1];
    const double J_12 = element_coordinates[3][1] - element_coordinates[0][1];
    const double J_20 = element_coordinates[1][2] - element_coordinates[0][2];
    const double J_21 = element_coordinates[2][2] - element_coordinates[0][2];
    const double J_22 = element_coordinates[3][2] - element_coordinates[0][2];
      
    // Compute sub determinants
    const double d00 = J_11*J_22 - J_12*J_21;
    const double d01 = J_12*J_20 - J_10*J_22;
    const double d02 = J_10*J_21 - J_11*J_20;
    
    const double d10 = J_02*J_21 - J_01*J_22;
    const double d11 = J_00*J_22 - J_02*J_20;
    const double d12 = J_01*J_20 - J_00*J_21;
    
    const double d20 = J_01*J_12 - J_02*J_11;
    const double d21 = J_02*J_10 - J_00*J_12;
    const double d22 = J_00*J_11 - J_01*J_10;
      
    // Compute determinant of Jacobian
    double detJ = J_00*d00 + J_10*d10 + J_20*d20;
    
    // Compute constants
    const double C0 = element_coordinates[3][0] + element_coordinates[2][0] \
                    + element_coordinates[1][0] - element_coordinates[0][0];
    const double C1 = element_coordinates[3][1] + element_coordinates[2][1] \
                    + element_coordinates[1][1] - element_coordinates[0][1];
    const double C2 = element_coordinates[3][2] + element_coordinates[2][2] \
                    + element_coordinates[1][2] - element_coordinates[0][2];
    
    // Get coordinates and map to the reference (FIAT) element
    double x = coordinates[0];
    double y = coordinates[1];
    double z = coordinates[2];
    
    x = (2.0*d00*x + 2.0*d10*y + 2.0*d20*z - d00*C0 - d10*C1 - d20*C2) / detJ;
    y = (2.0*d01*x + 2.0*d11*y + 2.0*d21*z - d01*C0 - d11*C1 - d21*C2) / detJ;
    z = (2.0*d02*x + 2.0*d12*y + 2.0*d22*z - d02*C0 - d12*C1 - d22*C2) / detJ;
    
    // Map coordinates to the reference cube
    if (std::abs(y + z) < 1e-14)
      x = 1.0;
    else
      x = -2.0 * (1.0 + x)/(y + z) - 1.0;
    if (std::abs(z - 1.0) < 1e-14)
      y = -1.0;
    else
      y = 2.0 * (1.0 + y)/(1.0 - z) - 1.0;
    
    for (unsigned int element = 0; element < 3; element++)
    // Switch for each of the basis elements
    {
      switch ( element )
      {
        case 0:
        {
          if (0 <= i and i <= 3)
          {
            // Compute local degree of freedom
            const static unsigned int dof = i;
    
            // Table(s) of coefficients
            const static double coefficients0[4][4] =         \
            {{0.2886751345948, -0.1825741858351, -0.1054092553389, -0.07453559924999},
            {0.2886751345948, 0.1825741858351, -0.1054092553389, -0.07453559924999},
            {0.2886751345948, 0, 0.2108185106779, -0.07453559924999},
            {0.2886751345948, 0, 0, 0.22360679775}};
    
            // Generate scalings
            const double scalings_y_0 = 1.0;
            const double scalings_y_1 = scalings_y_0*(0.5 - 0.5 * y);
            const double scalings_z_0 = 1.0;
            const double scalings_z_1 = scalings_z_0*(0.5 - 0.5 * z);
    
            // Compute psitilde_a
            const double psitilde_a_0 = 1.0;
            const double psitilde_a_1 = 1*x;
    
            // Compute psitilde_bs
            const double psitilde_bs_0_0 = 1.0;
            const double psitilde_bs_0_1 = 0.5 + 1.5*y;
            const double psitilde_bs_1_0 = 1.0;
    
            // Compute psitilde_cs
            const double psitilde_cs_00_0 = 1.0;
            const double psitilde_cs_00_1 = 1 + 2*z;
            const double psitilde_cs_01_0 = 1.0;
            const double psitilde_cs_10_0 = 1.0;
    
            // Compute basisvalues
            const double basisvalues[4] =         \
            {psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_0*0.8660254037844,\
             psitilde_a_1*scalings_y_1*psitilde_bs_1_0*scalings_z_1*psitilde_cs_10_0*2.738612787526,\
             psitilde_a_0*scalings_y_0*psitilde_bs_0_1*scalings_z_1*psitilde_cs_01_0*1.581138830084,\
             psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_1*1.11803398875};
    
            // Compute value(s)
            values[0] = 0.0;
            for (unsigned int j = 0; j < 4; j++)
            {
              values[0] += coefficients0[dof][j]*basisvalues[j];
            }
          }
          else
          {
            values[0] = 0.0;
          }
          break;
        }
        case 1:
        {
          if (4 <= i and i <= 7)
          {
            // Compute local degree of freedom
            const static unsigned int dof = i - 4;
    
            // Table(s) of coefficients
            const static double coefficients0[4][4] =         \
            {{0.2886751345948, -0.1825741858351, -0.1054092553389, -0.07453559924999},
            {0.2886751345948, 0.1825741858351, -0.1054092553389, -0.07453559924999},
            {0.2886751345948, 0, 0.2108185106779, -0.07453559924999},
            {0.2886751345948, 0, 0, 0.22360679775}};
    
            // Generate scalings
            const double scalings_y_0 = 1.0;
            const double scalings_y_1 = scalings_y_0*(0.5 - 0.5 * y);
            const double scalings_z_0 = 1.0;
            const double scalings_z_1 = scalings_z_0*(0.5 - 0.5 * z);
    
            // Compute psitilde_a
            const double psitilde_a_0 = 1.0;
            const double psitilde_a_1 = 1*x;
    
            // Compute psitilde_bs
            const double psitilde_bs_0_0 = 1.0;
            const double psitilde_bs_0_1 = 0.5 + 1.5*y;
            const double psitilde_bs_1_0 = 1.0;
    
            // Compute psitilde_cs
            const double psitilde_cs_00_0 = 1.0;
            const double psitilde_cs_00_1 = 1 + 2*z;
            const double psitilde_cs_01_0 = 1.0;
            const double psitilde_cs_10_0 = 1.0;
    
            // Compute basisvalues
            const double basisvalues[4] =         \
            {psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_0*0.8660254037844,\
             psitilde_a_1*scalings_y_1*psitilde_bs_1_0*scalings_z_1*psitilde_cs_10_0*2.738612787526,\
             psitilde_a_0*scalings_y_0*psitilde_bs_0_1*scalings_z_1*psitilde_cs_01_0*1.581138830084,\
             psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_1*1.11803398875};
    
            // Compute value(s)
            values[1] = 0.0;
            for (unsigned int j = 0; j < 4; j++)
            {
              values[1] += coefficients0[dof][j]*basisvalues[j];
            }
          }
          else
          {
            values[1] = 0.0;
          }
          break;
        }
        case 2:
        {
          if (8 <= i and i <= 11)
          {
            // Compute local degree of freedom
            const static unsigned int dof = i - 8;
    
            // Table(s) of coefficients
            const static double coefficients0[4][4] =         \
            {{0.2886751345948, -0.1825741858351, -0.1054092553389, -0.07453559924999},
            {0.2886751345948, 0.1825741858351, -0.1054092553389, -0.07453559924999},
            {0.2886751345948, 0, 0.2108185106779, -0.07453559924999},
            {0.2886751345948, 0, 0, 0.22360679775}};
    
            // Generate scalings
            const double scalings_y_0 = 1.0;
            const double scalings_y_1 = scalings_y_0*(0.5 - 0.5 * y);
            const double scalings_z_0 = 1.0;
            const double scalings_z_1 = scalings_z_0*(0.5 - 0.5 * z);
    
            // Compute psitilde_a
            const double psitilde_a_0 = 1.0;
            const double psitilde_a_1 = 1*x;
    
            // Compute psitilde_bs
            const double psitilde_bs_0_0 = 1.0;
            const double psitilde_bs_0_1 = 0.5 + 1.5*y;
            const double psitilde_bs_1_0 = 1.0;
    
            // Compute psitilde_cs
            const double psitilde_cs_00_0 = 1.0;
            const double psitilde_cs_00_1 = 1 + 2*z;
            const double psitilde_cs_01_0 = 1.0;
            const double psitilde_cs_10_0 = 1.0;
    
            // Compute basisvalues
            const double basisvalues[4] =         \
            {psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_0*0.8660254037844,\
             psitilde_a_1*scalings_y_1*psitilde_bs_1_0*scalings_z_1*psitilde_cs_10_0*2.738612787526,\
             psitilde_a_0*scalings_y_0*psitilde_bs_0_1*scalings_z_1*psitilde_cs_01_0*1.581138830084,\
             psitilde_a_0*scalings_y_0*psitilde_bs_0_0*scalings_z_0*psitilde_cs_00_1*1.11803398875};
    
            // Compute value(s)
            values[2] = 0.0;
            for (unsigned int j = 0; j < 4; j++)
            {
              values[2] += coefficients0[dof][j]*basisvalues[j];
            }
          }
          else
          {
            values[2] = 0.0;
          }
          break;
        }
      }
    }
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    double values[3];
    double coordinates[3];
    
    // Nodal coordinates on reference cell
    static double X[12][3] = {{0, 0, 0}, {1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}, {1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}, {1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
    
    // Components for each dof
    static unsigned int components[12] = {0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2};
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Evaluate basis functions for affine mapping
    const double w0 = 1.0 - X[i][0] - X[i][1] - X[i][2];
    const double w1 = X[i][0];
    const double w2 = X[i][1];
    const double w3 = X[i][2];
    
    // Compute affine mapping x = F(X)
    coordinates[0] = w0*x[0][0] + w1*x[1][0] + w2*x[2][0] + w3*x[3][0];
    coordinates[0] = w0*x[0][1] + w1*x[1][1] + w2*x[2][1] + w3*x[3][1];
    coordinates[0] = w0*x[0][2] + w1*x[1][2] + w2*x[2][2] + w3*x[3][2];
    
    // Evaluate function at coordinates
    f.evaluate(values, coordinates, c);
    
    // Pick component for evaluation
    return values[components[i]];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
    vertex_values[4] = dof_values[4];
    vertex_values[5] = dof_values[5];
    vertex_values[6] = dof_values[6];
    vertex_values[7] = dof_values[7];
    vertex_values[8] = dof_values[8];
    vertex_values[9] = dof_values[9];
    vertex_values[10] = dof_values[10];
    vertex_values[11] = dof_values[11];
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 3;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch ( i )
    {
    case 0:
      return new ffc_23_finite_element_0_0();
      break;
    case 1:
      return new ffc_23_finite_element_0_1();
      break;
    case 2:
      return new ffc_23_finite_element_0_2();
      break;
    }
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_23_dof_map_0_0: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  ffc_23_dof_map_0_0() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_23_dof_map_0_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for Discontinuous Lagrange finite element of degree 1 on a tetrahedron";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return false;
      break;
    case 2:
      return false;
      break;
    case 3:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 4*m.num_entities[3];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 4;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 4*c.entity_indices[3][0];
    dofs[1] = 4*c.entity_indices[3][0] + 1;
    dofs[2] = 4*c.entity_indices[3][0] + 2;
    dofs[3] = 4*c.entity_indices[3][0] + 3;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   const ufc::mesh& m,
                                   const ufc::cell& c,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      
      break;
    case 1:
      
      break;
    case 2:
      
      break;
    case 3:
      
      break;
    }
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double **coordinates,
                                    const ufc::mesh& m,
                                    const ufc::cell& c) const
  {
    // Not implemented
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    // Not implemented
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    // Not implemented
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_23_dof_map_0_1: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  ffc_23_dof_map_0_1() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_23_dof_map_0_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for Discontinuous Lagrange finite element of degree 1 on a tetrahedron";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return false;
      break;
    case 2:
      return false;
      break;
    case 3:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 4*m.num_entities[3];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 4;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 4*c.entity_indices[3][0];
    dofs[1] = 4*c.entity_indices[3][0] + 1;
    dofs[2] = 4*c.entity_indices[3][0] + 2;
    dofs[3] = 4*c.entity_indices[3][0] + 3;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   const ufc::mesh& m,
                                   const ufc::cell& c,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      
      break;
    case 1:
      
      break;
    case 2:
      
      break;
    case 3:
      
      break;
    }
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double **coordinates,
                                    const ufc::mesh& m,
                                    const ufc::cell& c) const
  {
    // Not implemented
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    // Not implemented
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    // Not implemented
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_23_dof_map_0_2: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  ffc_23_dof_map_0_2() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_23_dof_map_0_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for Discontinuous Lagrange finite element of degree 1 on a tetrahedron";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return false;
      break;
    case 2:
      return false;
      break;
    case 3:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 4*m.num_entities[3];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 4;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 4*c.entity_indices[3][0];
    dofs[1] = 4*c.entity_indices[3][0] + 1;
    dofs[2] = 4*c.entity_indices[3][0] + 2;
    dofs[3] = 4*c.entity_indices[3][0] + 3;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   const ufc::mesh& m,
                                   const ufc::cell& c,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      
      break;
    case 1:
      
      break;
    case 2:
      
      break;
    case 3:
      
      break;
    }
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double **coordinates,
                                    const ufc::mesh& m,
                                    const ufc::cell& c) const
  {
    // Not implemented
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    // Not implemented
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    // Not implemented
    return 0;
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_23_dof_map_0: public ufc::dof_map
{
private:

  unsigned int __global_dimension;

public:

  /// Constructor
  ffc_23_dof_map_0() : ufc::dof_map()
  {
    __global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_23_dof_map_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dof map
  virtual const char* signature() const
  {
    return "FFC dof map for Mixed finite element: [Discontinuous Lagrange finite element of degree 1 on a tetrahedron, Discontinuous Lagrange finite element of degree 1 on a tetrahedron, Discontinuous Lagrange finite element of degree 1 on a tetrahedron]";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch ( d )
    {
    case 0:
      return false;
      break;
    case 1:
      return false;
      break;
    case 2:
      return false;
      break;
    case 3:
      return true;
      break;
    }
    return false;
  }

  /// Initialize dof map for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    __global_dimension = 12*m.num_entities[3];
    return false;
  }

  /// Initialize dof map for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dof map for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return __global_dimension;
  }

  /// Return the dimension of the local finite element function space
  virtual unsigned int local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 4*c.entity_indices[3][0];
    dofs[1] = 4*c.entity_indices[3][0] + 1;
    dofs[2] = 4*c.entity_indices[3][0] + 2;
    dofs[3] = 4*c.entity_indices[3][0] + 3;
    unsigned int offset = 4*m.num_entities[3];
    dofs[4] = offset + 4*c.entity_indices[3][0];
    dofs[5] = offset + 4*c.entity_indices[3][0] + 1;
    dofs[6] = offset + 4*c.entity_indices[3][0] + 2;
    dofs[7] = offset + 4*c.entity_indices[3][0] + 3;
    offset = offset + 4*m.num_entities[3];
    dofs[8] = offset + 4*c.entity_indices[3][0];
    dofs[9] = offset + 4*c.entity_indices[3][0] + 1;
    dofs[10] = offset + 4*c.entity_indices[3][0] + 2;
    dofs[11] = offset + 4*c.entity_indices[3][0] + 3;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   const ufc::mesh& m,
                                   const ufc::cell& c,
                                   unsigned int facet) const
  {
    switch ( facet )
    {
    case 0:
      
      break;
    case 1:
      
      break;
    case 2:
      
      break;
    case 3:
      
      break;
    }
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double **coordinates,
                                    const ufc::mesh& m,
                                    const ufc::cell& c) const
  {
    // Not implemented
  }

  /// Return the number of sub dof maps (for a mixed element)
  virtual unsigned int num_sub_dof_maps() const
  {
    // Not implemented
    return 0;
  }

  /// Create a new dof_map for sub dof map i (for a mixed element)
  virtual ufc::dof_map* create_sub_dof_map(unsigned int i) const
  {
    // Not implemented
    return 0;
  }

};

#endif
