// Automatically generated by FFC, the FEniCS Form Compiler, version 0.3.1.
// For further information, go to http://www/fenics.org/ffc/.
// Licensed under the GNU GPL Version 2.

#ifndef __POISSON2D_4_H
#define __POISSON2D_4_H

#include <dolfin/Mesh.h>
#include <dolfin/Cell.h>
#include <dolfin/Point.h>
#include <dolfin/Vector.h>
#include <dolfin/AffineMap.h>
#include <dolfin/FiniteElement.h>
#include <dolfin/FiniteElementSpec.h>
#include <dolfin/LinearForm.h>
#include <dolfin/BilinearForm.h>

namespace dolfin { namespace Poisson2D_4 {

/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class BilinearForm : public dolfin::BilinearForm
{
public:
  
  class TestElement : public dolfin::FiniteElement
  {
  public:
  
    TestElement() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      // Element is scalar, don't need to initialize tensordims
  
      // Element is simple, don't need to initialize subelements
    }
  
    ~TestElement()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 15;
    }
  
    inline unsigned int shapedim() const
    {
      return 2;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_error("Element is scalar.");
      return 0;
    }
  
    inline unsigned int elementdim() const
    {
      return 1;
    }
  
    inline unsigned int rank() const
    {
      return 0;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      static unsigned int edge_reordering_0[2][3] = {{0, 1, 2}, {2, 1, 0}};
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      int alignment = cell.edgeAlignment(0);
      int offset = mesh.numVertices();
      nodes[3] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][0];
      nodes[4] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][1];
      nodes[5] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(1);
      nodes[6] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][0];
      nodes[7] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][1];
      nodes[8] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(2);
      nodes[9] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][0];
      nodes[10] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][1];
      nodes[11] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][2];
      offset = offset + 3*mesh.numEdges();
      nodes[12] = offset + 3*cell.id() + 0;
      nodes[13] = offset + 3*cell.id() + 1;
      nodes[14] = offset + 3*cell.id() + 2;
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00);
      points[3] = map(7.500000000000000e-01, 2.500000000000000e-01);
      points[4] = map(5.000000000000000e-01, 5.000000000000000e-01);
      points[5] = map(2.500000000000000e-01, 7.500000000000000e-01);
      points[6] = map(0.000000000000000e+00, 7.500000000000000e-01);
      points[7] = map(0.000000000000000e+00, 5.000000000000000e-01);
      points[8] = map(0.000000000000000e+00, 2.500000000000000e-01);
      points[9] = map(2.500000000000000e-01, 0.000000000000000e+00);
      points[10] = map(5.000000000000000e-01, 0.000000000000000e+00);
      points[11] = map(7.500000000000000e-01, 0.000000000000000e+00);
      points[12] = map(2.500000000000000e-01, 2.500000000000000e-01);
      points[13] = map(5.000000000000000e-01, 2.500000000000000e-01);
      points[14] = map(2.500000000000000e-01, 5.000000000000000e-01);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 0;
      components[5] = 0;
      components[6] = 0;
      components[7] = 0;
      components[8] = 0;
      components[9] = 0;
      components[10] = 0;
      components[11] = 0;
      components[12] = 0;
      components[13] = 0;
      components[14] = 0;
    }
  
    void vertexeval(real values[], unsigned int vertex, const real x[], const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      values[0] = x[vertex];
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *this;
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *this;
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("Lagrange", "triangle", 4);
      return s;
    }
    
  private:
  
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
    
  class TrialElement : public dolfin::FiniteElement
  {
  public:
  
    TrialElement() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      // Element is scalar, don't need to initialize tensordims
  
      // Element is simple, don't need to initialize subelements
    }
  
    ~TrialElement()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 15;
    }
  
    inline unsigned int shapedim() const
    {
      return 2;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_error("Element is scalar.");
      return 0;
    }
  
    inline unsigned int elementdim() const
    {
      return 1;
    }
  
    inline unsigned int rank() const
    {
      return 0;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      static unsigned int edge_reordering_0[2][3] = {{0, 1, 2}, {2, 1, 0}};
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      int alignment = cell.edgeAlignment(0);
      int offset = mesh.numVertices();
      nodes[3] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][0];
      nodes[4] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][1];
      nodes[5] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(1);
      nodes[6] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][0];
      nodes[7] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][1];
      nodes[8] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(2);
      nodes[9] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][0];
      nodes[10] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][1];
      nodes[11] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][2];
      offset = offset + 3*mesh.numEdges();
      nodes[12] = offset + 3*cell.id() + 0;
      nodes[13] = offset + 3*cell.id() + 1;
      nodes[14] = offset + 3*cell.id() + 2;
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00);
      points[3] = map(7.500000000000000e-01, 2.500000000000000e-01);
      points[4] = map(5.000000000000000e-01, 5.000000000000000e-01);
      points[5] = map(2.500000000000000e-01, 7.500000000000000e-01);
      points[6] = map(0.000000000000000e+00, 7.500000000000000e-01);
      points[7] = map(0.000000000000000e+00, 5.000000000000000e-01);
      points[8] = map(0.000000000000000e+00, 2.500000000000000e-01);
      points[9] = map(2.500000000000000e-01, 0.000000000000000e+00);
      points[10] = map(5.000000000000000e-01, 0.000000000000000e+00);
      points[11] = map(7.500000000000000e-01, 0.000000000000000e+00);
      points[12] = map(2.500000000000000e-01, 2.500000000000000e-01);
      points[13] = map(5.000000000000000e-01, 2.500000000000000e-01);
      points[14] = map(2.500000000000000e-01, 5.000000000000000e-01);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 0;
      components[5] = 0;
      components[6] = 0;
      components[7] = 0;
      components[8] = 0;
      components[9] = 0;
      components[10] = 0;
      components[11] = 0;
      components[12] = 0;
      components[13] = 0;
      components[14] = 0;
    }
  
    void vertexeval(real values[], unsigned int vertex, const real x[], const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      values[0] = x[vertex];
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *this;
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *this;
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("Lagrange", "triangle", 4);
      return s;
    }
    
  private:
  
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
  
  BilinearForm() : dolfin::BilinearForm(0)
  {
    // Create finite element for test space
    _test = new TestElement();

    // Create finite element for trial space
    _trial = new TrialElement();
  }

  void eval(real block[], const AffineMap& map) const
  {
    // Compute geometry tensors
    const real G0_0_0 = map.det*(map.g00*map.g00 + map.g01*map.g01);
    const real G0_0_1 = map.det*(map.g00*map.g10 + map.g01*map.g11);
    const real G0_1_0 = map.det*(map.g10*map.g00 + map.g11*map.g01);
    const real G0_1_1 = map.det*(map.g10*map.g10 + map.g11*map.g11);

    // Compute element tensor
    block[108] = -1.523809523809537e-01*G0_0_0 + -4.232804232804306e-02*G0_0_1 + -4.232804232804296e-02*G0_1_0;
    block[192] = block[108] + 5.841269841269837e+00*G0_0_0 + 2.886772486772484e+00*G0_0_1 + 2.886772486772483e+00*G0_1_0 + 5.688888888888887e+00*G0_1_1;
    block[52] = block[108];
    block[60] = -block[108] + -1.100529100529116e-01*G0_0_0 + 4.232804232804185e-02*G0_1_1;
    block[7] = block[60] + 4.253968253968248e-01*G0_0_1 + 4.253968253968248e-01*G0_1_1;
    block[10] = block[60] + 4.253968253968254e-01*G0_0_0 + 4.253968253968251e-01*G0_1_0;
    block[157] = block[108] + 2.031746031746044e-01*G0_0_0 + -1.037037037037025e-01*G0_0_1 + -1.037037037037022e-01*G0_1_0 + 5.079365079365238e-02*G0_1_1;
    block[100] = -block[108] + -1.523809523809538e-01*G0_0_0 + -6.772486772486880e-02*G0_1_1;
    block[99] = block[100] + 5.925925925925855e-02*G0_0_1 + 5.925925925925912e-02*G0_1_0 + -6.772486772486738e-02*G0_1_1;
    block[125] = block[99] + -3.386243386243368e-01*G0_0_0 + -3.386243386243369e-01*G0_0_1 + -3.386243386243378e-01*G0_1_0;
    block[83] = block[125];
    block[158] = block[100] + 1.015873015873021e-01*G0_0_0 + -4.063492063492065e-01*G0_0_1 + -4.063492063492053e-01*G0_1_0;
    block[170] = -block[99] + -4.740740740740742e-01*G0_1_1;
    block[186] = -block[99] + -2.370370370370365e-01*G0_0_1 + -2.370370370370363e-01*G0_1_0;
    block[4] = block[60];
    block[70] = block[157] + 3.428571428571424e-01*G0_0_1 + 3.428571428571413e-01*G0_1_0 + 3.428571428571416e-01*G0_1_1;
    block[86] = block[170];
    block[163] = -block[158] + -2.040211640211637e+00*G0_0_1 + -2.040211640211635e+00*G0_1_0 + -2.912169312169309e+00*G0_1_1;
    block[138] = block[125] + 2.031746031746031e-01*G0_0_0 + -2.031746031746014e-01*G0_1_1;
    block[90] = -block[60] + -2.031746031746028e-01*G0_1_0 + -2.031746031746031e-01*G0_1_1;
    block[165] = -block[60] + -2.031746031746033e-01*G0_0_0 + -2.031746031746036e-01*G0_0_1;
    block[205] = block[163];
    block[132] = -block[99] + -2.438095238095235e+00*G0_0_0 + -1.049735449735448e+00*G0_0_1 + -1.049735449735450e+00*G0_1_0;
    block[103] = block[186];
    block[113] = block[158] + -7.619047619047603e-01*G0_0_0 + -1.117460317460316e+00*G0_1_0 + -1.879365079365075e+00*G0_1_1;
    block[195] = -1.999999999999990e+00*block[60];
    block[188] = block[132];
    block[208] = block[192];
    block[14] = block[195];
    block[129] = block[99] + -1.354497354497352e-01*G0_0_0 + 8.126984126984117e-01*G0_0_1 + 8.126984126984120e-01*G0_1_0;
    block[104] = -block[99] + 1.388359788359786e+00*G0_0_1 + 1.388359788359785e+00*G0_1_0;
    block[89] = -block[104] + -2.302645502645504e+00*G0_1_1;
    block[215] = block[89];
    block[198] = -block[104] + -2.438095238095233e+00*G0_0_0 + 1.354497354497371e-01*G0_1_1;
    block[11] = -block[60] + -2.031746031746033e-01*G0_0_0 + -2.031746031746031e-01*G0_1_0;
    block[126] = -block[125] + 5.417989417989414e-01*G0_0_1 + 8.804232804232793e-01*G0_1_1;
    block[142] = block[158] + -1.693121693121690e-01*G0_0_0 + 1.693121693121709e-01*G0_1_1;
    block[117] = -block[142] + 3.386243386243382e-01*G0_0_0 + 1.210582010582010e+00*G0_0_1 + 1.210582010582009e+00*G0_1_0;
    block[202] = block[117] + -1.625396825396823e+00*G0_0_1 + -1.625396825396824e+00*G0_1_0;
    block[110] = block[142] + 8.296296296296274e-01*G0_0_0 + 8.296296296296276e-01*G0_0_1 + 8.296296296296279e-01*G0_1_0;
    block[97] = -block[110] + -1.117460317460316e+00*G0_1_0 + -1.845502645502643e+00*G0_1_1;
    block[111] = -block[110] + -1.117460317460315e+00*G0_0_1 + -1.845502645502643e+00*G0_1_1;
    block[65] = -block[110] + 1.286772486772486e+00*G0_0_1 + 1.693121693121675e-01*G0_1_0 + -5.587301587301587e-01*G0_1_1;
    block[164] = block[202] + -5.079365079365086e-01*G0_0_0 + 5.079365079365096e-01*G0_1_1;
    block[214] = block[164] + -2.742857142857138e+00*G0_0_0 + -1.117460317460315e+00*G0_0_1 + -1.117460317460318e+00*G0_1_0;
    block[199] = block[214] + 3.250793650793645e+00*G0_0_0 + -3.250793650793647e+00*G0_1_1;
    block[72] = block[117] + -1.117460317460314e+00*G0_0_1 + -1.117460317460316e+00*G0_1_0 + 5.079365079365088e-01*G0_1_1;
    block[153] = block[110] + -6.603174603174605e-01*G0_0_0 + 6.603174603174573e-01*G0_1_1;
    block[175] = block[111] + -1.185185185185184e+00*G0_0_0 + 1.185185185185186e+00*G0_1_1;
    block[94] = -block[65] + 1.117460317460318e+00*G0_0_1 + -7.280423280423263e-01*G0_1_1;
    block[79] = block[65] + -1.117460317460317e+00*G0_0_1 + 1.117460317460317e+00*G0_1_0;
    block[169] = block[94] + -8.296296296296279e-01*G0_0_0 + 8.296296296296286e-01*G0_1_1;
    block[154] = block[70];
    block[101] = block[99] + 1.354497354497355e-01*G0_1_1;
    block[31] = block[101] + -1.015873015873010e-01*G0_0_1 + -1.582010582010585e-01*G0_1_0;
    block[181] = block[31] + -8.465608465608533e-02*G0_0_0 + 5.661375661375635e-02*G0_1_0;
    block[21] = block[181] + 1.269841269841276e-01*G0_0_0;
    block[35] = block[31] + 8.354497354497349e-01*G0_1_0 + 1.269841269841268e-01*G0_1_1;
    block[26] = block[181] + -5.671957671957656e-01*G0_0_0 + -7.788359788359775e-01*G0_0_1;
    block[135] = block[35] + -6.518518518518515e-01*G0_0_0 + -6.518518518518509e-01*G0_0_1 + -6.518518518518508e-01*G0_1_0;
    block[211] = block[181];
    block[16] = block[181] + 4.576719576719578e-01*G0_0_0;
    block[36] = -block[35] + -5.248677248677244e-01*G0_1_1;
    block[1] = -block[31] + 5.661375661375651e-02*G0_0_0;
    block[27] = block[181];
    block[46] = block[31] + 1.269841269841266e-01*G0_0_0 + 8.354497354497341e-01*G0_1_0;
    block[144] = block[35] + 1.828571428571427e+00*G0_0_0 + 7.788359788359770e-01*G0_0_1 + 1.701587301587300e+00*G0_1_1;
    block[176] = block[144] + 2.708994708994700e-01*G0_0_1 + 2.708994708994699e-01*G0_1_0 + 2.708994708994690e-01*G0_1_1;
    block[80] = block[176] + 2.708994708994723e-01*G0_0_0 + -2.708994708994679e-01*G0_1_1;
    block[56] = -block[176] + 1.693121693121692e+00*G0_0_0;
    block[76] = -block[21] + 2.031746031746029e-01*G0_1_0;
    block[20] = -block[21] + 2.031746031746030e-01*G0_0_1;
    block[47] = block[20] + 4.232804232804225e-02*G0_0_0 + -4.232804232804278e-02*G0_1_1;
    block[122] = -block[47] + -2.878306878306879e-01*G0_1_1;
    block[41] = -block[47] + 2.031746031746023e-01*G0_0_1;
    block[212] = block[41] + -1.269841269841263e-01*G0_1_1;
    block[42] = block[212];
    block[182] = block[212];
    block[51] = -block[101] + -3.386243386243369e-01*G0_0_0;
    block[32] = block[41] + 3.306878306878301e-01*G0_1_1;
    block[61] = block[21] + -4.253968253968248e-01*G0_1_0;
    block[106] = block[21];
    block[187] = block[117];
    block[174] = -block[138] + 8.804232804232808e-01*G0_0_0 + 5.417989417989408e-01*G0_0_1;
    block[216] = block[104];
    block[201] = block[186];
    block[5] = block[60];
    block[15] = block[1] + 5.661375661375667e-02*G0_0_1 + -5.661375661375668e-02*G0_1_0;
    block[8] = block[135] + 7.788359788359784e-01*G0_0_0 + -7.788359788359783e-01*G0_1_1;
    block[71] = block[169];
    block[50] = -block[170] + 3.386243386243368e-01*G0_0_0 + -5.417989417989412e-01*G0_0_1;
    block[123] = -block[101] + -2.031746031746021e-01*G0_0_0;
    block[85] = -block[100] + -2.201058201058210e-01*G0_1_1;
    block[66] = block[94];
    block[160] = block[108] + 3.111111111111109e+00*G0_0_0 + 1.521693121693119e+00*G0_0_1 + 1.521693121693120e+00*G0_1_0 + 2.450793650793647e+00*G0_1_1;
    block[137] = block[41];
    block[91] = block[21];
    block[82] = block[110];
    block[168] = block[56];
    block[109] = block[70] + 3.428571428571419e-01*G0_0_0 + -3.428571428571431e-01*G0_1_1;
    block[184] = block[72];
    block[18] = -block[26] + -5.248677248677243e-01*G0_0_0;
    block[45] = block[60];
    block[143] = block[129];
    block[120] = block[8] + 7.788359788359775e-01*G0_0_1 + -7.788359788359775e-01*G0_1_0;
    block[88] = -block[186] + 9.481481481481491e-01*G0_1_1;
    block[193] = -block[88] + -4.063492063492056e+00*G0_0_0 + -1.693121693121689e+00*G0_0_1 + -1.693121693121690e+00*G0_1_0;
    block[222] = block[193] + 3.250793650793646e+00*G0_0_0 + -3.250793650793654e+00*G0_1_1;
    block[92] = block[36] + -7.788359788359782e-01*G0_0_1 + 7.788359788359782e-01*G0_1_0;
    block[116] = -block[108] + -2.201058201058216e-01*G0_0_0;
    block[139] = block[116] + -1.523809523809522e-01*G0_0_1 + -1.523809523809529e-01*G0_1_0 + -1.523809523809519e-01*G0_1_1;
    block[68] = block[139] + -8.465608465608496e-02*G0_0_0 + 8.465608465608401e-02*G0_1_1;
    block[189] = block[132] + 2.573544973544970e+00*G0_0_0 + -2.573544973544974e+00*G0_1_1;
    block[207] = block[193];
    block[55] = block[153];
    block[29] = block[181];
    block[130] = block[158];
    block[73] = block[199];
    block[43] = block[212];
    block[146] = -block[138] + 8.804232804232808e-01*G0_0_0 + 5.417989417989422e-01*G0_1_0;
    block[75] = block[60];
    block[150] = block[60] + 4.253968253968256e-01*G0_0_0 + 4.253968253968254e-01*G0_0_1;
    block[178] = -block[198] + -2.302645502645499e+00*G0_0_0;
    block[119] = block[163] + -2.742857142857141e+00*G0_0_0 + 2.742857142857142e+00*G0_1_1;
    block[220] = block[164];
    block[197] = block[212];
    block[194] = block[222];
    block[19] = block[21] + -4.253968253968249e-01*G0_0_1;
    block[25] = -block[19] + 5.100529100529094e-01*G0_0_0;
    block[12] = block[195];
    block[54] = block[138];
    block[33] = -block[41] + 2.031746031746021e-01*G0_1_0;
    block[38] = -block[33] + -2.878306878306879e-01*G0_1_1;
    block[24] = -block[20] + -2.878306878306874e-01*G0_0_0;
    block[127] = block[113] + -1.117460317460317e+00*G0_0_1 + 1.117460317460317e+00*G0_1_0;
    block[159] = block[127] + -1.286772486772488e+00*G0_0_0 + 1.286772486772486e+00*G0_1_1;
    block[62] = -block[47] + -2.222222222222225e-01*G0_0_1;
    block[107] = -block[62] + 5.100529100529088e-01*G0_1_1;
    block[44] = block[212];
    block[141] = block[99];
    block[95] = -block[80] + 1.693121693121693e+00*G0_1_1;
    block[78] = -block[170] + 3.386243386243368e-01*G0_0_0 + -5.417989417989407e-01*G0_1_0;
    block[172] = block[116];
    block[155] = block[85];
    block[105] = block[60] + 4.253968253968244e-01*G0_1_0 + 4.253968253968249e-01*G0_1_1;
    block[98] = -block[125] + 5.417989417989408e-01*G0_1_0 + 8.804232804232793e-01*G0_1_1;
    block[180] = block[195];
    block[173] = block[101] + -1.354497354497359e-01*G0_0_0;
    block[149] = -block[173] + 5.756613756613751e-01*G0_0_1 + 5.756613756613758e-01*G0_1_0 + 8.126984126984134e-01*G0_1_1;
    block[191] = -block[173] + -2.370370370370338e-01*G0_0_1 + -2.370370370370362e-01*G0_1_0;
    block[57] = -block[191] + 9.481481481481474e-01*G0_0_0;
    block[218] = block[149] + 6.772486772486761e-01*G0_0_0 + -6.772486772486798e-01*G0_1_1;
    block[148] = block[149];
    block[213] = block[57];
    block[204] = block[149];
    block[133] = block[218];
    block[179] = block[191];
    block[219] = block[149];
    block[183] = block[57];
    block[118] = block[202];
    block[217] = block[119];
    block[200] = block[88];
    block[6] = -block[60] + -2.031746031746031e-01*G0_0_1 + -2.031746031746031e-01*G0_1_1;
    block[22] = block[21];
    block[9] = block[135] + 7.788359788359784e-01*G0_0_1 + -7.788359788359784e-01*G0_1_0;
    block[49] = block[65] + 1.015873015873009e-01*G0_0_0 + -1.015873015873023e-01*G0_1_1;
    block[34] = block[41] + -4.253968253968248e-01*G0_1_0;
    block[37] = -block[34] + 5.100529100529088e-01*G0_1_1;
    block[147] = block[189];
    block[124] = block[68];
    block[84] = -block[99] + -3.386243386243390e-01*G0_1_1;
    block[67] = block[109];
    block[161] = block[97] + -1.185185185185184e+00*G0_0_0 + 1.185185185185186e+00*G0_1_1;
    block[136] = -block[76] + -2.878306878306874e-01*G0_0_0;
    block[96] = block[80];
    block[81] = block[95];
    block[167] = block[41];
    block[156] = block[100];
    block[112] = block[160] + -5.079365079365101e-01*G0_0_0 + 5.079365079365061e-01*G0_1_1;
    block[223] = -block[88] + -8.126984126984113e-01*G0_0_0 + 1.557671957671956e+00*G0_0_1 + 1.557671957671954e+00*G0_1_0;
    block[185] = block[88];
    block[210] = block[195];
    block[203] = block[218];
    block[3] = block[60];
    block[59] = block[57];
    block[17] = -block[15] + 5.661375661375651e-02*G0_0_0;
    block[2] = -block[17] + 5.661375661375673e-02*G0_1_1;
    block[134] = block[218];
    block[69] = block[139];
    block[48] = block[176];
    block[39] = block[41];
    block[121] = block[21];
    block[87] = block[88];
    block[64] = block[160] + -5.079365079365092e-01*G0_0_0 + -5.079365079365066e-01*G0_0_1 + -5.079365079365068e-01*G0_1_0;
    block[162] = block[117] + -5.079365079365082e-01*G0_0_0 + 5.079365079365088e-01*G0_1_1;
    block[93] = block[51];
    block[166] = -block[46] + -5.248677248677243e-01*G0_0_0;
    block[115] = block[157];
    block[224] = block[192];
    block[190] = block[162];
    block[206] = block[178];
    block[0] = 8.812500000000032e+00*block[60];
    block[58] = block[198];
    block[28] = block[181];
    block[131] = block[173];
    block[74] = block[214];
    block[40] = block[41];
    block[145] = block[113] + -1.286772486772488e+00*G0_0_0 + 1.286772486772486e+00*G0_1_1;
    block[151] = -block[61] + 5.100529100529094e-01*G0_0_0;
    block[102] = block[186];
    block[177] = block[191];
    block[114] = block[142];
    block[221] = block[191];
    block[196] = block[181];
    block[209] = block[223];
    block[13] = block[195];
    block[53] = block[123];
    block[30] = -block[31] + 5.661375661375673e-02*G0_1_1;
    block[23] = block[21];
    block[128] = block[144];
    block[63] = block[79] + 1.015873015873008e-01*G0_0_0 + -1.015873015873024e-01*G0_1_1;
    block[140] = block[84];
    block[77] = -block[92] + -5.248677248677244e-01*G0_1_1;
    block[171] = block[101];
    block[152] = block[41];
  }

  // No contribution from the boundary
  void eval(real block[], const AffineMap& map, unsigned int boundary) const {}   

};

/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class LinearForm : public dolfin::LinearForm
{
public:
  
  class TestElement : public dolfin::FiniteElement
  {
  public:
  
    TestElement() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      // Element is scalar, don't need to initialize tensordims
  
      // Element is simple, don't need to initialize subelements
    }
  
    ~TestElement()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 15;
    }
  
    inline unsigned int shapedim() const
    {
      return 2;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_error("Element is scalar.");
      return 0;
    }
  
    inline unsigned int elementdim() const
    {
      return 1;
    }
  
    inline unsigned int rank() const
    {
      return 0;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      static unsigned int edge_reordering_0[2][3] = {{0, 1, 2}, {2, 1, 0}};
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      int alignment = cell.edgeAlignment(0);
      int offset = mesh.numVertices();
      nodes[3] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][0];
      nodes[4] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][1];
      nodes[5] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(1);
      nodes[6] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][0];
      nodes[7] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][1];
      nodes[8] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(2);
      nodes[9] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][0];
      nodes[10] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][1];
      nodes[11] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][2];
      offset = offset + 3*mesh.numEdges();
      nodes[12] = offset + 3*cell.id() + 0;
      nodes[13] = offset + 3*cell.id() + 1;
      nodes[14] = offset + 3*cell.id() + 2;
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00);
      points[3] = map(7.500000000000000e-01, 2.500000000000000e-01);
      points[4] = map(5.000000000000000e-01, 5.000000000000000e-01);
      points[5] = map(2.500000000000000e-01, 7.500000000000000e-01);
      points[6] = map(0.000000000000000e+00, 7.500000000000000e-01);
      points[7] = map(0.000000000000000e+00, 5.000000000000000e-01);
      points[8] = map(0.000000000000000e+00, 2.500000000000000e-01);
      points[9] = map(2.500000000000000e-01, 0.000000000000000e+00);
      points[10] = map(5.000000000000000e-01, 0.000000000000000e+00);
      points[11] = map(7.500000000000000e-01, 0.000000000000000e+00);
      points[12] = map(2.500000000000000e-01, 2.500000000000000e-01);
      points[13] = map(5.000000000000000e-01, 2.500000000000000e-01);
      points[14] = map(2.500000000000000e-01, 5.000000000000000e-01);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 0;
      components[5] = 0;
      components[6] = 0;
      components[7] = 0;
      components[8] = 0;
      components[9] = 0;
      components[10] = 0;
      components[11] = 0;
      components[12] = 0;
      components[13] = 0;
      components[14] = 0;
    }
  
    void vertexeval(real values[], unsigned int vertex, const real x[], const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      values[0] = x[vertex];
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *this;
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *this;
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("Lagrange", "triangle", 4);
      return s;
    }
    
  private:
  
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
    
  class FunctionElement_0 : public dolfin::FiniteElement
  {
  public:
  
    FunctionElement_0() : dolfin::FiniteElement(), tensordims(0), subelements(0)
    {
      // Element is scalar, don't need to initialize tensordims
  
      // Element is simple, don't need to initialize subelements
    }
  
    ~FunctionElement_0()
    {
      if ( tensordims ) delete [] tensordims;
      if ( subelements )
      {
        for (unsigned int i = 0; i < elementdim(); i++)
          delete subelements[i];
        delete [] subelements;
      }
    }
  
    inline unsigned int spacedim() const
    {
      return 15;
    }
  
    inline unsigned int shapedim() const
    {
      return 2;
    }
  
    inline unsigned int tensordim(unsigned int i) const
    {
      dolfin_error("Element is scalar.");
      return 0;
    }
  
    inline unsigned int elementdim() const
    {
      return 1;
    }
  
    inline unsigned int rank() const
    {
      return 0;
    }
  
    void nodemap(int nodes[], const Cell& cell, const Mesh& mesh) const
    {
      static unsigned int edge_reordering_0[2][3] = {{0, 1, 2}, {2, 1, 0}};
      nodes[0] = cell.vertexID(0);
      nodes[1] = cell.vertexID(1);
      nodes[2] = cell.vertexID(2);
      int alignment = cell.edgeAlignment(0);
      int offset = mesh.numVertices();
      nodes[3] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][0];
      nodes[4] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][1];
      nodes[5] = offset + 3*cell.edgeID(0) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(1);
      nodes[6] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][0];
      nodes[7] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][1];
      nodes[8] = offset + 3*cell.edgeID(1) + edge_reordering_0[alignment][2];
      alignment = cell.edgeAlignment(2);
      nodes[9] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][0];
      nodes[10] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][1];
      nodes[11] = offset + 3*cell.edgeID(2) + edge_reordering_0[alignment][2];
      offset = offset + 3*mesh.numEdges();
      nodes[12] = offset + 3*cell.id() + 0;
      nodes[13] = offset + 3*cell.id() + 1;
      nodes[14] = offset + 3*cell.id() + 2;
    }
  
    void pointmap(Point points[], unsigned int components[], const AffineMap& map) const
    {
      points[0] = map(0.000000000000000e+00, 0.000000000000000e+00);
      points[1] = map(1.000000000000000e+00, 0.000000000000000e+00);
      points[2] = map(0.000000000000000e+00, 1.000000000000000e+00);
      points[3] = map(7.500000000000000e-01, 2.500000000000000e-01);
      points[4] = map(5.000000000000000e-01, 5.000000000000000e-01);
      points[5] = map(2.500000000000000e-01, 7.500000000000000e-01);
      points[6] = map(0.000000000000000e+00, 7.500000000000000e-01);
      points[7] = map(0.000000000000000e+00, 5.000000000000000e-01);
      points[8] = map(0.000000000000000e+00, 2.500000000000000e-01);
      points[9] = map(2.500000000000000e-01, 0.000000000000000e+00);
      points[10] = map(5.000000000000000e-01, 0.000000000000000e+00);
      points[11] = map(7.500000000000000e-01, 0.000000000000000e+00);
      points[12] = map(2.500000000000000e-01, 2.500000000000000e-01);
      points[13] = map(5.000000000000000e-01, 2.500000000000000e-01);
      points[14] = map(2.500000000000000e-01, 5.000000000000000e-01);
      components[0] = 0;
      components[1] = 0;
      components[2] = 0;
      components[3] = 0;
      components[4] = 0;
      components[5] = 0;
      components[6] = 0;
      components[7] = 0;
      components[8] = 0;
      components[9] = 0;
      components[10] = 0;
      components[11] = 0;
      components[12] = 0;
      components[13] = 0;
      components[14] = 0;
    }
  
    void vertexeval(real values[], unsigned int vertex, const real x[], const Mesh& mesh) const
    {
      // FIXME: Temporary fix for Lagrange elements
      values[0] = x[vertex];
    }
  
    const FiniteElement& operator[] (unsigned int i) const
    {
      return *this;
    }
  
    FiniteElement& operator[] (unsigned int i)
    {
      return *this;
    }
  
    FiniteElementSpec spec() const
    {
      FiniteElementSpec s("Lagrange", "triangle", 4);
      return s;
    }
    
  private:
  
    unsigned int* tensordims;
    FiniteElement** subelements;
  
  };
  
  LinearForm(Function& w0) : dolfin::LinearForm(1)
  {
    // Create finite element for test space
    _test = new TestElement();

    // Add functions
    add(w0, new FunctionElement_0());
  }

  void eval(real block[], const AffineMap& map) const
  {
    // Compute coefficients
    const real c0_0 = c[0][0];
    const real c0_1 = c[0][1];
    const real c0_2 = c[0][2];
    const real c0_3 = c[0][3];
    const real c0_4 = c[0][4];
    const real c0_5 = c[0][5];
    const real c0_6 = c[0][6];
    const real c0_7 = c[0][7];
    const real c0_8 = c[0][8];
    const real c0_9 = c[0][9];
    const real c0_10 = c[0][10];
    const real c0_11 = c[0][11];
    const real c0_12 = c[0][12];
    const real c0_13 = c[0][13];
    const real c0_14 = c[0][14];

    // Compute geometry tensors
    const real G0_0 = map.det*c0_0;
    const real G0_1 = map.det*c0_1;
    const real G0_2 = map.det*c0_2;
    const real G0_3 = map.det*c0_3;
    const real G0_4 = map.det*c0_4;
    const real G0_5 = map.det*c0_5;
    const real G0_6 = map.det*c0_6;
    const real G0_7 = map.det*c0_7;
    const real G0_8 = map.det*c0_8;
    const real G0_9 = map.det*c0_9;
    const real G0_10 = map.det*c0_10;
    const real G0_11 = map.det*c0_11;
    const real G0_12 = map.det*c0_12;
    const real G0_13 = map.det*c0_13;
    const real G0_14 = map.det*c0_14;

    // Compute element tensor
    block[0] = 2.557319223985879e-03*G0_0 - 2.380952380952367e-04*G0_1 - 2.380952380952367e-04*G0_2 - 9.876543209876513e-04*G0_3 - 1.058201058201041e-04*G0_4 - 9.876543209876513e-04*G0_5 - 7.054673721340329e-04*G0_7 + 1.410934744268066e-03*G0_8 + 1.410934744268068e-03*G0_9 - 7.054673721340345e-04*G0_10 + 1.410934744268062e-03*G0_12 - 1.410934744268069e-03*G0_13 - 1.410934744268073e-03*G0_14;
    block[1] = -2.380952380952367e-04*G0_0 + 2.557319223985876e-03*G0_1 - 2.380952380952364e-04*G0_2 + 1.410934744268064e-03*G0_3 - 7.054673721340293e-04*G0_4 - 9.876543209876507e-04*G0_6 - 1.058201058201054e-04*G0_7 - 9.876543209876511e-04*G0_8 - 7.054673721340340e-04*G0_10 + 1.410934744268066e-03*G0_11 - 1.410934744268076e-03*G0_12 + 1.410934744268066e-03*G0_13 - 1.410934744268072e-03*G0_14;
    block[2] = -2.380952380952366e-04*G0_0 - 2.380952380952364e-04*G0_1 + 2.557319223985878e-03*G0_2 - 7.054673721340343e-04*G0_4 + 1.410934744268068e-03*G0_5 + 1.410934744268068e-03*G0_6 - 7.054673721340334e-04*G0_7 - 9.876543209876483e-04*G0_9 - 1.058201058201056e-04*G0_10 - 9.876543209876487e-04*G0_11 - 1.410934744268071e-03*G0_12 - 1.410934744268071e-03*G0_13 + 1.410934744268068e-03*G0_14;
    block[3] = -9.876543209876513e-04*G0_0 + 1.410934744268064e-03*G0_1 + 2.257495590828913e-02*G0_3 - 1.128747795414456e-02*G0_4 + 6.772486772486739e-03*G0_5 + 4.514991181657825e-03*G0_6 + 5.643738977072474e-04*G0_7 + 2.257495590828912e-03*G0_8 + 4.514991181657824e-03*G0_9 - 8.465608465608426e-03*G0_10 + 1.128747795414456e-02*G0_11 - 2.257495590828916e-03*G0_12 + 1.128747795414457e-02*G0_13 + 2.257495590828919e-03*G0_14;
    block[4] = -1.058201058201042e-04*G0_0 - 7.054673721340295e-04*G0_1 - 7.054673721340343e-04*G0_2 - 1.128747795414456e-02*G0_3 + 2.793650793650778e-02*G0_4 - 1.128747795414456e-02*G0_5 - 8.465608465608418e-03*G0_6 + 4.232804232804068e-04*G0_7 + 5.643738977072389e-04*G0_8 + 5.643738977072396e-04*G0_9 + 4.232804232804163e-04*G0_10 - 8.465608465608414e-03*G0_11 - 6.772486772486735e-03*G0_12 + 3.386243386243383e-03*G0_13 + 3.386243386243379e-03*G0_14;
    block[5] = -9.876543209876513e-04*G0_0 + 1.410934744268068e-03*G0_2 + 6.772486772486738e-03*G0_3 - 1.128747795414456e-02*G0_4 + 2.257495590828913e-02*G0_5 + 1.128747795414456e-02*G0_6 - 8.465608465608409e-03*G0_7 + 4.514991181657822e-03*G0_8 + 2.257495590828906e-03*G0_9 + 5.643738977072293e-04*G0_10 + 4.514991181657822e-03*G0_11 - 2.257495590828928e-03*G0_12 + 2.257495590828915e-03*G0_13 + 1.128747795414457e-02*G0_14;
    block[6] = -9.876543209876507e-04*G0_1 + 1.410934744268068e-03*G0_2 + 4.514991181657825e-03*G0_3 - 8.465608465608418e-03*G0_4 + 1.128747795414456e-02*G0_5 + 2.257495590828913e-02*G0_6 - 1.128747795414455e-02*G0_7 + 6.772486772486734e-03*G0_8 + 4.514991181657822e-03*G0_9 + 5.643738977072281e-04*G0_10 + 2.257495590828909e-03*G0_11 + 2.257495590828898e-03*G0_12 - 2.257495590828906e-03*G0_13 + 1.128747795414457e-02*G0_14;
    block[7] = -7.054673721340328e-04*G0_0 - 1.058201058201054e-04*G0_1 - 7.054673721340334e-04*G0_2 + 5.643738977072475e-04*G0_3 + 4.232804232804062e-04*G0_4 - 8.465608465608407e-03*G0_5 - 1.128747795414455e-02*G0_6 + 2.793650793650779e-02*G0_7 - 1.128747795414455e-02*G0_8 - 8.465608465608402e-03*G0_9 + 4.232804232804167e-04*G0_10 + 5.643738977072468e-04*G0_11 + 3.386243386243405e-03*G0_12 - 6.772486772486716e-03*G0_13 + 3.386243386243392e-03*G0_14;
    block[8] = 1.410934744268066e-03*G0_0 - 9.876543209876511e-04*G0_1 + 2.257495590828912e-03*G0_3 + 5.643738977072390e-04*G0_4 + 4.514991181657822e-03*G0_5 + 6.772486772486733e-03*G0_6 - 1.128747795414455e-02*G0_7 + 2.257495590828915e-02*G0_8 + 1.128747795414457e-02*G0_9 - 8.465608465608431e-03*G0_10 + 4.514991181657830e-03*G0_11 + 1.128747795414459e-02*G0_12 - 2.257495590828913e-03*G0_13 + 2.257495590828918e-03*G0_14;
    block[9] = 1.410934744268068e-03*G0_0 - 9.876543209876483e-04*G0_2 + 4.514991181657824e-03*G0_3 + 5.643738977072393e-04*G0_4 + 2.257495590828906e-03*G0_5 + 4.514991181657822e-03*G0_6 - 8.465608465608404e-03*G0_7 + 1.128747795414457e-02*G0_8 + 2.257495590828913e-02*G0_9 - 1.128747795414457e-02*G0_10 + 6.772486772486735e-03*G0_11 + 1.128747795414456e-02*G0_12 + 2.257495590828901e-03*G0_13 - 2.257495590828900e-03*G0_14;
    block[10] = -7.054673721340341e-04*G0_0 - 7.054673721340338e-04*G0_1 - 1.058201058201056e-04*G0_2 - 8.465608465608425e-03*G0_3 + 4.232804232804158e-04*G0_4 + 5.643738977072296e-04*G0_5 + 5.643738977072278e-04*G0_6 + 4.232804232804172e-04*G0_7 - 8.465608465608431e-03*G0_8 - 1.128747795414457e-02*G0_9 + 2.793650793650780e-02*G0_10 - 1.128747795414457e-02*G0_11 + 3.386243386243356e-03*G0_12 + 3.386243386243373e-03*G0_13 - 6.772486772486737e-03*G0_14;
    block[11] = 1.410934744268066e-03*G0_1 - 9.876543209876485e-04*G0_2 + 1.128747795414456e-02*G0_3 - 8.465608465608416e-03*G0_4 + 4.514991181657822e-03*G0_5 + 2.257495590828908e-03*G0_6 + 5.643738977072467e-04*G0_7 + 4.514991181657830e-03*G0_8 + 6.772486772486735e-03*G0_9 - 1.128747795414457e-02*G0_10 + 2.257495590828913e-02*G0_11 + 2.257495590828924e-03*G0_12 + 1.128747795414456e-02*G0_13 - 2.257495590828904e-03*G0_14;
    block[12] = 1.410934744268062e-03*G0_0 - 1.410934744268077e-03*G0_1 - 1.410934744268071e-03*G0_2 - 2.257495590828917e-03*G0_3 - 6.772486772486736e-03*G0_4 - 2.257495590828927e-03*G0_5 + 2.257495590828899e-03*G0_6 + 3.386243386243405e-03*G0_7 + 1.128747795414459e-02*G0_8 + 1.128747795414456e-02*G0_9 + 3.386243386243354e-03*G0_10 + 2.257495590828924e-03*G0_11 + 9.481481481481445e-02*G0_12 - 1.354497354497349e-02*G0_13 - 1.354497354497348e-02*G0_14;
    block[13] = -1.410934744268069e-03*G0_0 + 1.410934744268066e-03*G0_1 - 1.410934744268071e-03*G0_2 + 1.128747795414457e-02*G0_3 + 3.386243386243381e-03*G0_4 + 2.257495590828915e-03*G0_5 - 2.257495590828906e-03*G0_6 - 6.772486772486716e-03*G0_7 - 2.257495590828914e-03*G0_8 + 2.257495590828901e-03*G0_9 + 3.386243386243373e-03*G0_10 + 1.128747795414456e-02*G0_11 - 1.354497354497350e-02*G0_12 + 9.481481481481449e-02*G0_13 - 1.354497354497348e-02*G0_14;
    block[14] = -1.410934744268073e-03*G0_0 - 1.410934744268072e-03*G0_1 + 1.410934744268068e-03*G0_2 + 2.257495590828918e-03*G0_3 + 3.386243386243379e-03*G0_4 + 1.128747795414457e-02*G0_5 + 1.128747795414457e-02*G0_6 + 3.386243386243391e-03*G0_7 + 2.257495590828918e-03*G0_8 - 2.257495590828900e-03*G0_9 - 6.772486772486737e-03*G0_10 - 2.257495590828903e-03*G0_11 - 1.354497354497348e-02*G0_12 - 1.354497354497348e-02*G0_13 + 9.481481481481437e-02*G0_14;
  }

  // No contribution from the boundary
  void eval(real block[], const AffineMap& map, unsigned int boundary) const {}   

};

} }

#endif
